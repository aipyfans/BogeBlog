<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android Studio PluginManager$StartupAbortedException 异常解决方案(Mac平台)]]></title>
    <url>%2F2018%2F08%2F03%2Fplugin_error%2F</url>
    <content type="text"><![CDATA[这是自己亲自动手解决的首个 Android Studio 异常，网上的方案大都是人云亦云，没有自己的思考 java.lang.RuntimeException: com.intellij.ide.plugins.PluginManager$StartupAbortedException: Fatal error initializing 原因我们从上面的异常名称来分析一下： PluginManager$StartupAbortedException 见名知意：由于插件管理导致的启动终止 最近有没有添加一些新的插件？ 有没有异常关机的情况？ 方案既然找到原因了，我们就要动手解决一下： 暴力方案：找到插件所在的文件夹，将整个插件文件夹删除 优雅方案：知道自己最近安装了哪些插件，删除指定的插件 出现此异常大多都是因为我们安装了第三方插件导致的不兼容异常 备注 Android Studio 【第三方插件】所在的文件夹路径【出现上面的异常，一般情况下，操作此文件夹】 1/Users/william/Library/Application Support/AndroidStudio3.1 Android Studio 【内置插件】所在的文件夹路径 1/Applications/Android Studio.app/Contents/plugins Android Studio IDE 【程序】所在的文件夹路径 1/Applications/Android Studio.app/Contents Android Studio IDE 【配置】所在的文件夹路径 1/Users/william/Library/Preferences/AndroidStudio3.1]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[写给女儿的歌词-Cover《成都》]]></title>
    <url>%2F2018%2F07%2F30%2Fmy-daughter-song%2F</url>
    <content type="text"><![CDATA[让我掉下眼泪的 不止送嫁的酒 让我依依不舍的 不止你的眼眸 余生路要走很久 他攒着你的手 让我心有不甘的 是放手的自由 回忆总是在深夜 忍不住冒出了头 将你稚嫩的温柔 托在我的肩头 在这个温馨的小家里 我一直呵护你 女儿 放不下的 只有你 和我在你儿时的街头走一走 直到所有的回忆都淡了也别逗留 你会挽着我的衣袖 我想牵着你的小手 笑着向你挥一挥手 坐在等你的家门口]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Lokijs 中文文档]]></title>
    <url>%2F2018%2F05%2F03%2Flokijs_index%2F</url>
    <content type="text"><![CDATA[Home Indexing and Performance Query Examples Changes API Persistence and Adapters Collection Transforms Autoupdating Collections]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[API的变化]]></title>
    <url>%2F2018%2F05%2F02%2Flokijs4_changes_api%2F</url>
    <content type="text"><![CDATA[OverviewLokiJS 1.1 introduces a “Changes API” that enables the user to keep track of the changes happened to each collection since a particular point in time, which is usually the start of a work session but it could be a user defined one. This is particularly useful for remote synchronization. Description of the Changes APIThe Changes API is a collection-level feature, hence you can establish which collections may simply contain volatile data and which ones need to keep a record of what has changed. The Changes API is an optional feature and can be activated/deactivated by either passing the option { disableChangesApi: isDisabled } in the config parameter of a collection constructor, or by calling collection.setChangesApi(isEnabled). Note that LokiJS will always set the fastest performing setting as default on a collection or database, hence the Changes API is disabled by default. There are three events which will trigger a Changes API operation: inserts, updates and deletes. When either of these events occur, on a collection with Changes API activated, the collection will store a snapshot of the relevant object, associated with the operation and the name of the collection. From the database object it is then possible to invoke the serializeChanges method which will generate a string representation of the changes occurred to be used for synchronization purposes. UsageTo enable the Changes API make sure to either instantiate a collection using db.addCollection(&#39;users&#39;, { disableChangesApi: false }), or call users.setChangesApi(true) (given an example users collection). To generate a string representation of the changes, call db.serializeChanges(). This will generate a representation of all the changes for those collections that have the Changes API enabled. If you are only interested in generating changes for a subset of collections, you can pass an array of names of the collections, i.e. db.serializeChanges([&#39;users&#39;]);. To clear all the changes, call db.clearChanges(). Alternatively you can call flushChanges() on the single collection, normally you would call db.clearChanges() on a callback from a successful synchronization operation. Each change is an object with three properties: name is the collection name, obj is the string representation of the object and operation is a character representing the operation (“I” for insert, “U” for update, “R” for remove). So for example, inserting user { name: &#39;joe&#39; } in the users collection would generate a change { name: &#39;users&#39;, obj: { name: &#39;joe&#39; }, operation: &#39;I&#39; }. Changes are kept in order of how the happened so a 3rd party application will be able to operate insert updates and deletes in the correct order.]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LokiJS 持久化以及适配器]]></title>
    <url>%2F2018%2F05%2F02%2Flokijs5_persistence_adapters%2F</url>
    <content type="text"><![CDATA[概述LokiJS持久化是通过适配器接口实现的。我们支持自动保存和自动加载选项，简单的键/值适配器以及参考模式的适配器，并且现在支持各种结构化序列化方法，可以轻松创建自己的持久化适配器以及批量或流式数据交换。 像lokijs这样的内存数据库和传统数据库系统之间的一个重要区别是，所有文档/记录都保存在内存中，并且不会根据需要加载。因此持久化仅用于保存和恢复这个内存数据库的状态。 如果您的数据库足够小，并且您希望尝试，则可以调用db.serialize()以返回完整序列化的数据库，并将其加载到另一个数据库实例中，如dbcopy.loadJSON(str)。 Node.js 快速开始If you are using lokijs in a node environment, we will automatically detect and use the built-in LokiFsAdapter without your needing to provide an adapter. No Persistence example (entirely synchronous and in memory) :123456789101112const loki = require("lokijs");var db = new loki("quickstart.db");var users = db.addCollection("users");users.insert(&#123;name:'odin', age: 50&#125;);users.insert(&#123;name:'thor', age: 35&#125;);var result = users.find(&#123; age : &#123; $lte: 35 &#125; &#125;);// dumps array with 1 doc (thor) to consoleconsole.log(result); Autosave/autoload quickstart with default LokiFsAdapter (async i/o) :1234567891011121314151617181920212223var db = new loki('quickstart.db', &#123; autoload: true, autoloadCallback : databaseInitialize, autosave: true, autosaveInterval: 4000&#125;);// implement the autoloadback referenced in loki constructorfunction databaseInitialize() &#123; var entries = db.getCollection("entries"); if (entries === null) &#123; entries = db.addCollection("entries"); &#125; // kick off any program logic or start listening to external events runProgramLogic();&#125;// example method with any bootstrap logic to run after database initializedfunction runProgramLogic() &#123; var entryCount = db.getCollection("entries").count(); console.log("number of entries in database : " + entryCount);&#125; If you expect your database to grow over 100mb or you experience slow save speeds you might to use our more high-performance LokiFsStructuredAdapter. This adapter utilitizes es6 generator iterators and node streams to stream the database line by line. It will also save each collection into its own file (partitioned) with a file name derived from the base name. This database should scale to support databases just under 1 gb on the default node heap allocation of 1.4gb. Increasing heap allocation, you can push this limit further. An example using fastest and most scalable LokiFsStructuredAdapter (for nodejs) might look like :12345678910111213141516171819202122const loki = require("lokijs");const lfsa = require('../src/loki-fs-structured-adapter.js');var adapter = new lfsa();var db = new loki('sandbox.db', &#123; adapter : adapter, autoload: true, autoloadCallback : databaseInitialize, autosave: true, autosaveInterval: 4000&#125;);function databaseInitialize() &#123; var log = db.getCollection("log"); if (log === null) &#123; db.addCollection("log"); &#125; // log some random event data as part of our example log.insert(&#123; event: 'dbinit', dt: (new Date()).getTime() &#125;);&#125; Web 快速开始If you are using lokijs in a web environment, we will automatically use the built-in LokiLocalStorageAdapter. This adapter is limited to around 5mb so that won’t last long but here is how to quickly get started experimenting with lokijs : 1&lt;script src="../../src/lokijs.js"&gt;&lt;/script&gt; Example constructing loki for in-memory only or manual save/load (with default localStorage adapter) :1var loki = new loki("test.db"); Example constructing loki for autoload/autosave (with default localStorage adapter) :123456789101112var db = new loki("quickstart.db", &#123; autoload: true, autoloadCallback : databaseInitialize, autosave: true, autosaveInterval: 4000&#125;);function databaseInitialize() &#123; if (!db.getCollection("users")) &#123; db.addCollection("users"); &#125;&#125; If you expect your database to grow up to 60megs you might want to use our LokiIndexedAdapter which can save to IndexedDb, if your browser supports it. Example using more scalable LokiIndexedAdapter :12&lt;script src=&quot;../../src/lokijs.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../../src/loki-indexed-adapter.js&quot;&gt;&lt;/script&gt; 12345678var idbAdapter = new LokiIndexedAdapter();var db = new loki(&quot;test.db&quot;, &#123; adapter: idbAdapter, autoload: true, autoloadCallback : databaseInitialize, autosave: true, autosaveInterval: 4000&#125;); If you expect your database to grow over 60megs things start to get browser dependent. To provide singular guidance and since Chrome is the most popular web browser you will want to employ our LokiPartitioningAdapter in addition to our LokiIndexedAdapter. To sum up as briefly as possible, this will divide collections into their own files and if a collection exceeds 25megs (customizable) it will subdivide into separate pages(files). This allows our indexed db adapter to accomplish a single database save/load using many key/value pairs. This adapter will allow scaling up to around 300mb or so in current testing. An example using the LokiPartitioningAdapter along with LokiIndexedAdapter might appear as :12&lt;script src=&quot;../../src/lokijs.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;../../src/loki-indexed-adapter.js&quot;&gt;&lt;/script&gt; 123456789101112var idbAdapter = new LokiIndexedAdapter();// use paging only if you expect a single collection to be over 50 megs or sovar pa = new loki.LokiPartitioningAdapter(idbAdapter, &#123; paging: true &#125;);var db = new loki(&apos;test.db&apos;, &#123; adapter: pa, autoload: true, autoloadCallback : databaseInitialize, autosave: true, autosaveInterval: 4000&#125;); Description of LokiNativescriptAdapterThis adapter can be used when developing a nativescript application for iOS or Android, it persists the loki db to the filesystem using the native platform api. Simple Example of using LokiNativescriptAdapter :12345const loki = require (&apos;lokijs&apos;);const LokiNativescriptAdapter = require(&apos;lokijs/src/loki-nativescript-adapter&apos;);let db = new loki(&apos;loki.json&apos;,&#123; adapter:new LokiNativescriptAdapter()&#125;); In addition to the above adapters which are included in the lokijs distro, several community members have also created their own adapters using this adapter interface. Some of these include : Cordova adapter : https://github.com/cosmith/loki-cordova-fs-adapter localForage adapter : https://github.com/paulhovey/loki-localforage-adapter Configuring persistence adaptersAutosave, Autoload and close()LokiJS now supports automatic saving at user defined intervals, configured via loki constructor options. This is supported for all persistenceMethods. Data is only saved if changes have occurred since the last save. You can also specify an autoload to immediately load a saved database during new loki construction. If you need to process anything on load completion you can also specify your own autoloadCallback. Finally, in an autosave scenario, if the user wants to exit or is notified of leaving the webpage (window.onbeforeunload) you can call close() on the database which will perform a final save (if needed). *Note : the ability of loki to ‘flush’ data on events such as a browsers onbeforeunload event, depends on the storage adapter being synchronous. Local storage and file system adapters are synchronous but indexeddb is asynchronous and cannot save when triggered from db.close() in an onbeforeunload event. The mouseleave event may allow enough time to perform a preemptive save.* Autosave example1234567var idbAdapter = new LokiIndexedAdapter(&apos;loki&apos;);var db = new loki(&apos;test&apos;, &#123; autosave: true, autosaveInterval: 10000, // 10 seconds adapter: idbAdapter &#125;); Autosave with autoload example1234567891011121314151617var idbAdapter = new lokiIndexedAdapter(&apos;loki&apos;);var db = new loki(&apos;test.db&apos;, &#123; autoload: true, autoloadCallback : loadHandler, autosave: true, autosaveInterval: 10000, // 10 seconds adapter: idbAdapter &#125;); function loadHandler() &#123; // if database did not exist it will be empty so I will intitialize here var coll = db.getCollection(&apos;entries&apos;); if (coll === null) &#123; coll = db.addCollection(&apos;entries&apos;); &#125;&#125; Try in Loki Sandbox. Save throttling and persistence contention managementLokiJS now supports throttled saves and loads to avoid overlapping saveDatabase and loadDatabase calls from interfering with each other. This is controlled by a loki constructor option called ‘throttledSaves’ and the default for that option is ‘true’. This means that within any single Loki database instance, multiple saves routed to the persistence adapter will be throttled and ensured to not conflict by overlap. With save throttling, during the time between an adapter save and an adapter response to that save, if new save requests come in we will queue those requests (and their callbacks) for a save which we will initiate immediately after the current save is complete. In that situation, if 10 requests to save had been made while a save is pending, the subsequent (single) save will callback all ten queued/tiered callbacks when -it- completes. If a loadDatabase call occurs while a save is pending, we will (by default) wait indefinitely for the queue to deplete without being replenished. Once that occurs we will lock all saves during the load… any incoming save requests made while the database is being loaded will then be queued for saving once the load is completed. Since loadDatabase now internally calls a new ‘throttledSaveDrain’ we will pass through options to control that drain. (These options will be summarized below). You may also directly call this ‘throttledSaveDrain’ loki method which can wait for the queue to drain. You might do this using any of these variations/options : 1234// wait indefinitely (recursively)db.throttledSaveDrain(function () &#123; console.log(&quot;no saves in progress&quot;);&#125;); 1234// wait only for the -current- queue to depletedb.throttledSaveDrain(function () &#123; console.log(&quot;queue drained&quot;);&#125;, &#123; recursiveWait: false &#125; ); 123456789// wait recursively but only for so long...db.throttledSaveDrain(function (success) &#123; if (success) &#123; console.log(&quot;no saves in progress&quot;); &#125; else &#123; console.log(&quot;taking too long, try again later&quot;); &#125;&#125;, &#123; recursiveWaitLimit: true, recursiveWaitLimitDuration: 2000 &#125;); If you do not wish loki to supervise these conflicts with its throttling contention management, you can disable this by constructing loki with the following option (in addition to any existing options you are passing) : 1var db = new loki(&apos;test.db&apos;, &#123; throttledSaves: false &#125;); Creating your own Loki Persistence AdaptersLokijs currently supports two types of database adapters : ‘basic’, and ‘reference’ mode adapters. Basic adapters are passed a string to save and return a string when loaded… this is well suited to key/value stores. Reference mode adapters are passed a reference to the database itself where it can save however it wishes to. When loading, reference mode adapters can return an object reference or serialized string. Below we will describe the minimal functionality which lokijs requires, you may want to provide additional adapter functionality for deleting or inspecting its persistence store. Creating your own ‘Basic’ persistence adapter12345678910111213MyCustomAdapter.prototype.loadDatabase = function(dbname, callback) &#123; // using dbname, load the database from wherever your adapter expects it var serializedDb = localStorage[dbname]; var success = true; // make your own determinations if (success) &#123; callback(serializedDb); &#125; else &#123; callback(new Error(&quot;There was a problem loading the database&quot;)); &#125;&#125; and a saveDatabase example might look like : 123456789101112MyCustomAdapter.prototype.saveDatabase = function(dbname, dbstring, callback) &#123; // store the database, for this example to localstorage localStorage[dbname] = dbstring; var success = true; // make your own determinations if (success) &#123; callback(null); &#125; else &#123; callback(new Error(&quot;An error was encountered loading &quot; + dbname + &quot; database.&quot;)); &#125;&#125; Creating your own ‘Reference Mode’ persistence adapterAn additional ‘level’ of adapter support would be for your adapter to support ‘reference’ mode support. This ‘reference’ mode will allow lokijs to provide your adapter with a reference to a lightweight ‘copy’ of the database sharing only the collection.data[] document object instances with the original database. You would use this reference to destructure or save however you want to. To instruct loki that your adapter supports ‘reference’ mode, you will need to implement a top level property called ‘mode’ on your adapter and set it equal to ‘reference’. Having done that and configured that adapter to be used, whenever loki wishes to save the database it will instead call out to an exportDatabase() method on your adapter. A simple example of an advanced ‘reference’ mode adapter might look like : 1234567891011121314151617181920212223242526272829303132function YourAdapter() &#123; this.mode = &quot;reference&quot;;&#125;YourAdapter.prototype.exportDatabase = function(dbname, dbref, callback) &#123; this.customSaveLogic(dbref); var success = true; // make your own determinations if (success) &#123; callback(null); &#125; else &#123; callback(new Error(&quot;some error occurred.&quot;)); &#125;&#125;// reference mode uses the same loadDatabase method signatureYourAdapter.prototype.loadDatabase = function(dbname, callback) &#123; // do some magic to reconstruct a new loki database object instance from wherever var newDatabase = this.customLoadLogic(); var success = true; // make you own determinations // once reconstructed, loki will expect either a serialized response or a Loki object instance to reinflate from if (success) &#123; callback(newSerialized); &#125; else &#123; callback(new Error(&quot;some error&quot;)); &#125;&#125; LokiPartitioningAdapterThis is an adapter for adapters. It wraps around and converts any ‘basic’ persistence adapter into one that scales nicely to your memory contraints. It can split your database up, saving each collection independently and only if changes have occurred since the last save. Since each collection is saved separately there is lower memory overhead and since only dirty collections are saved there is improved i/o save speeds. Chrome (using indexedDb) places a restriction on how large a single saved ‘chunk’ can be, this Partitioning adapter with just partitioning raises that limit from being ‘per db’ to ‘per collection’… when paging is enabled that limit is raised to being ‘per document’. Chrome indexedDb limit is somewhere around 30-60megs sized chunks. An example using partition adapter with our LokiIndexedAdapter might appear such as : 1234var idbAdapter = new LokiIndexedAdapter(&apos;appAdapter&apos;);var pa = new loki.LokiPartitioningAdapter(idbAdapter);var db = new loki(&apos;sandbox.db&apos;, &#123; adapter: pa &#125;); If you expect a single collection to grow rather large you may even want to utilize an additional ‘paging’ mode that this adapter provides. This is useful if you want to limit the size of data sent to the inner persistence adapter. This paging mode was added to accomodate a Chrome limitation on maximum record sizes. An example using paging mode might appear as follows : 1234var idbAdapter = new LokiIndexedAdapter(&apos;appAdapter&apos;);var pa = new loki.LokiPartitioningAdapter(idbAdapter, &#123; paging: true &#125;);var db = new loki(&apos;sandbox.db&apos;, &#123; adapter: pa &#125;); You can also pass in a pageSize option if you wish to use a page size other than the default 25meg page size. 12// set up adapter to page using 35 meg page sizevar pa = new loki.LokiPartitioningAdapter(idbAdapter, &#123; paging: true, pageSize:35*1024*1024 &#125;); LokiMemoryAdapterThis ‘basic’ persistence adapter is only intended for experimenting and testing since it retains its key/value store in memory and will be lost when session is done. This enables us to verify the partitioning adapter works and can be used to mock persistence for unit testing. You might access this memory adapter (which is included in the main source file) similarly to the following : 12var mem = new loki.LokiMemoryAdapter();var db = new loki(&apos;sandbox.db&apos;, &#123;adapter: mem&#125;); If you wish to simulate asynchronous ‘basic’ adapter you can pass options to its constructor : 123// simulate 50ms async delay for loads and saves. this will yield thread until thenvar mem = new loki.LokiMemoryAdapter(&#123; asyncResponses: true, asyncTimeout: 50 &#125;);var db = new loki(&apos;sandbox.db&apos;, &#123;adapter: mem&#125;); In order to see LokiPartitioningAdapter used in conjunction with LokiMemoryAdapter you can view this Loki Sandbox gist in your browser. What is happening in the gist linked above is that we create an instance of a LokiMemoryAdapter and pass that instance to the LokiPartitioningAdapter. We utilimately pass in the created LokiPartitioningAdapter instance to the database constructor. We then add multiple collections to our database, save it, update one of the collections (causing that collection’s ‘dirty’ flag to be set), and save again. When we examine the output of the script we can view the contents of the memory adapter’s internal hash store to see how there are multiple keys for a single database. We can also see that our modified collection (along with the database container itself) was saved again. The database container currently has no ‘dirty’ flag set but since we remove all collection.data[] object instances from it, it is relatively lightweight. ‘Rolling your own’ structured serialization mechanismIn addition to the ChangesAPI which can be utilized to isolate changesets, LokiJS has established several internal utility methods to assist users in developing optimal persistence or transmission of database contents. Those mechanisms include the ability to decompose the database into ‘partitions’ of structured serializations or assembled into a line oriented format (non-partitioned) and either delimited (single delimited string per collection) or non-delimited (array of strings, one per document). These utility methods are located on the Loki object instance itself as the ‘serializeDestructured’ and ‘deserializeDestructured’ methods. They can be invoked to create structured json serialization for the entire database, or (if you pass a partition option) it can provide a single partition at a time. Internal loki structured serialization in its current form provides mild memory overhead reduction and decreases I/O time if only some collections need to be saved. It may also be useful for other data exchange or synchronization mechanisms. In lokijs terminology the partitions of a database include the database container (partition -1) along with each individual collection (partitions 0-n). To destructure in various formats you can experiment with the following parameters : 1234var result = db.serializeDestructured(&#123; partitioned: false, delimited: false&#125;); To destructure a single partition you might use the following syntax and experiment with ‘delimited’ and ‘partition’ properties : 12345var result = db.serializeDestructured(&#123; partitioned: true, partition: 1, delimited: false&#125;); To experiment with the various structured serialization formats you can view this Loki Sandbox gist and try various combinations of ‘partitioned’ and ‘delimited’ options (making sure both the serializeDestructured and deserializeDestructured use the same values. Destructuring (making many smaller json serializations vs one large serialization) does not lower memory overhead but seems to be a little faster. Partitioning can reduce memory overhead if you can dispose of those memory chunks before advancing to the next (which our adapter implementations do). Our 2.0.0 branch which is able to use ES6 language constructs may gain an iterable interface in the future for data exchange or line-by-line streaming. If your database is small enough you can use the LokiPartitioningAdapter (with or without paging) along with LokiMemoryAdapter to decompose database into appropriately sized ‘chunks’ for transmission. Detailed LokiIndexedAdapter DescriptionOur LokiIndexedAdapter is implemented as a ‘basic’ mode loki persistence adapter. Since this will probably be the default web persistence adapter, this section will overview some of its advanced features. It implements persistence by defining an app/key/value database in indexeddb for storing serialized databases (or partitions). The ‘app’ portion is designated when instantiating the adapter and loki only supplies it key/value pair for storage. Simple Example of using LokiIndexedAdapter (for browser environments) :12&lt;script src=&quot;scripts/lokijs/lokijs.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;scripts/lokijs/loki-indexed-adapter.js&quot;&gt;&lt;/script&gt; … 12var idbAdapter = new LokiIndexedAdapter(&apos;finance&apos;);var db = new loki(&apos;test&apos;, &#123; adapter: idbAdapter &#125;); Note the ‘finance’ in this case represents an ‘App’ context and the ‘test’ designates the key (or database name)… the ‘value’ is the serialized strings representing your database which loki will provide. Advantages include larger storage limits over localstorage, and a catalog based approach where you can store many databases, grouped by an ‘App’ context. Since indexedDB storage is provided ‘per-domain’, and on any given domain you might be running several web ‘apps’ each with its own database(s), this structure allows for organization and expandibility. *Note : the ‘App’ context is an conceptual separation, not a security partition. Security is provided by your web browser, partitioned per-domain within client storage in the browser/system.* Loki Indexed adapter interfaceIn addition to core loadDatabase and saveDatabase methods, the loki Indexed adapter provides the ability to getDatabaseList (for the current app context), deleteDatabase, and getCatalogSummary to retrieve unfiltered list of app/keys along with the size in database. (Note sizes reported may not be Unicode sizes so effective ‘size’ it may consume might be double that amount as indexeddb saves in Unicode). The loki indexed adapter also is console-friendly… even though indexeddb is highly asynchronous, relying on callbacks, you can omit callbacks for many of its methods and will log results to console instead. This makes experimenting, diagnosing, and maintenance of loki catalog easier to learn and inspect. Full Examples of using loki indexed adapter123456789101112131415161718192021222324252627282930313233343536373839404142// Save : will save App/Key/Val as &apos;finance&apos;/&apos;test&apos;/&#123;serializedDb&#125;// if appContect (&apos;finance&apos; in this example) is omitted, &apos;loki&apos; will be usedvar idbAdapter = new lokiIndexedAdapter(&apos;finance&apos;);var db = new loki(&apos;test&apos;, &#123; adapter: idbAdapter &#125;);var coll = db.addCollection(&apos;testColl&apos;);coll.insert(&#123;test: &apos;val&apos;&#125;);db.saveDatabase(); // could pass callback if needed for async complete// Load databasevar idbAdapter = new LokiIndexedAdapter(&apos;finance&apos;);var db = new loki(&apos;test&apos;, &#123; adapter: idbAdapter &#125;);db.loadDatabase(&#123;&#125;, function(result) &#123; console.log(&apos;done&apos;);&#125;);// Get database listvar idbAdapter = new LokiIndexedAdapter(&apos;finance&apos;);idbAdapter.getDatabaseList(function(result) &#123; // result is array of string names for that appcontext (&apos;finance&apos;) result.forEach(function(str) &#123; console.log(str); &#125;);&#125;);// Delete databasevar idbAdapter = new LokiIndexedAdapter(&apos;finance&apos;);idbAdapter.deleteDatabase(&apos;test&apos;); // delete &apos;finance&apos;/&apos;test&apos; value from catalog// Delete database partitions and/or pages// This deletes all partitions or pages derived from this base filenamevar idbAdapter = new LokiIndexedAdapter(&apos;finance&apos;);idbAdapter.deleteDatabasePartitions(&apos;test&apos;); // Summaryvar idbAdapter = new LokiIndexedAdapter(&apos;finance&apos;);idbAdapter.getCatalogSummary(function(entries) &#123; entries.forEach(function(obj) &#123; console.log(&quot;app : &quot; + obj.app); console.log(&quot;key : &quot; + obj.key); console.log(&quot;size : &quot; + obj.size); &#125;);&#125;); Examples of using loki Indexed adapter from console1234567// CONSOLE USAGE : if using from console for management/diagnostic, here are a few examples :var adapter = new LokiIndexedAdapter('loki'); // or whatever appContext you want to useadapter.getDatabaseList(); // with no callback passed, this method will log results to consoleadapter.saveDatabase('UserDatabase', JSON.stringify(myDb));adapter.loadDatabase('UserDatabase'); // will log the serialized db to consoleadapter.deleteDatabase('UserDatabase');adapter.getCatalogSummary(); // gets list of all keys along with their sizes]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[查询示例]]></title>
    <url>%2F2018%2F05%2F02%2Flokijs3_query_examples%2F</url>
    <content type="text"><![CDATA[注意：我们现在在这个库的’examples’子文件夹中有几个快速入门示例。 https://github.com/techfort/LokiJS/blob/master/examples/quickstart-core.js https://github.com/techfort/LokiJS/blob/master/examples/quickstart-chaining.js https://github.com/techfort/LokiJS/blob/master/examples/quickstart-transforms.js https://github.com/techfort/LokiJS/blob/master/examples/quickstart-dynview.js 对于持久性示例，我们在 Loki Sandbox 中的 示例文件夹 和Web快速入门要点中编号了节点快速入门。 设计查询LokiJS衍生出了多种查询数据库的机制。在最高抽象层次上，让我们将这些方法分为以下几类： 核心方法 - 直接应用于集合的查询的简单而强大的方法。 链（通过Resultset） - 允许按顺序排序(sorting)，限制(limiting)，偏移(offsets)和多个查询(multiple queries)。 链变换 - 类似于上面的方法链，但在可以序列化的对象结构中定义。 动态视图 - 允许具有可能较大结果集的常用查询以获得最佳性能和可用性。 在每种方法中，您的查询通常属于find和where类别。 ‘Where’ 查询这些查询利用JavaScript函数来过滤数据。这是用于过滤集合中文档的最慢但最通用的方法。从本质上讲，我们将在集合中的每个文档上应用过滤器，以查看它是否应该放在结果集中。 123456789101112// 简单的匿名过滤器var results = coll.where(function(obj) &#123; return obj.legs === 8;&#125;);// -或- 设置命名过滤器函数function sleipnirFilter(obj) &#123; return obj.legs === 8;&#125;// 然后传递给where函数results = coll.where(sleipnirFunction); ‘Find’ 查询Find查询基于mongo查询语法的子集，并且能够使用索引来加速查询。与集合变换(Collection Transforms)或动态视图(Dynamic Views)一起使用时，这些过滤器可以保存到数据库本身中。这是查询Loki数据库的首选方法。使用Find查询所有内容（或尽可能多地过滤），如果发现不支持的边界情况，则使用&#39;where&#39;过滤。 ‘Find’ 操作符示例 :[目前增加和审查几个操作符的功能…我们可能应该用更好的例子来扩展本节的更多细节] 目前支持的主要操作符： $eq-(equal) - 过滤具有(严格)相等属性的文档 12345// 隐式（假设已经使用了$eq运算符）var results = coll.find(&#123;'Name': 'Odin'&#125;);// 显式 $eqresults = coll.find(&#123;'Name': &#123; '$eq' : 'Odin' &#125;&#125;); $ne-(not equal) -对属性不等于提供值的文档进行过滤 12// 不等于测试var results = coll.find(&#123;'legs': &#123; '$ne' : 8 &#125;&#125;); $aeq-(abstract equal) - 过滤具有抽象（非严格）等同性质的文档 12// 将匹配20岁或20岁的文档var results = coll.find(age: &#123;$aeq: 20&#125;); $dteq-(date equal) - 过滤日期属性等于提供日期值的文档 12345678var dt1 = new Date("1/1/2017");var dt2 = new Date("1/1/2017");items.insert(&#123; name : 'mjolnir', created: dt1 &#125;);items.insert(&#123; name : 'gungnir', created: dt2 &#125;);//返回上述两个插入的文档var results = items.find(&#123; created: &#123; $dteq: new Date("1/1/2017") &#125; &#125;); $gt-(greater than) - 过滤属性大于提供值的文档 1var results = coll.find(&#123;'age': &#123;'$gt': 40&#125;&#125;); $gte-(greater than equal) -过滤具有大于或等于提供值的属性的文档 1var results = coll.find(&#123;'age': &#123;'$gte': 40&#125;&#125;); $lt-(less than) - 过滤属性小于提供值的文档 1var results = coll.find(&#123;'age': &#123;'$lt': 40&#125;&#125;); $lte-(less than equal) - 过滤属性小于或等于提供值的文档 1var results = coll.find(&#123;'age': &#123;'$lte': 40&#125;&#125;); $between - 通过提供的属性过滤出在提供的值之间的文档 12// 匹配50至75之间的计数值的用户var results = users.find(&#123; count : &#123; '$between': [50, 75] &#125;&#125;); 注意：上面的$gt，$gte，$lt，$lte和$ops之间使用&#39;loki&#39;排序，它提供了一个统一范围的actoss混合类型，并返回相同的结果，无论属性是否被索引。这对二进制索引和保证索引和非索引比较结果相等是必需的。 如果您不希望利用二进制索引，并且您希望简单的JavaScript比较可以接受，那么我们提供以下操作（由于它们的简化比较）可以提供更优化的执行速度。 $jgt-(javascipt greater than) - 过滤(使用简化的JavaScript比较)出具有大于给定值的属性的文档 12&gt; var results = coll.find(&#123;'age': &#123;'$jgt': 40&#125;&#125;);&gt; $jgte-(javascipt greater than equal) - 过滤(使用简化的JavaScript比较)出具有大于等于给定值的属性的文档 12&gt; var results = coll.find(&#123;'age': &#123;'$jgte': 40&#125;&#125;);&gt; $jlt-(javascipt less than) - 过滤(使用简化的JavaScript比较)出具有小于给定值的属性的文档 12&gt; var results = coll.find(&#123;'age': &#123;'$jlt': 40&#125;&#125;);&gt; $jlte-(javascipt less than equal) - 过滤(使用简化的JavaScript比较)出具有小于等于给定值的属性的文档 12&gt; var results = coll.find(&#123;'age': &#123;'$jlte': 40&#125;&#125;);&gt; $jbetween- 通过提供的属性过滤(使用简化的JavaScript比较)出在提供的值之间的文档 12&gt; var results = users.find(&#123; count : &#123; '$jbetween': [50, 75] &#125;&#125;);&gt; $regex - 根据提供的正则表达式过滤出具有属性匹配的文档 如果在命名转换或动态视图过滤器中使用正则表达式操作符，最好使用后两个示例，因为原始正则表达式好像没有序列化/反序列化。 12345678// 传入原始正则表达式var results = coll.find(&#123;'Name': &#123; '$regex' : /din/ &#125;&#125;);//或仅传递字符串模式results = coll.find(&#123;'Name': &#123; '$regex': 'din' &#125;&#125;);// 或传入[pattern，options]字符串数组results = coll.find(&#123;'Name': &#123; '$regex': ['din', 'i'] &#125;&#125;); $in - 过滤具有与所提供的数组值相匹配的属性的文档。你的属性不应该是一个数组，但你的比较值应该是。 123456users.insert(&#123; name : 'odin' &#125;);users.insert(&#123; name : 'thor' &#125;);users.insert(&#123; name : 'svafrlami' &#125;);// 在数组集合['odin'，'thor']中将用户与名称进行匹配var results = users.find(&#123; 'name' : &#123; '$in' : ['odin', 'thor'] &#125; &#125;); $nin - 过滤具有与所提供的数组值不匹配的属性的文档。 123456users.insert(&#123; name : 'odin' &#125;);users.insert(&#123; name : 'thor' &#125;);users.insert(&#123; name : 'svafrlami' &#125;);// 将用户与名称不匹配的用户匹配['odin'，'thor']（仅svafrlami文档符合）var results = users.find(&#123; 'name' : &#123; '$nin' : ['odin', 'thor'] &#125; &#125;); $keyin - filter for document(s) whose property value is defined in the provided hash object keys.(Equivalent to $in: Object.keys(hashObject)) ( #362, #365 ) 1234categories.insert(&#123; name: 'Title', column: 'title'&#125;)// since the op doesn't use the title value, this is most effective with existing objectsvar result = categories.find(&#123;column: &#123; $keyin: &#123; title: 'anything'&#125; &#125;&#125;); $nkeyin - filter for document(s) whose property value is not defined in the provided hash object keys. (Equivalent to $nin: Object.keys(hashObject)) ( #362, #365 ) 1var result = categories.find(&#123;column: &#123; $nkeyin: &#123; title: 'anything'&#125; &#125;&#125;); $definedin - filter for document(s) whose property value is defined in the provided hash object as a value other than undefined. #285 1234567items.insert(&#123; name : 'mjolnir', owner: 'thor', maker: 'dwarves' &#125;);items.insert(&#123; name : 'gungnir', owner: 'odin', maker: 'elves' &#125;);items.insert(&#123; name : 'tyrfing', owner: 'Svafrlami', maker: 'dwarves' &#125;);items.insert(&#123; name : 'draupnir', owner: 'odin', maker: 'elves' &#125;);// returns gungnir and draupnir. similar to $keyin, the value ('rule') is not used by the opvar results = items.find(&#123;maker: &#123; $efinedin: &#123; elves: 'rule' &#125; &#125; &#125;); $undefinedin - filter for document(s) whose property value is not defined in the provided hash object or defined but is undefined. #285 1234567items.insert(&#123; name : 'mjolnir', owner: 'thor', maker: 'dwarves' &#125;);items.insert(&#123; name : 'gungnir', owner: 'odin', maker: 'elves' &#125;);items.insert(&#123; name : 'tyrfing', owner: 'Svafrlami', maker: 'dwarves' &#125;);items.insert(&#123; name : 'draupnir', owner: 'odin', maker: 'elves' &#125;);// returns mjolnir and tyrfing where the 'dwarves' val is not a property on our passed objectvar results = items.find(&#123;maker: &#123; $undefinedin: &#123; elves: 'rule' &#125; &#125; &#125;); $contains - 过滤包含提供值的属性的文档. ( commit, #205 ). 当你的属性包含一个数组，但你的比较值不是一个数组时，请使用它。. 当typeof属性是： string: 它会为你的字符串做一个子字符串匹配(indexOf) array: 它会检查该数组中是否存在“value”(indexOf) object: 它会检查你的’值’是否是该对象的一个定义的属性 1234567users.insert(&#123; name : 'odin', weapons : ['gungnir', 'draupnir']&#125;);users.insert(&#123; name : 'thor', weapons : ['mjolnir']&#125;);users.insert(&#123; name : 'svafrlami', weapons : ['tyrfing']&#125;);users.insert(&#123; name : 'arngrim', weapons : ['tyrfing']&#125;);// returns 'svafrlami' and 'arngrim' documentsvar results = users.find(&#123; 'weapons' : &#123; '$contains' : 'tyrfing' &#125; &#125;); $containsAny - 过滤包含任何提供值的属性的文档。当你的属性包含一个数组时，使用这个 - 并且你的比较值是一个数组。 When typeof property is : string: 它会为你的字符串做一个子字符串匹配(indexOf) array: 它会检查该数组中是否存在“value”(indexOf) object: 它会检查你的’值’是否是该对象的一个​定义的属性 1234567users.insert(&#123; name : 'odin', weapons : ['gungnir', 'draupnir']&#125;);users.insert(&#123; name : 'thor', weapons : ['mjolnir']&#125;);users.insert(&#123; name : 'svafrlami', weapons : ['tyrfing']&#125;);users.insert(&#123; name : 'arngrim', weapons : ['tyrfing']&#125;);// returns 'svafrlami', 'arngrim', and 'thor' documentsresults = users.find(&#123; 'weapons' : &#123; '$containsAny' : ['tyrfing', 'mjolnir'] &#125; &#125;); $containsNone - 过滤具有不包含所提供的值的属性的文档 1234567users.insert(&#123; name : 'odin', weapons : ['gungnir', 'draupnir']&#125;);users.insert(&#123; name : 'thor', weapons : ['mjolnir']&#125;);users.insert(&#123; name : 'svafrlami', weapons : ['tyrfing']&#125;);users.insert(&#123; name : 'arngrim', weapons : ['tyrfing']&#125;);// returns 'svafrlami' and 'arngrim'results = users.find(&#123; 'weapons' : &#123; '$containsNone' : ['gungnir', 'mjolnir'] &#125; &#125;); $type - 过滤具有指定类型属性的文档 123456789users.insert([ &#123; name: 'odin', weapons: ['gungnir', 'draupnir'] &#125;, &#123; name: 'thor', weapons: 'mjolnir' &#125;, &#123; name: 'svafrlami', weapons: ['tyrfing'] &#125;, &#123; name: 'arngrim', weapons: ['tyrfing'] &#125;]);// 返回docs（非数组）字符串值为'weapons'（mjolnir）var results = users.find(&#123; 'weapons' : &#123; '$type' : 'string' &#125; &#125;); $finite - 过滤具有数字或非数字属性的文档。 12// 返回所有文档，其中isFinite（doc.age）=== truevar results = users.find(&#123; age: &#123; $finite: true &#125;&#125;); $size - 筛选具有指定大小的数组属性的文档。（不适用于字符串） 123456789users.insert([ &#123; name: 'odin', weapons: ['gungnir', 'draupnir'] &#125;, &#123; name: 'thor', weapons: 'mjolnir' &#125;, &#123; name: 'svafrlami', weapons: ['tyrfing'] &#125;, &#123; name: 'arngrim', weapons: ['tyrfing'] &#125;]);// 返回docs'weapons'是2个元素数组（odin）var results = users.find(&#123; 'weapons' : &#123; '$size' : 2 &#125; &#125;); $len - 筛选具有指定长度的字符串属性的文档。 123456789users.insert([ &#123; name: 'odin', weapons: ['gungnir', 'draupnir'] &#125;, &#123; name: 'thor', weapons: 'mjolnir' &#125;, &#123; name: 'svafrlami', weapons: ['tyrfing'] &#125;, &#123; name: 'arngrim', weapons: ['tyrfing'] &#125;]);// returns docs where 'name' is a 9 character string (svafrllami)var results = users.find(&#123; 'name' : &#123; '$len' : 9 &#125; &#125;); $and - 筛选符合所有嵌套子表达式的文档 12345678910111213141516// 获取匹配两个子表达式的文档var results = coll.find(&#123; '$and': [&#123; 'age' : &#123; '$gt': 30 &#125; &#125;,&#123; 'name' : 'Thor' &#125;]&#125;);// alternative 'implicit' syntax :results = coll.find(&#123; age: &#123; $gt: 30 &#125;, name: 'Thor'&#125;); $or - 筛选符合任何嵌套子表达式的文档 12345678910// 获取匹配任何子表达式的文档var results = coll.find(&#123; '$or': [&#123; 'age' : &#123; '$gte': '40' &#125; &#125;,&#123; 'name' : 'Thor' &#125;]&#125;); 支持“find”查询的功能这些操作符可用于组合查找过滤对象，可用于以下内容中： Collection find() Collection findOne() (chained) Resultset find() Collection Transforms DynamicView applyFind() 程序化查询示例以下查询返回相同的结果： 12345678910// Core collection 'find' methodvar results = coll.find(&#123;'Age': &#123;'$gte': 40&#125;&#125;);// Resultset chainingresults = coll.chain().find(&#123;'Age': &#123;'$gte': 40&#125;&#125;).data();// Core collection 'where' methodresults = coll.where(function(obj) &#123; return obj.Age &gt;= 40;&#125;); Resultset 链核心find和where功能是Resultset链允许您构建的两个主要构建块。其他可用的方法包括： limit - 允许将结果集限制为指定数量的文档。 offset - 允许从结果集中跳过第一批数据文档。 branch - 用于将查询路径分成多个分支。 simplesort - 只需传递一个属性名称，你的resulset就会按这个排序。 sort - 允许您提供自己的比较函数来对结果集进行排序。 compoundsort - 允许您根据多个属性按升序或降序排序。 update - 用于对当前结果集中的所有文档运行更新操作（JavaScript函数）。 remove - 从集合中删除当前处于结果集中的所有文档对象（以及结果集） map - 映射到一个新的匿名集合中，提供一个映射函数 mapReduce - 允许您在当前结果集数据上指定map函数和reduce函数。 eqJoin - 左连接两组数据。连接键可以被定义或计算属性 transform - 在结果集级别，这需要一个原始转换数组。当开始一个链时，一个命名或原始的转换可能被传入链式方法。 (See the ‘Collection Transforms’ wiki page for more details.) 更好地使用方法链的例子可能如下： 123456789var results = coll.chain() .find(&#123;'Age': &#123;'$gt':20&#125;&#125;) .where(function(obj) &#123; return obj.Country.indexOf('FR') === 0; &#125;) .simplesort('Name') .offset(100) .limit(25) .data(); 结果集分支(Resultset branching)结果集及其结果并不意味着被“持有”。这些情况通常涉及利用动态视图来保持结果最新。但是，只要您想在发生任何插入/更新/删除之前，立即使用结果集，您可以随时临时分支Resulset。动态视图还允许分支结果集，而结果集又取其内部的结果集，并使用此分支来允许您进一步查询和转换其结果，而不会受到已执行过的过滤器的初始化时的影响。 集合分支的一个简单示例，如下所示： 12345var baseResulset = coll.chain().find(&#123;'Age': &#123;'$gte': 40&#125;&#125;);var branchedResulset = baseResultset.branch();var usResults = baseResultset.find(&#123;'Country': 'US'&#125;).data();var ieResults = branchedResulset.find(&#123;'Country': 'IE'&#125;).data(); 如果基础查询耗费时间，则您的后续分支无需承担该通用成本，这样做的好处是。在大型集合或对时间敏感的应用程序中，分支通常更有用。 如果您需要检查链中各个阶段的data()或文档计数，则可以保留结果集（即使未分支时）以将链分成几个部分。 总结尽可能在’Where’查询之前使用’Find’查询。如果它们被应用并与您的查询有关，则“Find”查询能够使用索引。 核心（Collection）的查询方法（Collection.where(), Collection.find(), Collection.findOne(), Collection.by()）是学习lokijs的最佳方法。对于许多应用程序来说，这可能足以满足您的查询需求。不可用的功能(尚未提供)是排序(sorting)，限制(limiting)，偏移(offsets)和其他更高级别的转换。 链查询通过调用collection.chain()方法返回的Resultset类来完成。 这样做，为我们的查询建立一个state。您可以将多个查找(find)，过滤(where)，排序(sorts)，限制(limit)，偏移(offset)等操作串在一起，逐步过滤和转换结果。 您也可以建立查询分支，尽可能高效地将查询分解为多个方向。通过结果集进行链调用仍然用于即时评估。 如果您将结果集保留在内存中，则不保证底层数据发生更改时保持最新状态。 只有第一个链的操作可能会使用数据库过滤器，因此优先考虑最昂贵的find()过滤器（其中应用了索引）作为第一个链接操作。 通过链变换允许在对象中定义与方法链相同的功能，其功能类似于存储过程。 由于它是对象表示，因此可以（可选）命名并与数据库一起保存。此方法也用于即时评估。 DynamicViews旨在让fresh的数据库视图随时可用。 您可以应用find和where过滤器，并指定排序。 随着文档的插入，更新或删除，您查看的内容将立即保持最新状态。 这可以确保您的视图具有最佳的读取性能，因为它始终处于最新状态。 如果您的视图需要进一步过滤，则可以将结果集从其中分离出来。 在分支DynamicView的时候，您可以在该时刻捕获DynamicView内部结果集的快照，从而可以执行各种各样的链接操作以进行即时评估。 因此，如果您执行DynamicView分支，请将视图视为保证fresh，并将分支视为快速一次性分支进行评估。]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[索引和查询性能]]></title>
    <url>%2F2018%2F05%2F02%2Flokijs2_index_query%2F</url>
    <content type="text"><![CDATA[Loki.js一直是快速的内存数据库解决方案。事实上，最近的基准测试表明，在node.js下运行的终端Core i5中，其主要的get()操作速度约为每秒140万次。get() 操作利用一个自动生成的 &#39;$loki id 列和自己生成的二进制索引。如果您希望提供您自己的unique key，则可以添加单个唯一的索引到集合中，便可使用collection.by()方法进行获取。这种方法比使用内置的$loki id快得多。因此，如果您打算进行单一对象查找，就可以获得此优化的性能。 使用自动生成的$loki列查找示例 :12345var users = db.addCollection("users");var resultObj = users.insert(&#123;username:"Heimdallr"&#125;);// 现在我们的对象已经被插入，它将会添加一个`$loki`属性var heimdallr = users.get(resultObj.$loki); 示例对象查找指定您自己的唯一索引 :123456var users = db.addCollection("users", &#123; unique: ['username']&#125;);// 插入记录后，您可能会使用coll.by()检索记录var result = users.by("username", "Heimdallr"); ‘Find’ 过滤更通用的查询方式是使用接受mongo风格查询对象的collection.find()。如果您没有为正在搜索的列添加索引，可以在node.js下获得预期约 20k ops/sec (浏览器性能可能会有所不同，但这是一个很好的数量级)。对于大多数情况下，性能可能比需要的更高，但现在可以在对象属性上应用loki.js二进制索引。使用collection.ensureIndex(propertyName)方法，您可以创建一个可以被各种find()操作使用的索引，例如collection.find()。对于我们的测试基准，这会将性能提高到大约500k ops/sec。 二进制索引可以与范围操作符一起使用，返回给定属性/范围的多个文档结果。如果您已将二进制索引应用于属性，则可以通过使用包含该属性的查询对象调用collection.find()来利用该索引。能够使用二进制索引的find()操作符包括$eq, $aeq, $lt, $lte, $gt, $gte, $between, $in. 默认情况下，如果您在属性上应用了二进制索引，并且将包含JavaScript Date对象的文档作为该属性的值插入，则 loki 将用可序列化安全的历元时间格式日期（整数）替换它。这是为了防止索引变得不可维护，如果我们将它保存为Date并将其作为字符串加载（它们就可以不同的顺序排序）。如果你不打算保存你的数据库（完全在内存中使用），你可以在创建集合时传递一个&#39;serializableIndices：false&#39;选项，我们不会改变你的日期。 二进制索引示例 :123456var coll = db.addCollection('users', &#123; indices: ['location']&#125;);// 插入记录后，您可以使用相等或范围操作符,如这种隐式 (strict) $eq op :var results = users.find(&#123; location: 'Himinbjörg' &#125;); Loki 的排序和范围 Native JavaScript提供 ==（abstract）相等，===（strict）相等，&lt;（abstract）小于，&gt;（abstract）大于等等。JavaScript处理很多混合类型，所以你可能想要一个数字4（abstract）等于字符串’4’。如果你想测试’小于’4，它会默认转换为字符串，所以如果你不想要字符串，你将不得不使用&#39;typeof&#39;或其他类型检测来手动过滤掉其他类型。Loki倾向于处理纯数据，但必须动态变化以支持额外发现的各种“脏”数据。因此，我们试图调整“范围”的概念，因为它涉及属性上的混合类型，以便它们适应混合类型，并提供类似的find()结果，而不管您是否使用二进制索引。 loki中的所有值都被我们的find()操作解释为“小于”，“大于” 或 “等于” 任何其他值。这与JavaScript不同，所以loki在两个值之间建立了统一的范围排序。 4 是 $aeq (非严格等于) &#39;4&#39;, 正如 &#39;3&#39; $lt(小于) 4, 和 4 is $gte(大于) &#39;3&#39;, 所以混合数字和’数字’字符串范围在loki中查找数字。 ‘数字’字符串与’非数字’字符串保持在不同的范围（数字），所以9999将会是$lt &#39;111asdf&quot;。 对象都是平等的（除非使用点符号来查询对象属性）。 日期按照他们的纪元时间排序为数字……这些数字很大，一般在数字范围的顶端。 $type op可用于过滤不符合特定JavaScript类型的结果。 $finite op 可用于过滤出“数字”或“非数字”的结果。 ‘Where’ 过滤器如果性能受到关注，应该谨慎使用’Where’过滤器（JavaScript过滤器函数）。他们无法使用索引，因此性能不会比未索引查找更好，并且取决于过滤器函数的复杂性，甚至更少。Unindex查询以及过滤器始终需要完整阵列扫描的位置，但如果数千ops/sec足够用，或稍后在查询链或动态视图过滤器管道中使用，并且惩罚更少，则它们可能非常有用。 在查询链中进行索引Resultset类引入了方法链作为查询选项。您可以使用方法链来连续应用几个查找操作，或者将find()，where()和sort()操作混合到顺序链式管道中。为了简单起见，这个例子可能是（其中用户是一个集合对象）： 1users.chain().find(queryObj).where(queryFunc).simplesort(&apos;name&apos;).data(); 检查这个语句，如果queryObj（一个mongo风格的查询对象）是{&#39;age&#39;：{&#39;$ gt&#39;：30}}，那么这个年龄段列表最好应用一个索引，并且find()链操作应该在方法链中排名第一。在链式操作中，只有第一个链式过滤器可以利用索引进行过滤。如果它筛选出足够数量的记录，那么（where）查询函数的影响会更小。保留过滤结果集的开销比collection.find降低了20％左右，但是它们的功能更强大。在我们的基准测试中，这仍然大约是 400k ops/sec。 索引和排序如果没有应用过滤器，并且（例如）’name’属性上存在二进制索引，则可以充分利用二进制索引： 1coll.chain().simplesort(&apos;name&apos;).data(); 如果发生了过滤，我们将检测我们是否可以利用&#39;索引相交&#39;算法中的索引来加速对典型loki排序的排序。只有在结果集中的结果集总数超过10％的情况下，才会启用此’索引相交’算法，否则标准loki排序将被确定为更快的方法。“索引相交”的性能优势与过滤质量有些成反比，因此它利用二进制索引来帮助减少“最坏情况”的分类处罚。 Loki sorting 不仅用于排序，还用于构建二进制索引，但如果您不需要在混合类型中进行更加统一的排序，则可以通过调用以下方法将额外的毫秒数排除在排序调用之外： 1coll.chain().simplesort(&apos;name&apos;, &#123; useJavascriptSorting: true &#125;).data(); 如果在&#39;name&#39;属性中存在二进制索引，我们将使用索引相交算法，除非resultset具有10％或更少的文档总数，此时我们将回退到传递给simplesort的属性上的JavaScript排序。如果您没有在该属性上应用二进制索引，那么如果该选项已通过，我们将始终使用JavaScript排序。 动态视图管道动态视图的行为与结果集[resultsets]相似，因为您要使用索引，必须使用第一个过滤器 12345678var userview = users.addDynamicView("over30");userview.applyFind(&#123;'Age': &#123;'$gte':30&#125;&#125;);// 可以随时获取最新的视图结果var results = userview.data();// 或对结果集进一步过滤results = userview.branchResultset().find(&#123;'Country': 'JP'&#125;).data(); 该查找过滤器理想情况下应引用您已应用索引（在此情况下为“年龄”）的字段。但是，动态视图运行一次它们的过滤器，因此即使是非高性能查询管道在建立之后也是快速的。这是由于在插入，更新或从集合中删除单个对象时重新评估这些过滤器。作为单个对象评估，在第一次评估期间不存在阵列扫描损失。动态视图的开销占据了结果集的顶部，将第一次评估的性能降低了大约40％，但后续查询得到了高度优化（比collection.find更快）。即使有这样的开销，我们的基准测试显示初始评估大约为30万[ops/sec]性能。根据更新频率的不同，后续评估可以扩展至每秒100万次以上。 在loki.js中，动态视图目前有两个选项，&#39;persistent&#39;（默认为false）和&#39;sortPriority&#39;（默认为&#39;passive&#39;）。 &#39;persistent&#39;选项表示结果将保存在内部数组中（除了正常的结果集）。这个&#39;resultdata&#39;数组会根据您的规范进行过滤和排序。将结果复制到内部数组发生在第一次data()评估期间，或者一旦过滤器或排序将结果集污染（文档插入，更新，从视图中删除）。此选项会增加内存开销，但可能会优化data()调用。 &#39;sortPriority&#39;选项可以是&#39;passive&#39;或&#39;active&#39;。默认情况下，当调用data()并将这些排序标记污染时，会进行懒惰（&#39;passive&#39;）。如果您希望排序成本为“up-front”，您可以指定“active” sortPriority。使用active的sortPriority，一旦插入/更新/删除将排序标记为脏，我们将排队并限制异步排序以在线程产生时运行。因此，如果更新频率较低或单独批量修改，则可以预先支付性能成本，以确保稍后获得最佳data()检索速度。如果您的数据修改频繁且零星，如果没有人读取数据，则有效的sortPriority可能会浪费计算排序。]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LokiJS快速入门]]></title>
    <url>%2F2018%2F05%2F02%2Flokijs1_overview%2F</url>
    <content type="text"><![CDATA[LokiJS.org web siteLokiJS GitHub pageSandbox / Playground 概况LokiJS是一个面向文档的JavaScript数据库，与MongoDB有些相似。这只是一个概述，有关完整的文档，请参阅 lokijs.org. 它支持数据集合的索引，查询和过滤。LokiJS还支持更高级的功能，例如mapReduce，事务，并允许您实现自定义远程同步以将数据保存到服务器（或移动设备上的本地文件）。持久化到磁盘已经为CommonJS环境（如nodejs）实现，在移动设备上，您只需要请求文件系统并将lokijs的serialize() 作为内容传递。 在浏览器或移动环境中，您只需要包含build/lokijs.min.js 功能1. 面向文档数据存储为JavaScript对象，并序列化为JSON以用于磁盘持久化。 2. 索引您可以指定索引以加快对某些对象属性的搜索。’id’字段自动编入索引，并使用二进制搜索算法来避免for(;;)循环变慢 3. 视图您可以声明自定义视图函数用以返回基于复杂逻辑的结果集。 4. Map reduce您可以声明map和reduce函数以检索数据库中的聚合数据。 用法示例如果您在node.js环境中工作，请运行 npm install lokijs 并确保调用 var loki = require(&#39;lokijs&#39;) 创建数据库: 1var db = new loki('Example'); 创建一个集合，指定名称，类型，索引字段以及集合是否是事务性的： 12var users = db.addCollection('users', &#123; indices: ['email'] &#125;);// 请注意，索引可以是单个字符串或字符串数组 请注意，索引和事务标志是可选参数。LokiJS中的事务只是允许您运行操作并自动将数据库恢复到事务开始之前的阶段（如果发生错误）。 在数据库中添加一些用户： 123456var odin = users.insert( &#123; name : &apos;odin&apos;, email: &apos;odin.soap@lokijs.org&apos;, age: 38 &#125; );var thor = users.insert( &#123; name : &apos;thor&apos;, email : &apos;thor.soap@lokijs.org&apos;, age: 25 &#125; );var stan = users.insert( &#123; name : &apos;stan&apos;, email : &apos;stan.soap@lokijs.org&apos;, age: 29 &#125; );var oliver = users.insert( &#123; name : &apos;oliver&apos;, email : &apos;oliver.soap@lokijs.org&apos;, age: 31 &#125; );var hector = users.insert( &#123; name : &apos;hector&apos;, email : &apos;hector.soap@lokijs.org&apos;, age: 15&#125; );var achilles = users.insert( &#123; name : &apos;achilles&apos;, email : &apos;achilles.soap@lokijs.org&apos;, age: 31 &#125; ); 操作更新： 123stan.name = &apos;Stan Laurel&apos;;// 更新对象（这实际上只是同步索引）users.update(stan); 动态视图 (DynamicViews) - 推荐方法: 123456789101112var dv = users.addDynamicView(&apos;a_complex_view&apos;);dv.applyWhere(function aCustomFilter(obj)&#123; return obj.name.length &lt; 5 &amp;&amp; obj.age &gt; 30;&#125;);// 查看数据console.log(dv.data());// 应用一些更改users.insert(&#123; name: &apos;ratatosk&apos;, email: &apos;rata@tosk.r&apos;, age: 10320 &#125;);// 看看动态视图通过检查数据来更新自己console.log(dv.data()); ‘Where’ 过滤函数: 1234567891011function ageView(obj)&#123; return obj.age &gt; 30;&#125;// 更复杂一些，名字长于3个字符，年龄超过30岁的用户function aCustomFilter(obj)&#123; return obj.name.length &lt; 5 &amp;&amp; obj.age &gt; 30;&#125;//测试过滤器var result = users.where(ageView);var anotherResult = users.where(aCustomFilter); Map Reduce (实时演示示例在 lokijs.org 上): 123456789101112131415161718function getDuration( obj )&#123; return obj.complete ? null : obj.duration;&#125;function getAverage( array )&#123; var cumulator = 0; var i = array.length &gt;&gt;&gt; 0; var actual = 0; while(i--)&#123; if(array[i] != null)&#123; cumulator += array[i]; actual++; &#125; &#125; return ( cumulator / actual).toFixed(2);&#125;var avgDuration = todos.mapReduce( getDuration, getAverage ); 通过方法链查询 : 1234567users.chain() .find(&#123;&apos;age&apos;:&#123;&apos;$gt&apos;: 25&#125;&#125;) .where(function(obj)&#123; return obj.name.indexOf(&quot;in&quot;) != -1 &#125;) .simplesort(&quot;age&quot;) .offset(50) .limit(10) .data() 简单的命名变换 : 123456789101112131415users.addTransform(&apos;progeny&apos;, [ &#123; type: &apos;find&apos;, value: &#123; &apos;age&apos;: &#123;&apos;$lte&apos;: 40&#125; &#125; &#125;, &#123; type: &apos;simplesort&apos;, property: &apos;age&apos;, desc: true &#125;]);var results = users.chain(&apos;progeny&apos;).data(); 更多信息: 访问 : www.lokijs.org 示例 : https://github.com/techfort/LokiJS/tree/master/examples StackOverflow : https://stackoverflow.com/questions/tagged/lokijs]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[集合变换]]></title>
    <url>%2F2018%2F05%2F02%2Flokijs6_collection_transforms%2F</url>
    <content type="text"><![CDATA[集合变换 集换背后的基本思想是允许将结果集的“链”式调用过程转换为该过程的对象定义。这个数据定义可以随意命名，并与集合一起保存在数据库中。 这可能对以下方面有用： 编写在loki数据库上运行的工具 创建’存储过程’的命名查询 转换您的数据以便提取 可以通过自定义meta进行扩展 变换是在集合链上执行的(有序)“步骤(step)”对象数组。这些步骤可能包括以下类型： ‘find’ ‘where’ ‘simplesort’ ‘compoundsort’ ‘sort’ ‘limit’ ‘offset’ ‘update’ ‘remove’ ‘map’ ‘mapReduce’ ‘eqJoin’ 这些转换步骤可以硬编码它们的参数，或者为loki变换添加参数替换机制。 一个简单的示例，只有一个步骤的loki变换可能如下所示： 12345678var tx = [ &#123; type: &apos;find&apos;, value: &#123; &apos;owner&apos;: &apos;odin&apos; &#125; &#125;]; 然后可以使用以下命令将其选择性地保存到集合中： 1userCollection.addTransform(&apos;OwnerFilter&apos;, tx); 这种转换可以通过以下任一方式执行 1userCollection.chain(&apos;OwnerFilter&apos;).data(); 或 1userCollection.chain(tx).data(); 参数化在任何对象属性的右侧的值上得到处理，该值在变换中表示为以&#39;[％lktxp]&#39;开头的字符串。示例如下： 12345678var tx = [ &#123; type: &apos;find&apos;, value: &#123; &apos;owner&apos;: &apos;[%lktxp]OwnerName&apos; &#125; &#125;]; 要执行此链式调用，您需要在执行时传递包含该参数值的参数对象。一个例子可能是： 12345var params = &#123; OwnerName: &apos;odin&apos;&#125;;userCollection.chain(tx, params).data(); 或 1userCollection.chain(&quot;OwnerFilter&quot;, params).data(); 过滤功能无法保存到数据库中，但是如果您仍然需要它们，可以利用转换和参数化可以实现清晰的结构化并且可以执行保存的转换。一个例子可能是： 123456789101112131415161718var tx = [ &#123; type: &apos;where&apos;, value: &apos;[%lktxp]NameFilter&apos; &#125;];items.addTransform(&apos;ByFilteredName&apos;, tx);// 那么可能会立即发生以下情况，甚至可能在`保存/加载`周期中发生// 这个例子使用匿名函数，但也可以将其命名为函数引用var params = &#123; NameFilter: function(obj) &#123; return (obj.name.indexOf(&quot;nir&quot;) !== -1); &#125;&#125;;var results = items.chain(&quot;ByFilteredName&quot;, params).data(); 转换可以包含多个要连续执行的步骤。在幕后，链命令将实例化一个Resultset并将其作为独立的链操作调用，最终在完成时返回结果。一些内置的“步骤(step)”，如&#39;mapReduce&#39;实际上通过返回一个数据数组来终止变换/链(transform/chain)，所以在这些情况下，chain()结果就是实际的数据，而不是你需要调用data()获取结果集。 更复杂的转换示例可能如下所示： 123456789101112131415161718192021222324252627282930var tx = [ &#123; type: &apos;find&apos;, value: &#123; owner: &#123; &apos;$eq&apos;: &apos;[%lktxp]customOwner&apos; &#125; &#125; &#125;, &#123; type: &apos;where&apos;, value: &apos;[%lktxp]customFilter&apos; &#125;, &#123; type: &apos;limit&apos;, value: &apos;[%lktxp]customLimit&apos; &#125;];function myFilter(obj) &#123; return (obj.name.indexOf(&quot;nir&quot;) !== -1);&#125;var params = &#123; customOwner: &apos;odin&apos;, customFilter: myFilter, customLimit: 100&#125;users.chain(tx, params); 如上例所示，我们将扫描对象层次结构（深达10层），并对右边的参数进行参数替换，这些值看起来是参数，然后我们将尝试从您的参数对象中查找。参数替换将用与您的params中包含的值相同的值替换该字符串，该参数可以是任何数据类型。 某些具有多个参数的步骤需要特定的步骤属性（除了类型和值）。这些在下面被演示为单独的步骤，这些步骤在单个变换中不一定有意义： 1234567891011121314151617181920212223var step1 = &#123; type: &apos;simplesort&apos;, property: &apos;name&apos;, desc: true&#125;;var step2 = &#123; type: &apos;mapReduce&apos;, mapFunction: myMap, reduceFunction: myReduce&#125;;var step3 = &#123; type: &apos;eqJoin&apos;, joinData: jd, leftJoinKey: ljk, rightJoinKey: rjk, mapFun: myMapFun&#125;;var step4 = &#123; type: &apos;remove&apos;&#125; 支持 DynamicViews您现在可以使用转换作为DynamicView的提取方法。某些应用程序可能会使用它创建一个包含广泛结果集的DynamicView，这些结果可以从用户定义的转换中快速提取。此功能在DynamicView的branchResultset()方法中提供。它可以接受存储在集合级别的原始转换或命名转换。 一个例子可能如下所示： 123456789101112131415161718var db = new loki(&apos;test&apos;);var coll = db.addCollection(&apos;mydocs&apos;);var dv = coll.addDynamicView(&apos;myview&apos;);var tx = [ &#123; type: &apos;offset&apos;, value: &apos;[%lktxp]pageStart&apos; &#125;, &#123; type: &apos;limit&apos;, value: &apos;[%lktxp]pageSize&apos; &#125;];coll.addTransform(&apos;viewPaging&apos;, tx);// add some recordsvar results = dv.branchResultset(&apos;viewPaging&apos;, &#123; pageStart: 10, pageSize: 10 &#125;).data(); 重要的区别在于分支（以及因此您的转换结果）仅反映了您分支时的视图。这些转换是提取而不是内部用于视图。 为定制解决方案添加元数据一种用于转换的用途可能是在用户界面构建，管理和执行这些转换时使用用户驱动的解决方案。在这种情况下，您可能需要将自己的元数据添加到变换中以进一步描述变换，步骤或参数。 任何具有Loki变换未知类型的步骤都将被忽略。您可能会决定始终将第一步作为具有包含有关作者，描述或所需参数描述元数据信息的属性的“元”类型。 每个步骤还可以包含额外的属性，超出了我们所定义的要求，因此您可能会在步骤中嵌入步骤描述，上次更改的日期等。 总结Loki转换可以建立一个自动化数据转换的过程（只需很少的额外占用空间）。这不是必需的功能，也不是要取代方法链接，但它允许您抽象和组织重复的查询以实现清洁或动态目的。]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自动更新集合]]></title>
    <url>%2F2018%2F05%2F02%2Flokijs7_autoupdating_collections%2F</url>
    <content type="text"><![CDATA[集合的自动更新功能可以通过构造函数选项autoupdate：true在每个集合的基础上启用自动更新。该功能需要Object.observe（目前在Chrome 36+, io.js 和 Node.js 0.12+中实现）。如果观察者不可用，则该选项将被忽略。 无论何时修改文档，自动更新(Autoupdate)都会自动调用 update(doc)，这对索引更新和脏标记（用于确定数据库是否已被修改并应该保留）是必需的。 启用此功能基本上意味着，所有手动update呼叫都可以省略。 示例1234567var doc = collection.by("name", "John");doc.name = "Peter";doc.age = 32;doc.gender = "male";collection.update(doc); // 这行代码可以安全地删除。 自动更新(Autoupdate)将在当前事件循环结束时调用 update ，因此即使在进行多项更改时也只会调用 update 一次。 错误处理自动更新和手动更新之间有一个重要区别。例如，如果文档更改违反了唯一键约束，update将同步抛出一个可以同步捕获的错误： 1234567891011121314var collection = db.addCollection(&quot;test&quot;, &#123; unique: [&quot;name&quot;]&#125;);collection.insert(&#123; name: &quot;Peter&quot; &#125;);var doc = collection.insert(&#123; name: &quot;Jack&quot; &#125;);doc.name = &quot;Peter&quot;;try &#123; collection.update(doc);&#125; catch(err) &#123; doc.name = &quot;Jack&quot;;&#125; 由于自动更新(Autoupdate)异步调用更新，因此无法通过try-catch捕获错误。相反，你必须使用事件监听器： 123456789101112131415var collection = db.addCollection(&quot;test&quot;, &#123; unique: [&quot;name&quot;], autoupdate: true&#125;);collection.insert(&#123; name: &quot;Peter&quot; &#125;);var doc = collection.insert(&#123; name: &quot;Jack&quot; &#125;);doc.name = &quot;Peter&quot;;collection.on(&quot;error&quot;, function(errDoc) &#123; if(errDoc === doc) &#123; doc.name = &quot;Jack&quot;; &#125;&#125;); 这可能会变得非常繁琐，因此您应该考虑在更新文档之前进行检查。]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Node.js和NPM版本的升级]]></title>
    <url>%2F2018%2F04%2F21%2F2018-04-21-node-update%2F</url>
    <content type="text"><![CDATA[升级 node.jsnpm中有一个模块叫做“n”，专门用来管理node.js版本的。 更新到最新的稳定版只需要在命令行中打下如下代码： 12npm install -g nn stable 注意：Linux系统需要添加sudo权限 eg: sudo npm install -g n 如需最新版本则用n latest 当然，n后面也可以跟具体的版本号：n v6.2.0 具体细节参见 n模块的GitHub 相关资料 用n管理不同版本的Node 升级 npmnpm升级就更简单了，只需要在终端中输入： 1npm -g install npm@latest 具体可参见阮一峰的【NPM模块管理器】]]></content>
      <categories>
        <category>CST</category>
      </categories>
      <tags>
        <tag>Software</tag>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Ubuntu上安装MongoDB社区版]]></title>
    <url>%2F2018%2F04%2F02%2Fubuntu_mongo_install%2F</url>
    <content type="text"><![CDATA[概览使用本教程在使用.deb软件包的LTS Ubuntu Linux 系统上安装MongoDB社区版。 重要的 由Ubuntu提供的非官方mongodb包不是由MongoDB维护的。您应该始终使用官方的MongoDB mongodb-org软件包，它们随时与最新的MongoDB的主版本和次要版本保持同步。 支持平台 MongoDB仅提供64位 LTS(长期支持) Ubuntu 发行版的软件包。 例如，12.04 LTS (precise)，14.04 LTS (trusty)，16.04 LTS (xenial)等等。 这些软件包可能与其他Ubuntu发行版一起使用，但是，它们不受支持。 MongoDB 3.6 放弃了对 Ubuntu 12.04 LTS (precise) 的支持。 在IBM电脑系统上，Ubuntu 16.04需要更新软件包 由于Ubuntu 16.04的旧版glibc软件包存在锁定漏洞问题，因此在运行MongoDB之前，必须将glibc软件包升级至glibc 2.23-0ubuntu5。 具有旧版本glibc软件包的系统将由于随机内存损坏而遇到数据库服务器崩溃和不正常行为，并且不适合MongoDB的生产部署 包MongoDB在他们自己的仓库中提供官方支持的软件包。此库包含以下软件包： 包名 描述 mongodb-org 一个元数据包，将自动安装下面列出的四个组件包。 mongodb-org-server 包含mongod守护进程和相关的配置以及init脚本。 mongodb-org-mongos 包含mongos守护进程。 mongodb-org-shell 包含mongo shell。 mongodb-org-tools 包含以下MongoDB工具: mongoimport bsondump, mongodump, mongoexport, mongofiles, mongoperf, mongorestore, mongostat, 和 mongotop. mongodb-org-server软件包提供了一个初始化脚本，它使用/etc/mongod.conf配置文件启动mongod。 有关使用此初始化脚本的详细信息，请参阅运行MongoDB社区版 。 这些软件包与Ubuntu提供的mongodb，mongodb-server和mongodb-clients软件包相冲突。 默认情况下，软件包提供的默认/etc/mongod.conf配置文件的bind_ip设置为127.0.0.1。在初始化副本集之前根据您的环境需要修改此设置。 安装 MongoDB 社区版 注意 要安装不同版本的MongoDB，请参阅该版本的文档。例如，参见3.4版。 1. 导入包管理系统使用的公钥.Ubuntu软件包管理工具（即dpkg和apt）通过要求分销商使用gpg密钥对软件包进行签名来确保软件包的一致性和真实性。发出以下命令来导入MongoDB 公共 GPG 密钥： 1sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 2930ADAE8CAF5059EE73BB4B58712A2291FA4AD5 2. 为MongoDB创建软件源list文件.使用适合您的Ubuntu版本的命令创建/etc/apt/sources.list.d/mongodb-org-3.6.list软件源list文件： Ubuntu 12.04 (deprecated) 1echo &quot;deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu precise/mongodb-org/3.6 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list Ubuntu 14.04 1echo &quot;deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.6 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list Ubuntu 16.04 1echo &quot;deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu xenial/mongodb-org/3.6 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-3.6.list 3. 重新加载本地包数据库.发出以下命令以重新加载本地包数据库 1sudo apt-get update 4. 安装 MongoDB 包.安装最新的稳定版本的MongoDB.发出以下命令: 1sudo apt-get install -y mongodb-org 安装指定版本的MongoDB.要安装特定版本，必须单独指定每个组件包以及版本号，如下例所示： 1sudo apt-get install -y mongodb-org=3.6.3 mongodb-org-server=3.6.3 mongodb-org-shell=3.6.3 mongodb-org-mongos=3.6.3 mongodb-org-tools=3.6.3 如果您只安装mongodb-org = 3.6.3并且不包含组件软件包，则无论您指定了哪个版本，都会安装每个mongodb软件包的最新版本。 固定一个特定版本的MongoDB.尽管您可以指定任何可用的MongoDB版本，但apt-get会在新版本可用时升级软件包。以防止意外升级，固定包装。要在当前安装的版本上固定MongoDB的版本，请发出以下命令序列： 12345echo &quot;mongodb-org hold&quot; | sudo dpkg --set-selectionsecho &quot;mongodb-org-server hold&quot; | sudo dpkg --set-selectionsecho &quot;mongodb-org-shell hold&quot; | sudo dpkg --set-selectionsecho &quot;mongodb-org-mongos hold&quot; | sudo dpkg --set-selectionsecho &quot;mongodb-org-tools hold&quot; | sudo dpkg --set-selections 运行 MongoDB 社区版大多数类Unix操作系统会限制会话可能使用的系统资源。这些限制可能会对MongoDB操作产生负面影响。有关更多信息，请参阅 UNIX ulimit 设置。 MongoDB实例默认将其数据文件存储在 /var/lib/mongodb 及其日志文件 /var/log/mongodb中，并使用mongodb用户帐户运行。您可以在/etc/mongod.conf中指定备用日志和数据文件目录。有关其他信息，请参阅 systemLog.path 和 storage.dbPath 。 如果更改运行MongoDB进程的用户，则必须修改/var/lib/mongodb 和 /var/log/mongodb 目录的访问控制权限，以使该用户可以访问这些目录。 1. 启动 MongoDB.发出以下命令: 1sudo service mongod start 2. 验证MongoDB已成功启动通过在/var/log/mongodb/mongod.log中检查日志文件的内容以确认mongod进程已成功启动。 1[initandlisten] waiting for connections on port 27017 &lt;port&gt;是 mongod 侦听的端口。如果您修改了/etc/mongod.conf配置文件中的 net.port 设置，则端口可能会有所不同。 如果您修改了 systemLog.path 配置文件选项，请在您为该设置指定的位置查找日志文件。 您可能会在 mongod 输出中看到非严重警告。只要您看到上面显示的日志行，就可以在您对MongoDB进行初始评估期间安全地忽略这些警告。 3. 停止 MongoDB.根据需要，您可以通过发出以下命令来停止 mongod 进程： 1sudo service mongod stop 4. 重新启动 MongoDB.发出以下命令重新启动 mongod : 1sudo service mongod restart 5. 开始使用 MongoDB.在与 mongod 相同的主机上启动一个 mongo shell。使用 --host 命令行选项来指定 mongod 侦听的本地主机地址和端口 1mongo --host 127.0.0.1:27017 之后，要停止MongoDB，请在运行mongod实例的终端中按下Control+C。 卸载 MongoDB 社区版要从系统中完全删除MongoDB，您必须自行删除MongoDB应用程序，配置文件以及包含数据和日志的任何目录。以下部分将指导您完成必要的步骤。 警告 这个过程将完全删除MongoDB以及它的配置和所有数据库。此过程不可逆，因此请确保在继续之前备份所有配置和数据。 1. 停止 MongoDB 服务.使用以下的命令停止mongod进程： 1sudo service mongod stop 2. 移除软件包.删除以前安装的任何MongoDB软件包。 1sudo apt-get purge mongodb-org* 3. 删除数据目录.删除MongoDB数据库和日志文件 12sudo rm -r /var/log/mongodbsudo rm -r /var/lib/mongodb]]></content>
      <categories>
        <category>CST</category>
      </categories>
      <tags>
        <tag>Software</tag>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu安装MongoDB]]></title>
    <url>%2F2018%2F04%2F02%2Fubuntu_mongo_db%2F</url>
    <content type="text"><![CDATA[相关网站 MongoDB官网 MongoDB中文网 MongoDB社区 Ubuntu搭建Node服务器，主要可以通过两种方式进行安装： 二进制文件 包管理器 二进制文件 获取下载源地址 点此获取 1https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.6.3.tgz 下载安装包并解压 12wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-ubuntu1604-3.6.3.tgztar -xzvf mongodb-linux-x86_64-ubuntu1604-3.4.5.tgz 如果服务器下载特别慢，那就在本地电脑下载好后,使用SCP命令上传到服务器上。 scp -r mongodb.tgz root@116.196.91.32:/root/softwares/ 解压过程中容易出错，解决方案见下方 配置环境变量 123vi .bashrc // 把MongoDB的bin目录添加到环境变量中export PATH=$PATH:&lt;mongodb-install-directory&gt;/binsource .bashrc 验证是否安装成功 1mongod --version 1234567891011db version v3.2.17-----------------------------------------------------git version: 186656d79574f7dfe0831a7e7821292ab380f667OpenSSL version: OpenSSL 1.0.2g 1 Mar 2016allocator: tcmallocmodules: nonebuild environment: distmod: ubuntu1604 distarch: x86_64 target_arch: x86_64----------------------------------------------------- ​ 包管理器 Ubuntu apt安装MongoDB【官方】文档 Ubuntu apt安装MongoDB【中文】文档 遇到的问题 使apt-get支持SSL源 因为在软件源中要用到HTTPS进行传输，所以，首先安装apt-transport-https，否则会出现：E: The method driver /usr/lib/apt/methods/https could not be found.N: Is the package apt-transport-https installed? 使用下面命令安装apt的ssl支持apt-get install apt-transport-https 顺便分享几个SSL的源站https://mirrors.ustc.edu.cn/https://mirrors.aliyun.com/ https://mirrors.tuna.tsinghua.edu.cn/ 似乎限速…. 不推荐用 tar解压出错：gzip: stdin: unexpected end of file的解决办法 解决方案：重新下载，再次进行解压。 参考链接 Ubuntu 16.04 安装 MongoDB Community Edition]]></content>
      <categories>
        <category>CST</category>
      </categories>
      <tags>
        <tag>Software</tag>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Realm for JavaScript(2.2.0)]]></title>
    <url>%2F2018%2F03%2F07%2Frealm_js_doc%2F</url>
    <content type="text"><![CDATA[介绍 Realm JavaScript 使您能够以安全，持久和快速的方式有效编写应用程序的模型层。它旨在与 React Native 与 Node.js一起工作。 这里有个简单的例子: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const Realm = require(&apos;realm&apos;);// 定义你的模型和它们的属性const CarSchema = &#123; name: &apos;Car&apos;, properties: &#123; make: &apos;string&apos;, model: &apos;string&apos;, miles: &#123;type: &apos;int&apos;, default: 0&#125;, &#125;&#125;;const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; name: &apos;string&apos;, birthday: &apos;date&apos;, cars: &apos;Car[]&apos;, picture: &apos;data?&apos; // 可选属性 &#125;&#125;;Realm.open(&#123;schema: [CarSchema, PersonSchema]&#125;) .then(realm =&gt; &#123; // 创建Realm对象并写入本地存储 realm.write(() =&gt; &#123; const myCar = realm.create(&apos;Car&apos;, &#123; make: &apos;Honda&apos;, model: &apos;Civic&apos;, miles: 1000, &#125;); myCar.miles += 20; // 更新属性值 &#125;); // 通过Realm实例查询所有高于1000里程车 const cars = realm.objects(&apos;Car&apos;).filtered(&apos;miles &gt; 1000&apos;); // 将返回一个结果对象(1辆车) cars.length // =&gt; 1 // 添加另一辆车 realm.write(() =&gt; &#123; const myCar = realm.create(&apos;Car&apos;, &#123; make: &apos;Ford&apos;, model: &apos;Focus&apos;, miles: 2000, &#125;); &#125;); // 查看结果:已经实时更新了 cars.length // =&gt; 2 &#125;) .catch(error =&gt; &#123; console.log(error); &#125;); 请注意，如果要将Realm用于服务器端或者Node环境，则在Realm对象服务器文档中可找到相关信息。 入门安装按照下面的安装说明通过npm安装Realm JavaScript，或者在github上查看源代码。 必要条件 确保您的环境设置为运行React Native应用程序。按照React Native说明开始使用。 使用Realm的应用程序可以同时针对iOS和Android。 支持React Native 0.31.0及更高版本。 安装 创建一个新的React Native工程: 1react-native init &lt;project-name&gt; 将目录更改为新项目(cd &lt;project-name&gt;)，并添加realm依赖 1npm install --save realm 接下来，将项目链接到realm原生模块。 1react-native link realm Android的警告：根据版本， react-native link可能会生成无效的配置，正确更新Gradle(android/settings.gradle and android/app/build.gradle) ，但无法添加Realm模块。确认react-native link已添加了Realm模块;如果没有，请通过以下步骤手动链接到库： 添加以下行到 android/settings.gradle: 12include &apos;:realm&apos;project(&apos;:realm&apos;).projectDir = new File(rootProject.projectDir, &apos;../node_modules/realm/android&apos;) 将编译行添加到 android/app/build.gradle 中的依赖项: 123dependencies &#123; compile project(&apos;:realm&apos;)&#125; 在MainApplication.java中添加导入并链接包: 1234567891011import io.realm.react.RealmReactPackage; // add this importpublic class MainApplication extends Application implements ReactApplication &#123; @Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new RealmReactPackage() // 添加这行 ); &#125;&#125; 现在已经准备好了。要查看Realm中的action，请在index.ios.js或index.android.js中添加以下作为class &lt;project-name&gt;的定义： 123456789101112131415161718192021222324252627282930313233const Realm = require(&apos;realm&apos;);class &lt;project-name&gt; extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; realm: null &#125;; &#125; componentWillMount() &#123; Realm.open(&#123; schema: [&#123;name: &apos;Dog&apos;, properties: &#123;name: &apos;string&apos;&#125;&#125;] &#125;).then(realm =&gt; &#123; realm.write(() =&gt; &#123; realm.create(&apos;Dog&apos;, &#123;name: &apos;Rex&apos;&#125;); &#125;); this.setState(&#123; realm &#125;); &#125;); &#125; render() &#123; const info = this.state.realm ? &apos;Number of dogs in this Realm: &apos; + this.state.realm.objects(&apos;Dog&apos;).length : &apos;Loading...&apos;; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt; &#123;info&#125; &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 然后，您可以在设备和模拟器中运行应用程序. 例子例子可以在realm-js仓库的github上找到。 请注意，在Android上，您需要安装ndk，并且必须设置android_ndk环境变量。 1export ANDROID_NDK=/usr/local/Cellar/android-ndk/r10e Realm StudioRealm Studio 是我们的首选开发工具，可以轻松管理Realm数据库和Realm平台。使用Realm Studio，您可以打开和编辑本地和同步Realm，并管理任何Realm对象服务器实例。它支持Mac, Windows 和 Linux 系统。 下载 Mac 版 下载 Linux 版 下载 Windows 版 获得帮助 需要帮助你的代码？ 在StackOverflow上提问吧. 我们积极监督并立马回答您的问题！ 有Bug上报? 在我们Github库上提问吧. 如果可能，请包括Realm版本，完整日志，Realm文件以及显示问题的项目。 有功能请求吗? 在我们Github库上提交请求吧吧. 告诉我们功能应该做什么，以及为什么要这个功能. 如果您使用崩溃记录（如Crashlytics或HockeyApp），请确保启用日志收集。Realm在抛出异常和不可恢复的情况下记录元数据信息（但不包含用户数据），并且这些消息可以帮助在出现问题时进行调试。 模型Realm数据模型由初始化期间传递到Realm的schema信息定义。对象的schema由对象的名称(name)和一组属性组成，每个属性由名称(name)和类型(type)以及对象和列表属性的objectType组成。您还可以将每个属性指定为可选optional的或具有默认default的值,以及索引indexed。 12345678910111213141516171819202122232425const Realm = require(&apos;realm&apos;);const CarSchema = &#123; name: &apos;Car&apos;, properties: &#123; make: &apos;string&apos;, model: &apos;string&apos;, miles: &#123;type: &apos;int&apos;, default: 0&#125;, &#125;&#125;;const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; name: &apos;string&apos;, birthday: &apos;date&apos;, cars: &apos;Car[]&apos; picture: &apos;data?&apos;, // 可选的属性 &#125;&#125;;// 使用Car和Person的模型初始化Realm实例Realm.open(&#123;schema: [CarSchema, PersonSchema]&#125;) .then(realm =&gt; &#123; // ... 使用Realm实力来读取和修改数据 &#125;) 类 在这一点上，支持通过类定义模型是有限制的。它能在React Native中运行，但不能在Node环境中。 如果你想使用ES2015类（也许想继承现有的功能），你只需要在构造函数中定义模式： 12345678910111213class Person &#123; get fullName() &#123; return this.firstName + &apos; &apos; + this.lastName; &#125;&#125;Person.schema = &#123; name: &apos;Person&apos;, properties: &#123; firstName: &apos;string&apos;, lastName: &apos;string&apos; &#125;&#125;; 您现在可以将该类本身传递给打开的配置的schema属性： 12Realm.open(&#123;schema: [Person]&#125;) .then( /* ... */ ); 或者像往常一样访问属性: 12345678realm.write(() =&gt; &#123; const john = realm.create(&apos;Person&apos;, &#123; firstName: &apos;John&apos;, lastName: &apos;Smith&apos; &#125;); john.lastName = &apos;Peterson&apos;; console.log(john.fullName); // -&gt; &apos;John Peterson&apos;&#125;); Supported typesRealm支持以下基本类型: bool, int, float, double, string, data, 和 date. bool 属性映射到 JavaScript Boolean 对象 int, float, and double 属性映射到 JavaScript Number 对象. 内部的int和double被存储为64位，而float以32位存储。 string 属性映射到 String data 属性映射到 ArrayBuffer date 属性映射到 Date 将基本属性指定为简写时，您可以仅指定类型，而不必指定具有单个条目的字典： 12345678const CarSchema = &#123; name: &apos;Car&apos;, properties: &#123; // 以下属性类型是等效的 make: &#123;type: &apos;string&apos;&#125;, model: &apos;string&apos;, &#125;&#125; 可选属性默认情况下，基本类型是非可选的，不支持存储null或undefined。属性可以通过在属性定义中指定optional指示符或使用简写语法，通过附加一个?到类型名称后面： 123456789101112131415161718192021222324252627const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; realName: &apos;string&apos;, // 要求属性 displayName: &apos;string?&apos;, // 可选属性 birthday: &#123;type: &apos;date&apos;, optional: true&#125;, // 可选属性 &#125;&#125;;let realm = new Realm(&#123;schema: [PersonSchema, CarSchema]&#125;);realm.write(() =&gt; &#123; // 可选属性可以在创建时设置为null或未定义 let charlie = realm.create(&apos;Person&apos;, &#123; realName: &apos;Charlie&apos;, displayName: null, // 也可以完全省略 birthday: new Date(1995, 11, 25), &#125;); // 可选属性可以设置为`null`, `undefined`, // 或新的非空值 charlie.birthday = undefined; charlie.displayName = &apos;Charles&apos;; // 将非可选属性设置为null会抛出`TypeError` // charlie.realName = null;&#125;); 列表属性除了存储单个值之外，还可以将属性声明为任何支持的基本类型的列表。这是通过将[]附加到类型名称来完成的： 12345678910111213141516171819202122const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; name: &apos;string&apos;, testScores: &apos;double?[]&apos; &#125;&#125;;let realm = new Realm(&#123;schema: [PersonSchema, CarSchema]&#125;);realm.write(() =&gt; &#123; let charlie = realm.create(&apos;Person&apos;, &#123; name: &apos;Charlie&apos;, testScores: [100.0] &#125;); // 查理在第二次考试中缺席了并且被允许跳过它 charlie.testScores.push(null); // 然后他在第三次测试中表现不佳 charlie.testScores.push(70.0);&#125;); 访问列表属性时会返回一个列表List对象。列表List的方法非常类似于常规的JavaScript数组。最大的区别是对列表List所做的任何更改都会自动保存到底层Realm，因此只能在写入事务中进行修改。此外，列表List属于它们从中获取的底层对象 - 您只能通过访问拥有对象中的属性来获取列表实例，并且不能手动创建它们。 虽然list属性中的值可以是可选的，但list属性本身不可以。使用longhand语法 (values: {type: &#39;int[]&#39;, optional: true})指定list属性为可选项，将使列表中的值成为可选项。 关系一对一的关系对于一对一的关系，您可以将引用的对象schema的name属性指定为属性的类型(type)： 12345678const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; // 所有以下属性定义是等效的 car: &#123;type: &apos;Car&apos;&#125;, van: &apos;Car&apos;, &#125;&#125;; 使用对象属性时，需要确保所有引用的类型都存在于用于打开Realm的schema中： 12// CarSchema是必需的，因为PersonSchema包含&apos;car&apos;类型的属性，Realm.open(&#123;schema: [CarSchema, PersonSchema]&#125;).then(/* ... */); 访问对象属性时，可以使用普通属性语法访问嵌套属性: 12345678910realm.write(() =&gt; &#123; const nameString = person.car.name; person.car.miles = 1100; // 通过将属性设置为具有所有必填字段的对象来创建Car实例 person.van = &#123;make: &apos;Ford&apos;, model: &apos;Transit&apos;&#125;; // 将两个属性设置为同一个汽车实例 person.car = person.van;&#125;); Realm中的对象属性始终是可选的，不必像这样明确指定，并且不能使其成为必需。 一对多的关系就像基本属性一样，你也可以有一个对象列表来形成一对多的关系。这可以通过将[]添加到目标对象schema的名称或通过将属性类型设置为列表list并指定objectType来完成： 123456789101112131415161718const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; // 以下属性定义是等效的 cars: &#123;type: &apos;list&apos;, objectType: &apos;Car&apos;&#125;, vans: &apos;Car[]&apos; &#125;&#125;let carList = person.cars;// 将新车添加到列表`List`中realm.write(() =&gt; &#123; carList.push(&#123;make: &apos;Honda&apos;, model: &apos;Accord&apos;, miles: 100&#125;); carList.push(&#123;make: &apos;Toyota&apos;, model: &apos;Prius&apos;, miles: 200&#125;);&#125;);let secondCar = carList[1].model; // access using an array index 与其他列表和一对一关系不同，一对多关系不能作为可选项。 多对多关系链接是单向的。所以如果一对多的属性Person.dogs链接到一个Dog实例和一个属性Dog.owner链接到Person，这些链接是彼此独立的。将Dog添加到Person实例的 dogs 属性不会自动将该狗的owner 属性设置为此Person。因为手动同步成对关系很容易出错，并且比较复杂和容易生成重复信息，所以Realm提供链接对象属性来表示这些反向关系。 使用链接对象属性，可以从特定属性获取链接到给定对象的所有对象。例如，Dog对象可以具有一个名为owner的属性，该属性包含其dogs属性中具有这个确切Dog对象的所有Person对象。通过owners属性的linkingObjects类型，指定它与Person对象的关系。 这样做可以通过owners属性指定它与Person对象的关系。 1234567891011121314const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; dogs: &apos;Dog[]&apos; &#125;&#125;const DogSchema = &#123; name:&apos;Dog&apos;, properties: &#123; // ``对象属性没有简写语法 owners: &#123;type: &apos;linkingObjects&apos;, objectType: &apos;Person&apos;, property: &apos;dogs&apos;&#125; &#125;&#125; 一个linksObjects属性可以指向一个List属性（多对多关系）或一个Object属性（一对一关系）: 12345678910111213const ShipSchema = &#123; name: &apos;Ship&apos;, properties: &#123; captain: &apos;Captain&apos; &#125;&#125;const CaptainSchema = &#123; name: &apos;Captain&apos;, properties: &#123; ships: &#123;type: &apos;linkingObjects&apos;, objectType: &apos;Ship&apos;, property: &apos;captain&apos;&#125; &#125;&#125; 访问linksObjects属性时，返回一个Results对象，因此完全支持进一步的查询和排序。linksObject属性属于它们从中获取的对象，不能直接设置或操作。当事务提交时，它们将自动更新。 访问不带schema的linkingObjects：如果您打开了一个Realm文件而不指定schema，例如在Realm Functions回调中，您可以通过在Object实例上调用 linkingObjects(objectType, property) 来获取linksObjects属性： 12let captain = realm.objectForPrimaryKey(&apos;Captain&apos;, 1);let ships = captain.linkingObjects(&apos;Ship&apos;, &apos;captain&apos;); 链接对象属性不能作为可选项。 默认属性值可以通过在属性定义中设置默认指示符来指定默认属性值。要使用默认值，请在创建对象期间保留未指定的属性。 1234567891011121314const CarSchema = &#123; name: &apos;Car&apos;, properties: &#123; make: &#123;type: &apos;string&apos;&#125;, model: &#123;type: &apos;string&apos;&#125;, drive: &#123;type: &apos;string&apos;, default: &apos;fwd&apos;&#125;, miles: &#123;type: &apos;int&apos;, default: 0&#125; &#125;&#125;;realm.write(() =&gt; &#123; // 由于`miles`被遗漏，它默认为“0”，而`drive`被指定，它会覆盖默认值 realm.create(&apos;Car&apos;, &#123;make: &apos;Honda&apos;, model: &apos;Accord&apos;, drive: &apos;awd&apos;&#125;);&#125;); 索引属性您可以将索引的指示符添加到属性定义，以使该属性进行索引。 目前支持 int, string, bool 和date属性类型： 1234567var BookSchema = &#123; name: &apos;Book&apos;, properties: &#123; name: &#123; type: &apos;string&apos;, indexed: true &#125;, price: &apos;float&apos; &#125;&#125;; 索引属性将极大地加快查询的属性进行比较，但是以较慢的插入为代价。 主键您可以在对象模型中为string和int属性指定primaryKey属性。声明一个主键可以对对象进行高效查找和更新，并强制执行每个值的唯一性。一旦有一个主键的对象被添加到Realm，主键就不能被改变了。 123456789const BookSchema = &#123; name: &apos;Book&apos;, primaryKey: &apos;id&apos;, properties: &#123; id: &apos;int&apos;, // 主键 title: &apos;string&apos;, price: &apos;float&apos; &#125;&#125;; 主键属性自动编入索引. 写创建，更新和删除Realm中的对象的操作必须在write()事务块中进行。请注意，写入事务具有不可忽略的开销;您应该尽量减少代码中写入块的数量。 创建对象使用create方法创建对象： 1234567try &#123; realm.write(() =&gt; &#123; realm.create(&apos;Car&apos;, &#123;make: &apos;Honda&apos;, model: &apos;Accord&apos;, drive: &apos;awd&apos;&#125;); &#125;);&#125; catch (e) &#123; console.log(&quot;Error on creation&quot;);&#125; 请注意， write()方法中抛出的任何异常都将取消事务。所有示例中都不会显示try/catch 块，但这是很好的做法。 嵌套对象如果对象具有对象属性，则可以通过为每个子属性指定JSON值来递归地创建这些属性的值： 1234567realm.write(() =&gt; &#123; realm.create(&apos;Person&apos;, &#123; name: &apos;Joe&apos;, // 嵌套对象是递归创建的 car: &#123;make: &apos;Honda&apos;, model: &apos;Accord&apos;, drive: &apos;awd&apos;&#125;, &#125;);&#125;); 更新对象键入的更新您可以通过在写事务中设置其属性来更新任何对象。 123realm.write(() =&gt; &#123; car.miles = 1100;&#125;); 使用主键创建和更新对象如果您的模型类包含主键，则可以根据主键值智能地更新或添加对象。这是通过将true作为第三个参数传递给create方法： 1234567realm.write(() =&gt; &#123; // 创建一个book对象 realm.create(&apos;Book&apos;, &#123;id: 1, title: &apos;Recipes&apos;, price: 35&#125;); // 通过ID,用新的价格更新book对象 realm.create(&apos;Book&apos;, &#123;id: 1, price: 55&#125;, true);&#125;); 在上面的例子中，由于一个对象已经存在，id值为1，并且我们已经为第三个参数传递了true，所以price属性被更新，而不是尝试创建一个新的对象。由于name属性被省略，对象保留此属性的原始值。请注意，当使用主键属性创建或更新对象时，必须指定主键。 删除对象可以通过在写事务中调用delete方法来删除对象。 1234567891011realm.write(() =&gt; &#123; // Create a book object let book = realm.create(&apos;Book&apos;, &#123;id: 1, title: &apos;Recipes&apos;, price: 35&#125;); // Delete the book realm.delete(book); // Delete multiple books by passing in a `Results`, `List`, or JavaScript `Array` let allBooks = realm.objects(&apos;Book&apos;); realm.delete(allBooks); // Deletes all books&#125;); 查询查询允许您从Realm中获取单个类型的对象，并可选择过滤和排序这些结果。所有查询（包括查询和属性访问）在Realm中都是懒加载的。仅在访问对象和属性时才读取数据。这样，您可以以高效的方式表示大量数据。 执行查询时，您将返回一个Results对象。Results只是您的数据视图，不可变。 从Realm中检索对象的最基本方法是使用Realm中的objects方法来获取给定类型的所有对象 1let dogs = realm.objects(&apos;Dog&apos;); // retrieves all Dogs from the Realm 过滤您可以通过使用查询字符串调用过滤的方法来获取已过滤的结果。 例如，以下将改变我们早期的例子，以检索所有具有颜色tan的狗，以’B’开头的名字： 12let dogs = realm.objects(&apos;Dog&apos;);let tanDogs = dogs.filtered(&apos;color = &quot;tan&quot; AND name BEGINSWITH &quot;B&quot;&apos;); 目前，查询语言只支持NSPredicate语法的一部分,让我们简要总结一下支持的功能和语法： Realm支持的查询语言受到了苹果公司的 Apple’s NSPredicate启发。让我们简要总结一下支持的功能和语法： 比较操作数可以是属性名称或常量。至少有一个操作数必须是属性名称。特殊常量为false, true, 和 null. 时间戳可以以“YYYY-MM-DD@HH:MM:SS:NANOSECONDS” 格式指定，其中纳秒可以省略。 比较运算符 =/==, &lt;=, &lt;, &gt;=, &gt;, !=/&lt;&gt;,以及 BETWEEN 的比较运算符支持 int, float, double, 和 Date 属性类型。 e.g. age = 45. boolean (bool)属性支持比较运算符=/== and !=/&lt;&gt; 对于字符串和数据（ArrayBuffer）属性，支持 = (and ==), != (and &lt;&gt;), BEGINSWITH, CONTAINS, and ENDSWITH 运算符。e.g. name CONTAINS &#39;Ja&#39;. 通配符比较对于具有相似运算符的字符串是可能的， e.g. name LIKE &#39;*an?&#39; 匹配 “Jane”, “Dan”, “Shane”, 等等. 使用[c]的字符串不区分大小写的比较，e.g. , CONTAINS[c] &#39;Ja&#39;. 注意只有字符“A-Z” 和 “a-z” 会被忽略。 Realm支持以下复合运算符：AND/&amp;&amp;, OR/ ||, 和 NOT/!, e.g. name BEGINSWITH &#39;J&#39; AND age &gt;= 32. 在列表属性上支持聚合表达式 @count/@size, @min, @max, @sum 和 @avg 。eg:employees.@count &gt; 5查找多于5个元素的员工列表。 字符串和二进制属性的聚合表达式 @count/@size ，e.g. name.@size = 5 查找所有名称均为5个字母的名称。 关键路径可以遵循列表属性关系，e.g. child.age &gt;= 13 and `cars.@avg.milage &gt; 1000`. $运算符可以用来替换参数, e.g. child.age &gt;= $0 请参阅下面的示例）。 An non-trivial example on how to query a Realm is: 一个关于如何查询Realm的特殊例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const Realm = require(&apos;realm&apos;);const CarSchema = &#123; name: &apos;Car&apos;, properties: &#123; make: &apos;string&apos;, model: &apos;string&apos;, miles: &#123;type: &apos;int&apos;, default: 0&#125;, &#125;&#125;;const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; name: &apos;string&apos;, cars: &#123;type: &apos;list&apos;, objectType: &apos;Car&apos;&#125;, &#125;&#125;;// Initialize a Realm with Car and Person modelsRealm.open(&#123;schema: [CarSchema, PersonSchema]&#125;) .then(realm =&gt; &#123; // Add persons and their cars realm.write(() =&gt; &#123; let john = realm.create(&apos;Person&apos;, &#123;name: &apos;John&apos;, cars: []&#125;); john.cars.push(&#123;make: &apos;Honda&apos;, model: &apos;Accord&apos;, miles: 1500&#125;); john.cars.push(&#123;make: &apos;Toyota&apos;, model: &apos;Prius&apos;, miles: 2780&#125;); let joan = realm.create(&apos;Person&apos;, &#123;name: &apos;Joan&apos;, cars: []&#125;); joan.cars.push(&#123;make: &apos;Skoda&apos;, model: &apos;Octavia&apos;, miles: 1120&#125;); joan.cars.push(&#123;make: &apos;Ford&apos;, model: &apos;Fiesta&apos;, miles: 95&#125;); joan.cars.push(&#123;make: &apos;VW&apos;, model: &apos;Golf&apos;, miles: 1270&#125;); let jill = realm.create(&apos;Person&apos;, &#123;name: &apos;Jill&apos;, cars: []&#125;); let jack = realm.create(&apos;Person&apos;, &#123;name: &apos;Jack&apos;, cars: []&#125;); jack.cars.push(&#123;make: &apos;Porche&apos;, model: &apos;911&apos;, miles: 965&#125;); &#125;); // Find car owners let carOwners = realm.objects(&apos;Person&apos;).filtered(&apos;cars.@size &gt; 0&apos;); console.log(&apos;Car owners&apos;) for (let p of carOwners) &#123; console.log(` $&#123;p.name&#125;`); &#125; // Find who has been driver longer than average let average = realm.objects(&apos;Car&apos;).avg(&apos;miles&apos;); let longerThanAverage = realm.objects(&apos;Person&apos;).filtered(&apos;cars.@sum.miles &gt; $0&apos;, average); console.log(`Longer than average ($&#123;average&#125;)`) for (let p of longerThanAverage) &#123; console.log(` $&#123;p.name&#125;: $&#123;p.cars.sum(&apos;miles&apos;)&#125;`); &#125; realm.close();&#125;); The output of the code snippet is: 1234567Car owners John Joan JackLonger than average (1288.3333333333333) John: 4280 Joan: 2485 SortingResults允许您根据单个或多个属性指定排序标准和顺序。 例如，以下是上述示例中查询结果返回的汽车结果集,按照数英里进行排序： 12345678910let hondas = realm.objects(&apos;Car&apos;).filtered(&apos;make = &quot;Honda&quot;&apos;);// 按`miles`排序hondas结果集(默认升序)let sortedHondas = hondas.sorted(&apos;miles&apos;);// 按`miles`的降序hondas结果集sortedHondas = hondas.sorted(&apos;miles&apos;, true);// 按`price`降序排序，然后按`miles`升序排序sortedHondas = hondas.sorted([[&apos;price&apos;, true], [&apos;miles&apos;, false]]); Results也可以按照您正在排序的对象链接到的对象的值进行排序： 1234let people = realm.objects(&apos;Person&apos;);// 按他们的汽车的里程(`miles`)排序let sortedPeople = people.sorted(&apos;car.miles&apos;); 基本类型List可以通过调用sorted()而不指定属性来按其值排序： 12let person = realm.objects(&apos;Person&apos;)[0];let sortedTestScores = person.testScores.sorted(); 请注意，Results的顺序只有在查询排序后才能保证一致。出于性能原因，不保证插入顺序。 自动更新结果集Results实例是实时的，自动更新视图到底层数据中，这意味着结果集永远不需要重新获取。修改影响查询的对象将立即反映在结果集中。这是一个例外，当使用 for...in 或 for...of,时，即使其中一些被删除或修改为被排除，它将始终遍历迭代开始时与查询匹配的对象迭代期间的过滤器。 1234567let hondas = realm.objects(&apos;Car&apos;).filtered(&apos;make = &quot;Honda&quot;&apos;);// hondas.length == 0realm.write(() =&gt; &#123; realm.create(&apos;Car&apos;, &#123;make: &apos;Honda&apos;, model: &apos;RSX&apos;&#125;);&#125;);// hondas.length == 1 这适用于所有Results实例，包括由objects,filtered,sorted方法返回的结果集。 Results的这个属性不仅使Realm快速和高效，它允许您的代码更简单，更有灵活性。例如，如果您的视图依赖于查询的结果，则可以将结果存储在属性中并访问它，而无需在每次访问之前刷新其数据。 您可以订阅通知，以了解何时更新Realm数据，指出何时应该刷新应用的UI，而无需重新获取Results。 限制结果集大多数其他数据库技术提供了对查询结果进行“分页”的能力（例如SQLite中的“LIMIT”关键字）。这通常是为了避免从磁盘读取太多或者一次将太多结果拖到内存中而完成的。 由于Realm中的查询是懒惰的，所以执行这种分页行为根本不是必需的，因为只有在明确访问该域后，域才会从查询结果中加载对象。 如果由于与UI相关或其他实现原因，您需要查询中的特定对象子集，那么只需要使用Results对象，并只读出所需的对象。 1234let cars = realm.objects(&apos;Car&apos;);// get first 5 Car objectslet firstCars = cars.slice(0, 5); Realms打开Realm实例打开Realm只是通过实例化一个新的Realm对象来执行。将配置对象传递给构造函数。我们已经看到这个已经在示例中使用了包含schema键的配置对象： 12345678// 获得支持我们对象的默认的Realm实例Realm.open(&#123;schema: [Car, Person]&#125;) .then(realm =&gt; &#123; // ...在这里使用Realm实例 &#125;) .catch(error =&gt; &#123; // 如果发生任何错误,将在这里进行捕获处理 &#125;); 有关配置对象的完整详细信息，请参阅API参考以进行配置。对象的一些更常见的键，除了schema，包括： path: 指定另一个Realm的路径 migration: 迁移功能 sync: 同步对象, ，打开与Realm对象服务器同步的Realm inMemory:Realm将在内存中打开，并且对象不会持久化;一旦最后一个Realm实例关闭，所有对象都会销毁. deleteRealmIfMigrationNeeded:如果需要迁移，则删除领域;这在开发中很有用，因为数据模型可能经常变化 默认Realm实例在以前的所有例子中可能已经注意到路径参数已被省略。在这种情况下，使用默认的Realm路径。您可以使用Realm.defaultPath全局属性访问和更改默认的Realm路径。 其他Realm实例有多个Realm在多个位置持久化是有用的。例如，除了您的主Realm外，您还可能希望将一些数据与您的应用程序捆绑在Realm文件中。您可以通过在初始化Realm时指定路径path参数来执行此操作。所有路径都相对于您的应用程序的可写入文档目录： 12345// Open a realm at another pathRealm.open(&#123; path: &apos;anotherRealm.realm&apos;, schema: [CarSchema]&#125;).then(/* ... */); Schema版本打开Realm时可用的另一个选项是schemaVersion属性。当省略时，schemaVersion属性默认为0.在使用包含与之前规范不同的对象的Schema初始化现有Realm时，需要指定schemaVersion。如果Schema被更新并且schemaVersion不是之前的结构，将抛出异常。 123456789const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; name: &apos;string&apos; &#125;&#125;;// schemaVersion defaults to 0Realm.open(&#123;schema: [PersonSchema]&#125;); 如果你后来做这样的操作： 1234567891011121314const UpdatedPersonSchema = &#123; // 因为schema名称相同, 所以以前的“Person”对象在Realm将会更新 name: &apos;Person&apos;, properties: &#123; name: &apos;string&apos;, dog: &apos;Dog&apos; // 新属性 &#125;&#125;;// 这将抛出异常，因为schema已经改变和`schemaVersion`还没有指定Realm.open(&#123;schema: [UpdatedPersonSchema]&#125;);// 这将成功并将Realm更新到新的schemaRealm.open(&#123;schema: [UpdatedPersonSchema], schemaVersion: 1&#125;); 如果您想要检索当前的Realm 的 schema 的版本，可以使用Realm.schemaVersion方法。 1const currentVersion = Realm.schemaVersion(Realm.defaultPath); 异步打开Realm您可以通过简单地调用构造函数并将配置对象传递给它来创建Realm实例。通常不推荐这样做，因为它会阻止并且可能是一项耗时的操作，尤其是在要迁移的情况下运行,或者Realm已同步,并且您不希望在数据完全下载之前修改数据。 如果你仍然想这样做，模式很简单： 1234const realm = new Realm(&#123;schema: [PersonSchema]&#125;);// You can now access the realm instance.realm.write(/* ... */); 如果Realm具有只读权限，那么您必须使用异步API来打开它。用上述模式打开只读领域将导致错误。 迁移在使用数据库时，您的数据模型很可能随时间而改变。例如，假设我们有以下Person模型： 12345678const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; firstName: &apos;string&apos;, lastName: &apos;string&apos;, age: &apos;int&apos; &#125;&#125; 我们要更新数据模型，用来添加一个name属性，而不是单独的名字和姓氏。为此，我们只需将schema更改为以下内容： 1234567const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; name: &apos;string&apos;, age: &apos;int&apos; &#125;&#125; 在这一点上，如果您使用以前的model版本保存了任何数据，新的代码和Realm已存储在磁盘上的旧数据将不匹配。发生这种情况时，当您尝试使用新的schema打开现有的Realm时，将抛出异常，除非运行迁移。 进行迁移您可以通过更新schemaVersion并定义可选的迁移函数来定义迁移和关联的schema版本。您的迁移函数提供将数据模型从以前的schema转换为新的schema所需的任何逻辑。当打开Realm时，只有在需要迁移时，才会将迁移函数应用于将Realm更新到给定的schema版本。 如果没有提供迁移函数，则当更新到新的schemaVersion时，任何新的属性将自动添加并且旧的属性从数据库中删除。如果您需要在升级版本时更新旧的或填充的新属性，那么可以在迁移函数中执行此操作。例如，假设我们要迁移先前声明的Person模型。您可以使用旧的firstName和lastName属性填充新模式的name属性： 123456789101112131415161718Realm.open(&#123; schema: [PersonSchema], schemaVersion: 1, migration: (oldRealm, newRealm) =&gt; &#123; // only apply this change if upgrading to schemaVersion 1 if (oldRealm.schemaVersion &lt; 1) &#123; const oldObjects = oldRealm.objects(&apos;Person&apos;); const newObjects = newRealm.objects(&apos;Person&apos;); // loop through all objects and set the name property in the new schema for (let i = 0; i &lt; oldObjects.length; i++) &#123; newObjects[i].name = oldObjects[i].firstName + &apos; &apos; + oldObjects[i].lastName; &#125; &#125; &#125;&#125;).then(realm =&gt; &#123; const fullName = realm.objects(&apos;Person&apos;)[0].name;&#125;); 迁移成功完成后，您的应用程序可以像往常一样访问Realm及其所有对象。 线性迁移使用上述迁移模式，您可能会在多个版本上迁移时遇到问题。如果用户跳过应用程序更新，并且在跳过的版本中属性已被更改多次，则可能会发生这种情况。在这种情况下，您可能需要编辑旧的迁移代码才能将数据从旧schema更新到最新schema。 可以通过顺序运行多个迁移来避免此问题，确保将数据库升级到每个先前版本，并运行关联的迁移代码。当遵循这种模式时，永远不需要修改旧的迁移代码，尽管您需要保留所有旧的schema和迁移模块以备将来使用。一个这样的例子： 12345678910111213141516const schemas = [ &#123; schema: schema1, schemaVersion: 1, migration: migrationFunction1 &#125;, &#123; schema: schema2, schemaVersion: 2, migration: migrationFunction2 &#125;, ...]// 要更新的第一个schema是当前schema版本。// 因为第一个schema是在我们的数组里let nextSchemaIndex = Realm.schemaVersion(Realm.defaultPath);while (nextSchemaIndex &lt; schemas.length) &#123; const migratedRealm = new Realm(schemas[nextSchemaIndex++]); migratedRealm.close();&#125;// 用最新的schema打开RealmRealm.open(schemas[schemas.length-1]); NotificationsRealm的 Results和 List 对象提供了addListener方法来注册通知回调。每当更新对象时，将调用更改通知回调。 有两种通知，“Realm通知”（提交写入事务时通知的简单回调）和“Collection通知”（更复杂的回调，它们在插入，删除和更新时接收更改元数据）。 此外，专业版和企业版提供事件处理通知。阅读“Realm移动平台”了解更多信息。 如果Realm升级到了最新版本, 在某些情况下，可以在事务开始时调用监听器 ，或者观察到的Realm实体以触发通知的方式被修改或删除。在这些情况下，监听器在当前写入事务的上下文中运行，因此尝试在通知处理程序中开始新的写入事务将引发异常。您可以使用Realm.isInTransaction属性来确定您的代码是否在写入事务中执行。 Realm通知每次提交写入事务时，Realm实例都会向其他实例发送通知。注册通知： 123456789101112function updateUI() &#123; // ...&#125;// 注册 Realm 通知realm.addListener(&apos;change&apos;, updateUI);// ..之后移除Realm通知realm.removeListener(&apos;change&apos;, updateUI);// .或者将所有通知取消注册realm.removeAllListeners(); Collection 通知Collection通知包含描述在细粒度级别发生了哪些更改的信息。这包括自上次通知以来插入，删除或修改的对象的索引。Collection通知异步传递：首先使用初始结果，然后在任何修改Collection中的任何对象的写入事务之后，从集合中删除对象，或向集合中添加新对象。 当这些变化发生时，addListener通知回调函数会收到两个参数。第一个是更改的collection，第二个是具有关于由删除，插入和修改影响的集合索引的信息的changes对象。 前两项，删除和插入，每当对象开始和停止作为collection的一部分时，记录索引。当您将对象添加到realm或将其从realm中删除时，这将考虑在内。对于Results，当您过滤特定值并且对象已更改，以使其现在与查询匹配或不匹配时，此操作也适用。对于基于List的collection，这适用于从关系中添加或删除对象时。 当对象的属性发生更改时，您的应用程序将被通知有关修改，该属性以前是collection的一部分，并且仍然是其中的一部分。当一对多关系发生变化时，也会发生这种情况，但不考虑反向关系的变化。 12345678910111213141516class Dog &#123;&#125;Dog.schema = &#123; name: &apos;Dog&apos;, properties: &#123; name: &apos;string&apos;, age: &apos;int&apos;, &#125;&#125;;class Person &#123;&#125;Person.schema = &#123; name: &apos;Person&apos;, properties: &#123; name: &#123;type: &apos;string&apos;&#125;, dogs: &#123;type: &apos;list&apos;, objectType: &apos;Dog&apos;&#125;, &#125;&#125;; 让我们假设您正在观察上面的模型代码给出的狗主人列表。当以下情况下，您将收到关于匹配的Person对象的修改的通知： 您修改Person的name属性。 你添加或删除Dog给Person的dogs属性。 您修改属于该Person的 Dog的 age 属性。 这使得可以离散地控制对UI内的内容进行的动画和视觉更新，而不是在每次发生通知时任意重新加载所有内容。 1234567891011121314151617181920212223242526// 注册通知realm.objects(&apos;Dog&apos;).filtered(&apos;age &lt; 2&apos;).addListener((puppies, changes) =&gt; &#123; // 更新UI以响应插入的对象 changes.insertions.forEach((index) =&gt; &#123; let insertedDog = puppies[index]; ... &#125;); // 更新UI以响应修改的对象 changes.modifications.forEach((index) =&gt; &#123; let modifiedDog = puppies[index]; ... &#125;); // 更新UI以响应已删除的对象 changes.deletions.forEach((index) =&gt; &#123; // 已删除的对象无法直接访问 // 支持即将访问已删除的对象... ... &#125;);&#125;);// 取消注册所有的通知realm.removeAllListeners(); 同步在Node.js环境中进行同步，对于Linux系统来说是专业版功能，且必须在有许可的情况下才能执行。 在Linux系统中使用Node.js，需要指定访问许可获取token启动Sync功能。这样做： 1234const token = &quot;eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9...&quot;;// Unlock Professional Edition APIsRealm.Sync.setFeatureToken(token); Realm平台跨网络扩展数据库可以实现跨设备数据同步。为了实现这种同步，Realm提供一组新的类型和类支持被同步的Realm；这些新的类型和类与现存的Realm移动数据库是协同关系。 用户Realm对象服务器中的中心对象是与被同步的Realm相关联的Realm用户 (Realm.Sync.User) 。 User 访问共享Realm可以通过用户名/密码的方式进行验证，或者通过第三方验证数字验证。 创建及注册用户需要两个东西： 可以连接到Realm对象服务器的URL 表明该用户适用于该验证机制的凭据（例如：用户名/密码，权限密码，等等） 认证创建用户id及用户登录需要用到验证。请参考我们的认证文件查找Realm移动平台支持的验证提供者。 指定用户的凭据信息可以通过以下几种方式建立: 提供一个有效的用户名/密码组合 提供一个从Realm支持的第三方验证服务商处获得的token 提供一个token和一个自定义认证提供程序（参见 自定义身份验证） 用户名和密码验证完全由Realm对象服务器管理，允许你完全控制自己的应用程序用户管理。对于其他的验证方法，你的应用程序会登录外部服务器并获取验证token. 下面是一些不同的提供者设置凭证示例. 用户名/密码123456Realm.Sync.User.login(&apos;http://my.realm-auth-server.com:9080&apos;, &apos;username&apos;, &apos;p@s$w0rd&apos;).then(user =&gt; &#123; // user is logged in // do stuff ...&#125;).catch(error =&gt; &#123; // an auth error has occurred&#125;); 用户登录之前，必须先创建账户。你可以使用Admin Dashboard提前在服务器上创建，或者通过调用注册（register）方法 1Realm.Sync.User.register(&apos;http://my.realm-auth-server.com:9080&apos;, &apos;username&apos;, &apos;p@s$w0rd&apos;, (error, user) =&gt; &#123; /* ... */ &#125;); Google12const googleAccessToken = &apos;acc3ssT0ken...&apos;;Realm.Sync.User.registerWithProvider(&apos;http://my.realm-auth-server.com:9080&apos;, &apos;google&apos;, googleAccessToken, (error, user) =&gt; &#123; /* ... */ &#125;); Facebook12const fbAccessToken = &apos;acc3ssT0ken...&apos;;Realm.Sync.User.registerWithProvider(&apos;http://my.realm-auth-server.com:9080&apos;, &apos;facebook&apos;, fbAccessToken, (error, user) =&gt; &#123; /* ... */ &#125;); Custom Auth123456789// The user token provided by your authentication serverconst accessToken = &apos;acc3ssT0ken...&apos;;const user = Realm.Sync.User.registerWithProvider( &apos;http://my.realm-auth-server.com:9080&apos;, &apos;custom/fooauth&apos;, accessToken, (error, user) =&gt; &#123; /* ... */ &#125;); 注：JavaScript软件工具开发包目前不允许发送额外数据。如需要发送不止一个token，请将额外数据加密成JSON并通过accessToken参数传输，再在服务器端解码字符串。 Logging OutLogging out of a synced Realm is simple: 1user.logout(); When a user is logged out, the synchronization will stop. A logged out user can no longer open a synced Realm. Working with UsersThe sync server URL may contain the tilde character (“~”) which will be transparently expanded to represent the user’s unique identifier. This scheme easily allows you to write your app to cater to its individual users. The location on disk for shared Realms is managed by the framework, but can be overridden if desired. 12345678910111213Realm.Sync.User.login(/* ... */, (error, user) =&gt; &#123; if (!error) &#123; Realm.open(&#123; sync: &#123; user: user, url: &apos;realm://object-server-url:9080/~/my-realm&apos;, &#125;, schema: [/* ... */] &#125;).then(realm =&gt; &#123; /* ... */ &#125;); &#125;&#125;); Realm.Sync.User.current can be used to obtain the currently logged in user. If no users have logged in or all have logged out, it will return undefined. If there are more than one logged in users, an error will be thrown. 1const user = Realm.Sync.User.current; If there are likely to be multiple users logged in, you can get a collection of them by calling Realm.Sync.User.all. This will be empty if no users have logged in. 1234567let users = Realm.Sync.User.all;for(const key in users) &#123; const user = users[key]; // do something with the user object.&#125; Opening a Synchronized RealmYou open a synchroized Realm the same say as you open any other Realm. The configuration can be extended with a sync property if you need to configure the synchronization. The optional properties of sync include: error - a callback for error handling/reporting validate_ssl - indicating if SSL certificates must be validated ssl_trust_certificate_path - a path where to find trusted SSL certificates The error handling is set up by registering a callback (error) as part of the configuration: 123456789const config = &#123; sync: &#123; user: userA, url: realmUrl, error: err =&gt; console.log(err) &#125;, schema: [&#123; name: &apos;Dog&apos;, properties: &#123; name: &apos;string&apos; &#125; &#125;]&#125;;var realm = new Realm(config); Partially synchronized RealmsThis feature is included as a tech preview. It is likely to change! Instead of synchronized every object, it is possible to synchronize a subset. This partially synchronized Realm is based on a query, and your client will only receive the objects which fulfil the query. A simple example is: 1234567891011121314const config = &#123; sync: &#123; user: userA, url: realmUrl, partial: true, // &lt;-- this enables a partially synced Realm &#125;, schema: [&#123; name: &apos;Person&apos;, properties: &#123; name: &apos;string&apos;, age: &apos;int&apos; &#125; &#125;]&#125;;var realm = new Realm(config);var partialResults = realm.subscribeToObjects(&apos;Integer&apos;, &apos;age &gt; 5&apos;).then((results, error) =&gt; &#123; return results;&#125;);// partialResults is updated with objects matching the query You may modify objects within the results collection, and these changes will be synced up to the Realm Object Server. Note that conflicts may be resolved differently than if the writes had been made to a fully-synchronized copy of the Realm. Working with a Synchronized RealmOnce you have opened a Realm using a URL to a Realm Object Server and a Userobject, you can interact with it as you would any other Realm in JavaScript. 12345realm.write(() =&gt; &#123; realm.create(&apos;MyObject&apos;, jsonData);&#125;);var objects = realm.objects(&apos;MyObject&apos;); Sync SessionsA synced Realm’s connection to the Realm Object Server is represented by a Sessionobject. Session objects can be retrieved by calling realm.syncSession. The state of the underlying session can be retrieved using the state property. This can be used to check whether the session is active, not connected to the server, or in an error state. Progress notificationsSession objects allow your app to monitor the status of a session’s uploads to and downloads from the Realm Object Server by registering a progress notification callback on a session object by calling [realm.syncSession.addProgressNotification(direction, mode, callback)] or one of the asynchronous methods Realm.open and Realm.openAsync. (these methods support only a subset of the progress notifications modes) Progress notification callbacks will be invoked periodically by the synchronization subsystem. As many callbacks as needed can be registered on a session object simultaneously. Callbacks can either be configured to report upload progress or download progress. Each time a callback is called, it will receive the current number of bytes already transferred, as well as the total number of transferable bytes (defined as the number of bytes already transferred plus the number of bytes pending transfer). To stop receiving progress notifications a callback can be unregistered using [realm.syncSession.removeProgressNotification(callback)]. Calling the function a second time with the same callback is ignored. There are two progress notification modes for the progress notifications: reportIndefinitely - the registration will stay active until the callback is unregistered and will always report the most up-to-date number of transferable bytes. This type of callback could be used to control a network indicator UI that, for example, changes color or appears only when uploads or downloads are actively taking place. 123456789101112let realm = new Realm(config);const progressCallback = (transferred, transferables) =&gt; &#123; if (transferred &lt; transferables) &#123; // Show progress indicator &#125; else &#123; // Hide the progress indicator &#125;&#125;;realm.syncSession.addProgressNotification(&apos;upload&apos;, &apos;reportIndefinitely&apos;, progressCallback);// ...realm.syncSession.removeProgressNotification(progressCallback); forCurrentlyOutstandingWork - the registration will capture the number of transferable bytes at the moment it is registered and always report progress relative to that value. Once the number of transferred bytes reaches or exceeds that initial value, the callback will be automatically unregistered. This type of progress notification could, for example, be used to control a progress bar that tracks the progress of an initial download of a synced Realm when a user signs in, letting them know how long it is before their local copy is up-to-date. 12345678let realm = new Realm(config);const progressCallback = (transferred, transferable) =&gt; &#123; const progressPercentage = transferred / transferable;&#125;;realm.syncSession.addProgressNotification(&apos;download&apos;, &apos;forCurrentlyOutstandingWork&apos;, progressCallback);// ...realm.syncSession.removeProgressNotification(progressCallback); The asynchronous methods Realm.open and Realm.openAsync for opening a Realm can also be used to register a callback for sync progress notifications. In this case only ‘download’ direction and ‘forCurrentlyOutstandingWork’ mode are supported. Additional callbacks can be registered after the initial open is completed by using the newly created Realm instance 12345678910111213141516Realm.open(config) .progress((transferred, transferable) =&gt; &#123; // update UI &#125;) .then(realm =&gt; &#123; // use the Realm &#125;) .catch((e) =&gt; reject(e));Realm.openAsync(config, (error, realm) =&gt; &#123; // use the Realm or report an error &#125;, (transferred, transferable) =&gt; &#123; // update UI &#125;, ); Access ControlThe Realm Mobile Platform provides flexible access control mechanisms to restrict which users are allowed to sync against which Realm files. This can be used, for example, to create collaborative apps where multiple users write to the same Realm. It can also be used to share data in a publisher/subscriber scenario where a single writing user shares data with many users with read permissions. There are three permissions that control the access level of a given Realm for a User: mayRead indicates that the user is allowed to read from the Realm. mayWrite indicates that the user is allowed to write to the Realm. mayManage indicates that the user is allowed to change the permissions for the Realm. Unless permissions are explicitly modified, only the owner (creator) of a Realm can access it. The only exception is admin users: They are always granted all permissions to all Realms on the server. Write-only permissions (i.e., mayWrite set without mayRead) are not currently supported. Please refer to the general Realm Object Server documentation on Access Control to learn more about the concept. Retrieving PermissionsTo get a collection of all the Permissions a user has been granted, use the User.getGrantedPermissions method: 123456789const permissions = user.getGrantedPermissions(&quot;currentUser&quot;);// Permissions is a regular queryconst writePermissions = permissions.filtered(&quot;mayWrite = true&quot;);// Queries are live and emit notificationswritePermissions.addListener((collection, changes) =&gt; &#123; // handle permission changes&#125;); To get permissions granted by a user, pass in &quot;otherUser&quot;. Modifying PermissionsModifying the access control settings for a Realm file is performed by either applying permissions directly or offering them. Granting PermissionsPermission changes can be applied (i.e. granted or revoked) via the User.applyPermissions method in order to directly increase or decrease other users’ access level to a Realm. 123const condition = &#123; userId: &apos;some-user-id&apos; &#125;;const realmUrl = &quot;realm://my-server.com/~/myRealm&quot;;user.applyPermissions(condition, realmUrl, &apos;read&apos;); The condition parameter must be an object containing either userId - use this to apply permissions based on a user’s identity (the internal Id that Realm generates). metadataKey and metadataValue - use the key &#39;email&#39; and an email address as the value to specify a user via the Username/Password provider. The last argument controls the access level that the user will be granted. Higher access implies all lower tiers, e.g. write implies read, admin implies read and write. If none is passed, this will revoke the user’s permissions for this Realm. Offer/ResponseA user can offer permissions to their Realm by sharing the opaque token returned by offerPermissionsAsync: 12345const realmUrl = &apos;realm://my-server.com/~/myRealm&apos;;const oneDay = 1000 * 60 * 60 * 24;const expiration = new Date(Date.now() + 7 * oneDay);userA.offerPermissions(realmUrl, &apos;write&apos;, expiration) .then(token =&gt; &#123; /* ... */ &#125;); The optional expiresAt argument controls when the offer expires - i.e. using the token after that date will no longer grant permissions to that Realm. Users who have already consumed the token to obtain permissions will not lose their access after that date. If you want to revoke permissions, use applyPermissionsAsync. Once a user has received a token, e.g. by sharing it via messaging app, or scanning a QR code, they can consume it to obtain the permissions offered: 123456const token = &quot;...&quot;;userB.acceptPermissionOffer(token) .then(realmUrl =&gt; Realm.open(&#123; schema: [/* ... */], sync: &#123; user: userB, url: realmUrl &#125;&#125;)) .then(realm =&gt; &#123; // ..use the realm &#125;); Migrating from Realm Object Server 1.x to 2.xIf you upgrade Realm Object Server from version 1.x to 2.x, your Realms must be migrated. The new file format is incompatible, and Realms have to be re-downloaded. When a synchronized Realm requiring migration is opened, the Realm file will be copied to a backup location and then deleted so that it can be re-downloaded from the Realm Object Server. An exception will be thrown, and you can choose to migrate your objects from the old Realm. 1234567891011Realm.open(config) .then(realm =&gt; &#123; // you have probably already migrated &#125;) .catch(e =&gt; &#123; if (e.name == &quot;IncompatibleSyncedRealmError&quot;) &#123; const backupRealm = new Realm(e.configuration); // copy objects from backupRealm return; &#125; &#125;); EncryptionPlease take note of the Export Compliance section of our LICENSE, as it places restrictions against the usage of Realm if you are located in countries with an export restriction or embargo from the United States. Realm supports encrypting the database file on disk with AES-256+SHA2 by supplying a 64-byte encryption key when creating a Realm. 123456var key = new Int8Array(64); // pupulate with a secure keyRealm.open(&#123;schema: [CarObject], encryptionKey: key&#125;) .then(realm =&gt; &#123; // Use the Realm as normal var dogs = realm.objects(&apos;Car&apos;); &#125;); This makes it so that all of the data stored on disk is transparently encrypted and decrypted with AES-256 as needed, and verified with a SHA-2 HMAC. The same encryption key must be supplied every time you obtain a Realm instance. There is a small performance hit (typically less than 10% slower) when using encrypted Realms. TroubleshootingMissing Realm ConstructorIf your app crashes, telling you that the Realm constructor was not found, there are a few things you can try: First of all, run react-native link realm If that doesn’t help, and your problem is on Android, try: Add the following in your MainApplication.java file: java import io.realm.react.RealmReactPackage; And add the RealmReactPackage to the list of packages: 123456protected List getPackages() &#123; return Arrays.asList( new MainReactPackage(), new RealmReactPackage() // add this line );&#125; add following two lines in settings.gradle: 12include &apos;:realm&apos;project(&apos;:realm&apos;).projectDir = new File(settingsDir, &apos;../node_modules/realm/android&apos;) If your problem is on iOS, try: 1. Close all simulators/device builds 2. Stop the package manager running in terminal (or better yet, just restart terminal) 3. Open the ios folder in your app root in finder 4. Go into the build folder (note: you won’t see this build folder in atom, so just right click ios and click open in finder) 5. Delete everything inside of the build folder (just move to trash and keep trash around in case you’re worried) 6. Run react-native run-ios to rebuild the whole thing Chrome Debugging is slowWe are aware of this. The reason for this is that since Realm is written in C++ and runs native code, it has to run on the device/simulator. But given the zero-copy architecture, we need to send values in realm objects over the RPC wire every time you inspect an object that is stored in a Realm. We are investigating various potential solutions for this problem. If you want to keep track of it, you can follow the GitHub issue. Crash ReportingWe encourage you to use a crash reporter in your application. Many Realm operations could potentially fail at runtime (like any other disk IO), so collecting crash reports from your application will help identify areas where either you (or us) can improve error handling and fix crashing bugs. Most commercial crash reporters have the option of collecting logs. We strongly encourage you to enable this feature. Realm logs metadata information (but no user data) when throwing exceptions and in irrecoverable situations, and these messages can help debug when things go wrong. Getting help Need help with your code? Ask on StackOverflow. We actively monitor &amp; answer questions on SO! Have a bug to report? Open an issue on our repo. If possible, include the version of Realm, a full log, the Realm file, and a project that shows the issue. Have a feature request? Open an issue on our repo. Tell us what the feature should do, and why you want the feature. Love to follow what comes up next? Look at our changelog. The log shows the latest additions and changes we plan to release soon, and the history of how Realm has evolved.]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何开发一个JavaScript库]]></title>
    <url>%2F2018%2F03%2F02%2Fnpm_lib%2F</url>
    <content type="text"><![CDATA[相关知识NPM包管理器 NPM 基础 NPM 相关知识 在5分钟内搭建企业内部私有npm仓库 基于 Webpack 和 ES6 打造 JavaScript 类库 Webpack Webpack CN1 Webpack CN2 Babel Babel CN ESLint ESLint CN Mocha mocha中文文档 Chai 前端自动化测试之chai.js断言库 UMD实践过程 从零开始搭建一个webpack前端类库脚手架[1]-开端 从零开始搭建一个webpack前端类库脚手架[2]-插件及常用解决方案 从零开始搭建一个webpack前端类库脚手架[3]-强悍的babel 从零开始搭建一个webpack前端类库脚手架[4]-实践 从零开始搭建一个webpack前端类库脚手架[5]-测试你的代码 从零开始搭建一个webpack前端类库脚手架[6]-在github上开源]]></content>
      <categories>
        <category>library</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[人之初,性本善,将之老,性乃迁?]]></title>
    <url>%2F2018%2F02%2F12%2Fday_004%2F</url>
    <content type="text"><![CDATA[事因由于我的爱人, 生完孩子之后一直气血两虚. 为此, 我趁着假期期间, 为她进行食疗. 我刚刚出去, 买了一个乌鸡, 然后去宏泰大药房抓了两味中药 - 人参 | 天麻 . 一个老头一脸全世界都欠他钱似的说: 人参2元钱, 很贵,要吗? 我说:”一两吗”? 他眉毛上调道 : “ 1g ! “. 我应道:”要,就炖一只鸡而已!” 可能是我敏感, 我感觉这个老头并非善类. 在我结账的时候,我就让店员给我打印了明细. 在我去水果摊买水果的时候,就让人家给我称了一下(我跟水果摊的老板比较熟). 水果摊称重是: 人参-10g, 天麻-40g. 药店称重是: 人参-15g, 天麻-40g. 除此之外,我发现还多出莫名其妙的13元. 少了我5g人参. 2.4元 *5g = 12元 + 13元 = 总共多要了我25元! 我就回去找了一下. 店员给我退了那莫名其妙的13元. 然后她说:”你说的人参不是10g,是15g,还要吗?” 你懂得,我不可能为了那12元, 耽误我爱人的食补. 后果我最大的感触就是:物以类聚,人以群分! 远离垃圾人! 间接地我也明白了:为什么大多数在一线打拼的年轻人不愿意回家乡发展了. 大城市的医疗体系基本上都是透明的.比如一味药几克几两, 每克多少钱, 都清清楚楚明明白白的. 我们都习惯这种公开透明且相对公平的生活环境. 重点是,我们起初都是相信人性的美好. 我们都相信你们只是简简单单地做事而已, 根本不会上升到小利小惠的算计上. 虽然我讲的有失偏颇, 但这也是一个点,一个面吧. 内修我想说一句狠话:大爷您这么大年纪了, 就不为您的子孙后代积点德吗? 还是多修点了凡四训吧 ! 文字记录一下, 就此翻篇.]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[6个简单的步骤来自动测试和部署你的JavaScript程序到GitHub页面]]></title>
    <url>%2F2018%2F02%2F05%2Fautomatically_test_deploy_js_app_to_github_pages%2F</url>
    <content type="text"><![CDATA[Workflow as per example below Wouldn’t it be amazing if your new React app tested and deployed itself automatically? It’s very simple thanks to GitHub and Travis CI (CI stands for Continuous Integration). This guide is for you if you: Know how to create a JavaScript app. This example focuses on a simple React app, but all apps that follow the typical test and build jobs can be adapted. Know what unit tests are. Reasonably familiar with Git and/or GitHub. Reasonably familiar with the command line. Don’t know how to set up automatic tests and deployment. Need free hosting to show off your latest JavaScript project. The guide will show how to create a simple React application, push it to GitHub, link it to Travis CI and then to GitHub Pages. The tutorial will not focus on what React is. Step 1. Create a JavaScript app. Add tests.For the purposes of this tutorial I will be using create-react-app, an ingenious tool for quick and tool-less creation of React apps. Apps made using the tool already have a sample unit test written. Make sure you have NodeJS and NPM installed. Run quick test commands node -v and npm -v to double-check. Runnpm install -g create-react-app to install the create-react-app utility globally on your computer To create a new app, create-react-app test-app . This command takes some time. Once complete, your app will be located in the /test-app directory. Make sure the app runs properly. Navigate to the project directory and run npm run start or npm start to start the development server. Once everything works, cancel the task by pressing ctrl+c. Make sure that npm run test runs successfully. It should have a single test suite setup with a single test in it. Make sure the npm run build command works. It should create a deployment-ready build in the /build folder. Step 2. Create a GitHub repository, push your app.Create an empty repository in GitHub without any files it. Make sure you have an SSH key added for your machine, then add your project files to a new git repo, then push it: 12345git initgit add .git commit -m &quot;first commit&quot;git remote add origin (URL OF YOUR REPOSITORY)git push -u origin master Refresh your repository page to make sure your app is now on GitHub. Step 3. Generate a GitHub token.On GitHub, go to your account settings -&gt; Personal Access Tokens. Generate a new token. The token has to have the ‘repo’ scope selected in order to be able to access your repositories. Save the token in a save place and do not include in any public repositories in plain text. The token will be used in the next section. Note: the token should not be shared with anyone, it essentially gives an app access to edit your repositories. Step 4. Link your project to Travis CI, add the .travis.yml file.If you haven’t already, create a Travis CI profile using your GitHub profile. Add your newly added GitHub project to Travis using the green switch. Before we create the Travis config file, we will add the GitHub token you created above to the Travis project. Go to the project settings in Travis and add a new Environmental Variable. Call the variable github_token, and set the value to the token you got from GitHub. This will enable Travis to use your token without you having to publicly put in in your repository. Add the following .travis.yml file to the root directory of your project: 12345678910111213141516language: node_jsnode_js: - &quot;stable&quot;cache: directories: - node_modulesscript: - npm test - npm run builddeploy: provider: pages skip_cleanup: true github_token: $github_token local_dir: build on: branch: master What each line means in the file: 1language: node_js Tells Travis to use NodeJS. 12node_js: - &quot;stable&quot; Tells Travis which version(s) of NodeJS to use. Feel free to add additional versions, such as - &quot;7&quot; or - &quot;6&quot; . 123cache: directories: - node_modules Tells Travis to cache the node_modules directory between builds instead of re-compiling the whole directory each time you commit. 123script: - npm test - npm run build Important bit: tells Travis which commands to run. Commands run in a succession, and if a command fails (i.e. exits with anything but 0), the build is marked as failed. Failed builds do not get deployed. Note that Travis knows to npm install already. 1234567deploy: provider: pages skip_cleanup: true github_token: $github_token local_dir: build on: branch: master The deployment structure. Detailed documentation about other deployment platforms available can be found here. provider: pages specifies we’re using GitHub Pages. skip_cleanup: true tells Travis not to delete build files. github_token: $github_token sets the GitHub token. We used an environment variable to avoid exposing our token to the public. local_dir: build tells Travis to only take the files from the /build directory for deployment on: branch: master tells Travis when to trigger deployment. We only want to deploy when we push to the master branch of the repository. Step 5. Set the homepage address in package.jsonWhen you use GitHub Pages, your project is going to be hosted on a URL that looks like this: 1https://USERNAME.github.io/PROJECT_NAME/ Following the above syntax, edit your package.json file to add a new entry with the URL of your project: 1&quot;homepage&quot;: &quot;https://USERNAME.github.io/PROJECT_NAME/&quot; Setting the homepage informs the npm run build to add the right paths to the HTML file generated in the build directory. Step 6. Commit and push.Add the new .travis.yml file to git, commit the repository and push it to GitHub. Travis will automatically start building, testing and deploying it. 123git add .git commit -m &quot;Added the travis file and homepage&quot;git push origin master Travis will queue your project and build it as soon as it can. You can follow the execution on your home page. Once tested and built — your project will update on GitHub in settings to show that it’s now hosted on GitHub Pages. A new branch called gh-pages is created on your repository. The page contains the output from the npm run build command. All done!Check the URL created above and you should see your app there. This is the app I used for the guide, feel free to use for reference: source code, page hosted on GitHub Pages and the Travis logs. References:Travis CI Docs: https://docs.travis-ci.com/ Travis CI Docs - GitHub Pages deployment: https://docs.travis-ci.com/user/deployment/pages/ Create-React-App Docs — Deployment: https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#github-pages]]></content>
      <categories>
        <category>ci</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[教育的本质]]></title>
    <url>%2F2018%2F01%2F14%2Fday_003%2F</url>
    <content type="text"><![CDATA[弱谈教育本质环境人的这一辈子是一个很奇妙的过程，好比一滴纯心的墨。 如果滴落到一瓶水中，此后的半生可能需要不停地沉淀，才能将其澄清； 如果滴落到一片海中，瞬间的凝结之后，随之而来的就是消融，慢慢地拥有了海的壮阔与平静。 从上面这个类比当中，我们能意识到一个环境的重要性，尤其是一个教育环境！ 古有“孟母三迁”，今有选择各种“托辅班”，哈哈，是不是戳到各位家长痛点了！ 教育孩子如履薄冰啊，各位宝妈宝爸们该何去何从呢？莫急，听波哥慢慢给您道来。 人品波哥，这些年算是走过南也闯过北，就连传销窝子也趟过水。干过基层的机械工，做过高端的IT民工。 广东、北京、上海等一线城市辗转流离，随心而安。在企业与公司之间迎来送往，也有小10年了。 深知一家公司需要的是什么类型的人才。 开门见山的说：他们需要的是人品好的人！侧重点是人，而不是人才！为什么呢？ 因为如果一个人的能力不足，可以在入职之后慢慢地培养。而如果一个人的人品不好，公司却培养不起。 为什么培养不起？因为那是一个人从小到大的家教以及学校教育的18个春秋，成本太高！ 关于教育缺失的新闻也不少，在此不再列举，但我们得有心感知人品的重要性。 友情提示：《弟子规》是个宝啊，多多践行，让人生更美好！ 习惯在人品好的前提下，体现一个的人能力的第一要素，波哥认为是一个人生活习惯，工作习惯。 习惯能给你带来什么好处？请记住这2个关键词：健康，效率！ 小举几例: 养成多多喝水的好习惯：能防止多少疾病你知道吗？ 养成早睡早起的好习惯：能让你拥有的幸福叫做健康！ 养成善于总结的好习惯：能让你不乱于心也不惧未来！ 养成专注于心的好习惯：岂止是工作效率上的提升？难道没有那种忘我的乐趣？难道没有小小的成就感？ 习惯对于一个人来说，能让你知足，让你有幸福感。 波哥认识的一位好友就是这种类型的人，慢慢往下读呗，我会引荐给你们认识哦！ 知识最后，我们要谈谈知识，说的情怀一点应该叫文化。 关于什么是文化？我最欣赏的回答，是作家梁晓声的四句概括： 1.根植于内心的修养； 2.无需提醒的自觉； 3.以约束为前提的自由； 4.为别人着想的善良。 有木有发现这段总结，其实是包括我们之前谈论的人品和习惯，在哪里体现的呢？ 善良是不是人品？约束是不是习惯？ 其实，波哥在这里想谈的更多是知识，应该更确切一点的说是技能，相当于大学里的专业。 这部分固然重要，但是你试想一下，如果一个人，一个自然人，他有了好的人品，好的生活习惯，好的工作习惯。它的技能还会差了吗？ 尤其在中国这个社会发展中，你大学里学的专业，毕业之后未必就做的是相关专业的工作啊？如果那样的话，你去了一家公司，是不是在技能方面要从头开始学习了呢？这里你可能还有一个疑问：既然你的专业不与招聘企业的用人需求相符，为什么企业还愿意录用你呢？答案在前面我已经告诉你了！因为你拥有好的人品，好的习惯。公司很愿意给你机会，让你去学习技能方面的知识。毕竟技能的学习对于公司相对来说，成本比较低！ 职业英语人接下来，我要给你介绍一下：我这位认识多年的好友了，她叫孙梅，是一位人品与习惯俱佳的音乐人！不好意思，刚才打错字了，毕竟英语与音乐是如此的容易打错字，那就将错就错吧。她是一位在英语这门语言方面的一位终身学习者和践行者。我不想在介绍我这位好友的方面，占用更多篇幅的文字。我可以负责任的告诉你，她就是符合我这篇文章描述的一个真正意义的人。对，你没有猜错，我就是要给她打广告，～哈哈～因为她终于要开创自己的教育事业了，我和我的以及她的朋友都为此开心不已。 平述教育平台童花树专注于幼儿英语启蒙的教育与研究，提供优质的教育资源，打造寓教于乐的教学平台。 强宣教育资源选择童花树的理由: 专业的教师资源 优质的教学和休息环境​ 孩子价值观培养的小课程 一周一节免费的公益课 优惠的价格]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[没有想象的那么难]]></title>
    <url>%2F2018%2F01%2F02%2Fday_002%2F</url>
    <content type="text"><![CDATA[昨晚,凌晨三点还未入眠. 其中反复的想过今天要做的工作. 不知道用什么方式去实现. 我这种生活跟工作分不开的状态很不好. 然而事情并没有想象的那么难! 因此,以后,安心睡觉. 工作的时候,安静思考,沉着编码! 一切没有想象的那么难!]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[不卑不亢]]></title>
    <url>%2F2018%2F01%2F01%2Fday_001%2F</url>
    <content type="text"><![CDATA[今天通过”吃饺子”事件 我懂得了 从容不迫地做事 不卑不亢地表达.]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Realm for JavaScript(1.10.1)]]></title>
    <url>%2F2017%2F07%2F29%2Frealm_js_doc%2F</url>
    <content type="text"><![CDATA[介绍Realm JavaScript使您能够以安全，持久和快速的方式有效地编写应用程序的Model层。它的设计是可以与 React Native 和 Node.js一起工作。 以下是使用React Native的示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 定义您的Model及其属性class Car &#123;&#125;Car.schema = &#123; name: &apos;Car&apos;, properties: &#123; make: &apos;string&apos;, model: &apos;string&apos;, miles: &apos;int&apos;, &#125;&#125;;class Person &#123;&#125;Person.schema = &#123; name: &apos;Person&apos;, properties: &#123; name: &#123;type: &apos;string&apos;&#125;, cars: &#123;type: &apos;list&apos;, objectType: &apos;Car&apos;&#125;, picture: &#123;type: &apos;data&apos;, optional: true&#125;, // 可选属性 &#125;&#125;;// 获取支持我们对象的默认Realm实例let realm = new Realm(&#123;schema: [Car, Person]&#125;);// 创建Realm对象并写入本地存储realm.write(() =&gt; &#123; let myCar = realm.create(&apos;Car&apos;, &#123; make: &apos;Honda&apos;, model: &apos;Civic&apos;, miles: 1000, &#125;); myCar.miles += 20; // 更新属性值&#125;);// 查询出所有具有较高里程数的车辆let cars = realm.objects(&apos;Car&apos;).filtered(&apos;miles &gt; 1000&apos;);// 将返回一个结果对象(我们的1辆车)cars.length // =&gt; 1// 添加另一辆车realm.write(() =&gt; &#123; let myCar = realm.create(&apos;Car&apos;, &#123; make: &apos;Ford&apos;, model: &apos;Focus&apos;, miles: 2000, &#125;);&#125;);// 查询结果将实时更新cars.length // =&gt; 2 入门安装按照以下安装说明，通过npm安装Realm JavaScript，或者在 GitHub上查看源代码。 React Native Node.js 必要条件 确保您的环境设置为运行React Native应用程序。按照React Native说明开始使用。 使用Realm的应用程序可以同时针对iOS和Android。 支持React Native 0.20.0及更高版本。 确保React Native软件包管理器（rnpm）全局安装并且是最新的： 1npm install -g rnpm 安装 创建一个新的React Native工程: 1react-native init &lt;project-name&gt; 将目录更改为新项目(cd &lt;project-name&gt;)，并添加realm依赖 1npm install --save realm 接下来，将项目链接到realm原生模块。 React Native &gt;= 0.31.0 1react-native link realm React Native &lt; 0.31.0 1rnpm link realm Android的警告：根据版本，rnpm可能会生成无效的配置，正确更新Gradle(android/settings.gradle and android/app/build.gradle) ，但无法添加Realm模块。确认react-native link已添加了Realm模块;如果没有，请通过以下步骤手动链接到库： 添加以下行到 android/settings.gradle: gradle include &#39;:realm&#39; project(&#39;:realm&#39;).projectDir = new File(rootProject.projectDir, &#39;../node_modules/realm/android&#39;) 将编译行添加到 android/app/build.gradle 中的依赖项: gradle dependencies { compile project(&#39;:realm&#39;) } 在MainApplication.java中添加导入并链接包：: 1234567891011import io.realm.react.RealmReactPackage; // 添加导入public class MainApplication extends Application implements ReactApplication &#123; @Override protected List&lt;ReactPackage&gt; getPackages() &#123; return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new RealmReactPackage() // 添加链接包 ); &#125;&#125; 你现在已经准备好了。要查看Realm中的action，请在index.ios.js或index.android.js中添加以下作为class &lt;project-name&gt;的定义： 123456789101112131415161718192021const Realm = require(&apos;realm&apos;);class &lt;project-name&gt; extends Component &#123; render() &#123; let realm = new Realm(&#123; schema: [&#123;name: &apos;Dog&apos;, properties: &#123;name: &apos;string&apos;&#125;&#125;] &#125;); realm.write(() =&gt; &#123; realm.create(&apos;Dog&apos;, &#123;name: &apos;Rex&apos;&#125;); &#125;); return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.welcome&#125;&gt; Count of Dogs in Realm: &#123;realm.objects(&apos;Dog&apos;).length&#125; &lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 然后，您可以在设备和模拟器中运行应用程序！ 安装示例可以从Github克隆可选的示例库。 1git clone https://github.com/realm/realm-js.git 更改到克隆的目录，并更新子模块： 12cd realm-jsgit submodule update --init --recursive 在Android上，您需要安装NDK，并且必须设置ANDROID_NDK环境变量. 1export ANDROID_NDK=/usr/local/Cellar/android-ndk/r10e React Native示例在examples目录中。您必须为每个示例运行npm install。 获得帮助 需要帮助你的代码？ 在StackOverflow上提问吧. 我们积极监督并立马回答您的问题！ 有Bug上报? 在我们Github库上提问吧. 如果可能，请包括Realm版本，完整日志，Realm文件以及显示问题的项目。 有功能请求吗? 在我们Github库上提交请求吧吧. 告诉我们功能应该做什么，以及为什么要这个功能. 如果您使用崩溃记录（如Crashlytics或HockeyApp），请确保启用日志收集。Realm在抛出异常和不可恢复的情况下记录元数据信息（但不包含用户数据），并且这些消息可以帮助在出现问题时进行调试。 模型Realm数据模型由初始化期间传递到Realm的schema信息定义。对象的schema由对象的名称(name)和一组属性组成，每个属性由名称(name)和类型(type)以及对象和列表属性的objectType组成。您还可以将每个属性指定为可选的或具有默认值。 12345678910111213141516171819202122var Realm = require(&apos;realm&apos;);const CarSchema = &#123; name: &apos;Car&apos;, properties: &#123; make: &apos;string&apos;, model: &apos;string&apos;, miles: &#123;type: &apos;int&apos;, default: 0&#125;, &#125;&#125;;const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; name: &apos;string&apos;, birthday: &apos;date&apos;, cars: &#123;type: &apos;list&apos;, objectType: &apos;Car&apos;&#125;, picture: &#123;type: &apos;data&apos;, optional: true&#125;, // 可选的属性 &#125;&#125;;// 使用Car和Person的模型初始化Realm实例let realm = new Realm(&#123;schema: [CarSchema, PersonSchema]&#125;); 如果您希望对象继承自现有类，则只需在对象构造函数中定义schema，并在创建realm时传递构造函数： 12345678910111213class Person &#123; get ageSeconds() &#123; return Math.floor((Date.now() - this.birthday.getTime())); &#125; get age() &#123; return ageSeconds() / 31557600000; &#125;&#125;Person.schema = PersonSchema;// Note here we are passing in the `Person` constructorlet realm = new Realm(&#123;schema: [CarSchema, Person]&#125;); 一旦定义了对象模型，就可以从Realm创建和获取对象： 1234567891011realm.write(() =&gt; &#123; let car = realm.create(&apos;Car&apos;, &#123; make: &apos;Honda&apos;, model: &apos;Civic&apos;, miles: 750, &#125;); // 您可以访问并设置模型中定义的所有属性 console.log(&apos;Car type is &apos; + car.make + &apos; &apos; + car.model); car.miles = 1500;&#125;); 支持的类型Realm支持以下基本类型: bool, int, float, double, string, data, 和 date. bool 属性映射到 JavaScript Boolean 对象 int, float, and double 属性映射到 JavaScript Number 对象. 内部的“int”和“double”被存储为64位，而float以32位存储。 string 属性映射到 String data 属性映射到 ArrayBuffer date 属性映射到 Date 将基本属性指定为简写时，您可以仅指定类型，而不必指定具有单个条目的字典： 12345678const CarSchema = &#123; name: &apos;Car&apos;, properties: &#123; // 以下属性类型是等效的 make: &#123;type: &apos;string&apos;&#125;, model: &apos;string&apos;, &#125;&#125; 关系一对一关系 对于一对一的关系，您可以将引用的对象schema的name属性指定为属性的类型(type)： 12345678const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; // 所有以下属性定义是等效的 car: &#123;type: &apos;Car&apos;&#125;, van: &apos;Car&apos;, &#125;&#125;; 使用对象属性时，需要确保所有引用的类型都存在于用于打开Realm的schema中： 12// CarSchema is needed since PersonSchema contains properties of type &apos;Car&apos;let realm = new Realm(&#123;schema: [CarSchema, PersonSchema]&#125;); 访问对象属性时，可以使用普通属性语法访问嵌套属性： 12345678910realm.write(() =&gt; &#123; var nameString = person.car.name; person.car.miles = 1100; // 通过将属性设置为有效的JSON来创建一个新的Car person.van = &#123;make: &apos;Ford&apos;, model: &apos;Transit&apos;&#125;; // 将两个属性设置为同一个汽车实例 person.car = person.van;&#125;); 一对多关系对于多对多关系，您必须将属性类型指定为列表(list)以及objectType： 123456const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; cars: &#123;type: &apos;list&apos;, objectType: &apos;Car&apos;&#125;, &#125;&#125; 访问列表属性时，返回一个List对象。列表(List)具有与常规JavaScript数组非常相似的方法。最大的区别是，对列表进行的任何更改都会自动持续到底层的Realm。此外，列表属于从其获取的基础对象 - 您只能通过从拥有对象访问属性来获取List实例，并且不能手动创建。 123456789let carList = person.cars;// 将新车添加到列表中realm.write(() =&gt; &#123; carList.push(&#123;make: &apos;Honda&apos;, model: &apos;Accord&apos;, miles: 100&#125;); carList.push(&#123;make: &apos;Toyota&apos;, model: &apos;Prius&apos;, miles: 200&#125;);&#125;);let secondCar = carList[1].model; // 访问使用数组索引 多对多关系链接是单向的。所以如果一对多的属性Person.dogs链接到一个Dog实例和一个属性Dog.owner链接到Person，这些链接是彼此独立的。将Dog添加到Person实例的 dogs 属性不会自动将该狗的owner 属性设置为此Person。因为手动同步对关系是容易出错的，复杂的并复制信息，所以Realm提供链接对象属性来表示这些反向关系。 使用链接对象属性，可以从特定属性获取链接到给定对象的所有对象。例如，Dog对象可以具有一个名为owner的属性，该属性包含其dogs属性中具有这个确切Dog对象的所有Person对象。通过owners属性的linkingObjects类型，指定它与Person对象的关系。 这样做可以通过owners属性指定它与Person对象的关系。 12345678910111213const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; dogs: &#123;type: &apos;list&apos;, objectType: &apos;Dog&apos;&#125;, &#125;&#125;const DogSchema = &#123; name:&apos;Dog&apos;, properties: &#123; owners: &#123;type: &apos;linkingObjects&apos;, objectType: &apos;Person&apos;, property: &apos;dogs&apos;&#125; &#125;&#125; 一个linksObjects属性可以指向一个List属性（多对多关系）或一个Object属性（一对一关系）： 12345678910111213const ShipSchema = &#123; name: &apos;Ship&apos;, properties: &#123; captain: &apos;Captain&apos; &#125;&#125;const CaptainSchema = &#123; name: &apos;Captain&apos;, properties: &#123; ships: &#123;type: &apos;linkingObjects&apos;, objectType: &apos;Ship&apos;, property: &apos;captain&apos;&#125; &#125;&#125; 访问linksObjects属性时，返回一个Results对象，因此完全支持进一步的查询和排序。linksObject属性属于它们从中获取的对象，不能直接设置或操作。当事务提交时，它们将自动更新。 访问没有schema的linkingObjects：如果您打开了一个Realm文件而不指定schema，例如在Realm Functions回调中，您可以通过在Object实例上调用 linkingObjects(objectType, property) 来获取linksObjects属性： 12let captain = realm.objectForPrimaryKey(&apos;Captain&apos;, 1);let ships = captain.linkingObjects(&apos;Ship&apos;, &apos;captain&apos;); 可选属性属性可以通过在【属性定义】中指定【可选指示符】来声明为【可选属性 或 非可选属性】： 12345678910111213141516171819202122232425const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; name: &#123;type: &apos;string&apos;&#125;, // 必需属性 birthday: &#123;type: &apos;date&apos;, optional: true&#125;, // 可选属性 // object properties are always optional car: &#123;type: &apos;Car&apos;&#125;, &#125;&#125;;let realm = new Realm(&#123;schema: [PersonSchema, CarSchema]&#125;);realm.write(() =&gt; &#123; // 可选属性可以在创建时设置为null或未定义 let charlie = realm.create(&apos;Person&apos;, &#123; name: &apos;Charlie&apos;, birthday: new Date(1995, 11, 25), car: null, &#125;); // 可选属性可以设置为`null`，`undefined`或新的非空值 charlie.birthday = undefined; charlie.car = &#123;make: &apos;Honda&apos;, model: &apos;Accord&apos;, miles: 10000&#125;;&#125;); 如上所述，对象属性始终是可选的，不需要可选名称。列表属性不能被声明为可选或设置为null。您可以使用空数组来设置或初始化列表以将其清除。 默认属性值可以通过在属性定义中设置默认指示符来指定默认属性值。要使用默认值，请在创建对象期间保留未指定的属性。 1234567891011121314const CarSchema = &#123; name: &apos;Car&apos;, properties: &#123; make: &#123;type: &apos;string&apos;&#125;, model: &#123;type: &apos;string&apos;&#125;, drive: &#123;type: &apos;string&apos;, default: &apos;fwd&apos;&#125;, miles: &#123;type: &apos;int&apos;, default: 0&#125; &#125;&#125;;realm.write(() =&gt; &#123; // 由于`miles`被遗漏，它默认为“0”，而`drive`被指定，它会覆盖默认值 realm.create(&apos;Car&apos;, &#123;make: &apos;Honda&apos;, model: &apos;Accord&apos;, drive: &apos;awd&apos;&#125;);&#125;); 索引属性您可以将索引的指示符添加到属性定义，以使该属性进行索引。 目前支持 int, string, 和 bool 属性类型： 1234567var BookSchema = &#123; name: &apos;Book&apos;, properties: &#123; name: &#123; type: &apos;string&apos;, indexed: true &#125;, price: &apos;float&apos; &#125;&#125;; 索引属性将极大地加快查询的属性进行比较，但是以较慢的插入为代价。 主键您可以在对象模型中为string和int属性指定primaryKey属性。声明一个主键可以对对象进行高效查找和更新，并强制执行每个值的唯一性。一旦有一个主键的对象被添加到Realm，主键就不能被改变了。 123456789const BookSchema = &#123; name: &apos;Book&apos;, primaryKey: &apos;id&apos;, properties: &#123; id: &apos;int&apos;, // primary key title: &apos;string&apos;, price: &apos;float&apos; &#125;&#125;; 主键属性自动编入索引。 写创建，更新和删除Realm中的对象的操作必须在write()事务块中进行。请注意，写入事务具有不可忽略的开销;您应该尽量减少代码中写入块的数量。 创建对象使用create方法创建对象： 123456789let realm = new Realm(&#123;schema: [CarSchema]&#125;);try &#123; realm.write(() =&gt; &#123; realm.create(&apos;Car&apos;, &#123;make: &apos;Honda&apos;, model: &apos;Accord&apos;, drive: &apos;awd&apos;&#125;); &#125;);&#125; catch (e) &#123; console.log(&quot;Error on creation&quot;);&#125; 请注意， write() 中抛出的任何异常都将取消事务。所有示例中都不会显示try/catch 块，但这是很好的做法。 嵌套对象如果对象具有对象属性，则可以通过为每个子属性指定JSON值来递归地创建这些属性的值： 123456789let realm = new Realm(&#123;schema: [PersonSchema, CarSchema]&#125;);realm.write(() =&gt; &#123; realm.create(&apos;Person&apos;, &#123; name: &apos;Joe&apos;, // 嵌套对象是递归创建的 car: &#123;make: &apos;Honda&apos;, model: &apos;Accord&apos;, drive: &apos;awd&apos;&#125;, &#125;);&#125;); 更新对象Typed Updates 键入的更新您可以通过在写事务中设置其属性来更新任何对象。 123realm.write(() =&gt; &#123; car.miles = 1100;&#125;); 使用主键创建和更新对象如果您的模型类包含主键，则可以根据主键值智能地更新或添加对象。这是通过将true作为第三个参数传递给create方法： 1234567realm.write(() =&gt; &#123; // Create a book object realm.create(&apos;Book&apos;, &#123;id: 1, title: &apos;Recipes&apos;, price: 35&#125;); // Update book with new price keyed off the id realm.create(&apos;Book&apos;, &#123;id: 1, price: 55&#125;, true);&#125;); 在上面的例子中，由于一个对象已经存在，id值为1，并且我们已经为第三个参数传递了true，所以price属性被更新，而不是尝试创建一个新的对象。由于name属性被省略，对象保留此属性的原始值。请注意，当使用主键属性创建或更新对象时，必须指定主键。 删除对象可以通过在写事务中调用delete方法来删除对象。 1234567891011realm.write(() =&gt; &#123; // Create a book object let book = realm.create(&apos;Book&apos;, &#123;id: 1, title: &apos;Recipes&apos;, price: 35&#125;); // Delete the book realm.delete(book); // Delete multiple books by passing in a `Results`, `List`, or JavaScript `Array` let allBooks = realm.objects(&apos;Book&apos;); realm.delete(allBooks); // Deletes all books&#125;); 查询查询允许您从Realm中获取单个类型的对象，并可选择过滤和排序这些结果。所有查询（包括查询和属性访问）在Realm中都是懒加载的。仅在访问对象和属性时才读取数据。这样，您可以以高效的方式表示大量数据。 执行查询时，您将返回一个Results对象。Results只是您的数据视图，不可变。 从Realm中检索对象的最基本方法是使用Realm中的对象方法来获取给定类型的所有对象 1let dogs = realm.objects(&apos;Dog&apos;); // retrieves all Dogs from the Realm 过滤您可以通过使用查询字符串调用过滤的方法来获取已过滤的结果。 例如，以下将改变我们早期的例子，以检索所有具有颜色tan的狗，以’B’开头的名字： 12let dogs = realm.objects(&apos;Dog&apos;);let tanDogs = dogs.filtered(&apos;color = &quot;tan&quot; AND name BEGINSWITH &quot;B&quot;&apos;); 目前，查询语言只支持NSPredicate语法的一部分。 数字属性支持基本比较运算符 ==, !=, &gt;, &gt;=, &lt;, 和 &lt;=。 ==, BEGINSWITH, ENDSWITH, 和 CONTAINS 支持字符串属性。 字符串比较可以通过将[c]附加到运算符来进行区分大小写： ==[c], BEGINSWITH[c] 等。 可以通过在查询中指定关键字来完成对链接或子对象上的属性进行过滤，例如car.color == &#39;blue&#39;。 排序Results允许您根据单个或多个属性指定排序标准和顺序。例如，以下呼叫会从上面的例子中以几英里的速度排列返回的车辆： 1234let hondas = realm.objects(&apos;Car&apos;).filtered(&apos;make = &quot;Honda&quot;&apos;);// Sort Hondas by mileagelet sortedHondas = hondas.sorted(&apos;miles&apos;); 请注意，仅当查询排序时，结果的顺序才能保持一致。出于性能原因，不能保证插入顺序不被保留。 自动更新结果集Results实例是活动的，自动更新到底层数据的视图，这意味着结果不必重新获取。修改影响查询的对象将立即反映在结果中。 1234567let hondas = realm.objects(&apos;Car&apos;).filtered(&apos;make = &quot;Honda&quot;&apos;);// hondas.length == 0realm.write(() =&gt; &#123; realm.create(&apos;Car&apos;, &#123;make: &apos;Honda&apos;, model: &apos;RSX&apos;&#125;);&#125;);// hondas.length == 1 这适用于所有Results实例，包括由objects,filtered,sorted方法返回的结果集。 Results的这个属性不仅使Realm快速和高效，它允许您的代码更简单，更有灵活性。例如，如果您的视图依赖于查询的结果，则可以将结果存储在属性中并访问它，而无需在每次访问之前刷新其数据。 您可以订阅通知，以了解何时更新Realm数据，指出何时应该刷新应用的UI，而无需重新获取Results。 限制结果集大多数其他数据库技术提供了对查询结果进行“分页”的能力（例如SQLite中的“LIMIT”关键字）。这通常是为了避免从磁盘读取太多或者一次将太多结果拖到内存中而完成的。 由于Realm中的查询是懒惰的，所以执行这种分页行为根本不是必需的，因为只有在明确访问该域后，域才会从查询结果中加载对象。 如果由于与UI相关或其他实现原因，您需要查询中的特定对象子集，那么只需要使用Results对象，并只读出所需的对象。 1234let cars = realm.objects(&apos;Car&apos;);// get first 5 Car objectslet firstCars = cars.slice(0, 5); RealmsRealm是Realm移动数据库容器的实例。Realm可以是本地的或同步的。同步Realm使用Realm对象服务器将其内容与其他设备透明地同步。当您的应用程序继续使用同步的Realm，就像它是本地文件一样，该Realm中的数据可能会被具有该Realm的写入权限的任何设备更新。实际上，您的应用程序可以以任何类型的Realm以同样的方式运行，尽管打开一个同步的Realm需要一个已经被对象服务器认证的用户，并被授权打开该Realm。 有关Realm的更详细的讨论，请阅读Realm数据模型。 打开Realm打开Realm只是通过实例化一个新的Realm对象来执行。将配置对象传递给构造函数。我们已经看到这个已经在示例中使用了包含schema键的配置对象： 12// Get the default Realm with support for our objectslet realm = new Realm(&#123;schema: [Car, Person]&#125;); 有关配置对象的完整详细信息，请参阅API参考以进行配置。对象的一些更常见的键，除了schema，包括： path: 指定另一个Realm的路径 migration: 迁移功能 sync: 同步对象, ，打开与Realm对象服务器同步的Realm 默认Realm在以前的所有例子中可能已经注意到路径参数已被省略。在这种情况下，使用默认的Realm路径。您可以使用Realm.defaultPath全局属性访问和更改默认的Realm路径。 其它Realm有多个Realm在多个位置持久化是有用的。例如，除了您的主Realm外，您还可能希望将一些数据与您的应用程序捆绑在Realm文件中。您可以通过在初始化Realm时指定路径参数来执行此操作。所有路径都相对于您的应用程序的可写入文档目录： 12345// Open a realm at another pathlet realmAtAnotherPath = new Realm(&#123; path: &apos;anotherRealm.realm&apos;, schema: [CarSchema]&#125;); Schema版本打开Realm时可用的另一个选项是schemaVersion属性。当省略时，schemaVersion属性默认为0.在使用包含与之前规范不同的对象的Schema初始化现有Realm时，需要指定schemaVersion。如果Schema被更新并且schemaVersion不是之前的结构，将抛出异常。 123456789101112131415161718192021222324const PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; name: &apos;string&apos; &#125;&#125;;// schemaVersion默认是0let realm = new Realm(&#123;schema: [PersonSchema]&#125;);const UpdatedPersonSchema = &#123; // 因为schema名称相同, 所以以前的“Person”对象在Realm将会更新 name: &apos;Person&apos;, properties: &#123; name: &apos;string&apos;, dog: &apos;Dog&apos; // 新属性 &#125;&#125;;// 这将抛出异常，因为schema已经改变和`schemaVersion`未指定let realm = new Realm(&#123;schema: [UpdatedPersonSchema]&#125;);// 这将成功并将Realm更新到新的schemalet realm = new Realm(&#123;schema: [UpdatedPersonSchema], schemaVersion: 1&#125;); 如果您想要检索当前的Realmschema版本，可以使用Realm.schemaVersion方法。 1let currentVersion = Realm.schemaVersion(Realm.defaultPath); 异步打开Realm如果打开Realm可能需要耗时的操作，例如应用迁移或下载同步Realm的远程内容，则应该使用openAsync API执行所有需要的工作，以使Realm在后台线程上处于可用状态调度到给定的队列。您还应该使用openAsync设置只读的Realm。 例如: 12345678910111213Realm.openAsync(&#123; schema: [PersonSchema], schemaVersion: 42, migration: function(oldRealm, newRealm) &#123; // 执行迁移（请参阅文档中的“迁移”） &#125;&#125;, (error, realm) =&gt; &#123; if (error) &#123; return; &#125; // 用openAsync返回的Realm对象做回调 console.log(realm);&#125;) openAsync命令将配置对象作为其第一个参数，回调作为第二个参数;回调函数接收布尔错误标志和已打开的Realm实例。 初始下载在某些情况下，您可能不想在所有远程数据可用之前打开领域。在这种情况下，请使用openAsync。当与同步Realm一起使用时，这将在调用回调之前下载所有的Realm内容。 1234567891011121314var carRealm;Realm.openAsync(&#123; schema: [CarSchema], sync: &#123; user: user, url: &apos;realm://object-server-url:9080/~/cars&apos; &#125;&#125;, (error, realm) =&gt; &#123; if (error) &#123; return; &#125; // Realm现已下载并可以使用 carRealm = realm;&#125;); 迁移在数据库工作时，您的数据模型将很可能随时间而变化。 例如，假设我们有以下Person模型： 12345678var PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; firstName: &apos;string&apos;, lastName: &apos;string&apos;, age: &apos;int&apos; &#125;&#125; 我们要更新数据模型，用来添加一个name属性，而不是单独的名字和姓氏。为此，我们只需将schema更改为以下内容： 1234567var PersonSchema = &#123; name: &apos;Person&apos;, properties: &#123; name: &apos;string&apos;, age: &apos;int&apos; &#125;&#125; 在这一点上，如果您使用以前的model版本保存了任何数据，新的代码和Realm已存储在磁盘上的旧数据将不匹配。发生这种情况时，当您尝试使用新的schema打开现有的Realm时，将抛出异常，除非运行迁移。 进行迁移您可以通过更新schemaVersion并定义可选的迁移函数来定义迁移和关联的schema版本。您的迁移函数提供将数据模型从以前的schema转换为新的schema所需的任何逻辑。当打开Realm时，只有在需要迁移时，才会将迁移函数应用于将Realm更新到给定的schema版本。 如果没有提供迁移函数，则当更新到新的schemaVersion时，任何新的属性将自动添加并且旧的属性从数据库中删除。如果您需要在升级版本时更新旧的或填充的新属性，那么可以在迁移函数中执行此操作。例如，假设我们要迁移先前声明的Person模型。您可以使用旧的firstName和lastName属性填充新模式的name属性： 123456789101112131415161718var realm = new Realm(&#123; schema: [PersonSchema], schemaVersion: 1, migration: function(oldRealm, newRealm) &#123; // only apply this change if upgrading to schemaVersion 1 if (oldRealm.schemaVersion &lt; 1) &#123; var oldObjects = oldRealm.objects(&apos;Person&apos;); var newObjects = newRealm.objects(&apos;Person&apos;); // loop through all objects and set the name property in the new schema for (var i = 0; i &lt; oldObjects.length; i++) &#123; newObjects[i].name = oldObjects[i].firstName + &apos; &apos; + oldObjects[i].lastName; &#125; &#125; &#125;&#125;);var fullName = realm.objects(&apos;Person&apos;)[0].name; 迁移成功完成后，您的应用程序可以像往常一样访问Realm及其所有对象。 线性迁移使用上述迁移模式，您可能会在多个版本上迁移时遇到问题。如果用户跳过应用程序更新，并且在跳过的版本中属性已被更改多次，则可能会发生这种情况。在这种情况下，您可能需要编辑旧的迁移代码才能将数据从旧schema更新到最新schema。 可以通过顺序运行多个迁移来避免此问题，确保将数据库升级到每个先前版本，并运行关联的迁移代码。当遵循这种模式时，永远不需要修改旧的迁移代码，尽管您需要保留所有旧的schema和迁移模块以备将来使用。一个这样的例子： 12345678910111213141516var schemas = [ &#123; schema: schema1, schemaVersion: 1, migration: migrationFunction1 &#125;, &#123; schema: schema2, schemaVersion: 2, migration: migrationFunction2 &#125;, ...]// 要更新的第一个schema是当前schema版本。// 因为第一个schema是在我们的数组里var nextSchemaIndex = Realm.schemaVersion(Realm.defaultPath);while (nextSchemaIndex &lt; schemas.length) &#123; var migratedRealm = new Realm(schemas[nextSchemaIndex++]); migratedRealm.close();&#125;// 用最新的schema打开Realmvar realm = new Realm(schemas[schemas.length-1]); 通知Realm的 Results和 List 对象提供了addListener方法来注册通知回调。每当更新对象时，将调用更改通知回调。 有两种通知，“Realm通知”（提交写入事务时通知的简单回调）和“Collection通知”（更复杂的回调，它们在插入，删除和更新时接收更改元数据）。 此外，专业版和企业版提供事件处理通知。阅读“Realm移动平台”了解更多信息。 Realm 通知每次提交写入事务时，领域实例都会向其他实例发送通知。注册通知： 12345678// 注册 Realm 通知realm.addListener(&apos;change&apos;, () =&gt; &#123; // Update UI ...&#125;);// 移除所有注册过的通知realm.removeAllListeners(); Collection 通知Collection通知包含描述在细粒度级别发生了哪些更改的信息。这包括自上次通知以来插入，删除或修改的对象的索引。Collection通知异步传递：首先使用初始结果，然后在任何修改Collection中的任何对象的写入事务之后，从集合中删除对象，或向集合中添加新对象。 当这些变化发生时，addListener通知回调函数会收到两个参数。第一个是更改的collection，第二个是具有关于由删除，插入和修改影响的集合索引的信息的changes对象。 前两项，删除和插入，每当对象开始和停止作为collection的一部分时，记录索引。当您将对象添加到realm或将其从realm中删除时，这将考虑在内。对于Results，当您过滤特定值并且对象已更改，以使其现在与查询匹配或不匹配时，此操作也适用。对于基于List的collection，这适用于从关系中添加或删除对象时。 当对象的属性发生更改时，您的应用程序将被通知有关修改，该属性以前是collection的一部分，并且仍然是其中的一部分。当一对多关系发生变化时，也会发生这种情况，但不考虑反向关系的变化。 12345678910111213141516class Dog &#123;&#125;Dog.schema = &#123; name: &apos;Dog&apos;, properties: &#123; name: &apos;string&apos;, age: &apos;int&apos;, &#125;&#125;;class Person &#123;&#125;Person.schema = &#123; name: &apos;Person&apos;, properties: &#123; name: &#123;type: &apos;string&apos;&#125;, dogs: &#123;type: &apos;list&apos;, objectType: &apos;Dog&apos;&#125;, &#125;&#125;; 让我们假设您正在观察上面的模型代码给出的狗主人列表。当以下情况下，您将收到关于匹配的Person对象的修改的通知： 您修改Person的name属性。 你添加或删除Dog给Person的dogs属性。 您修改属于该Person的 Dog的 age 属性。 这使得可以离散地控制对UI内的内容进行的动画和视觉更新，而不是在每次发生通知时任意重新加载所有内容。 123456789101112131415161718192021222324252627// 注册通知realm.objects(&apos;Dog&apos;).filtered(&apos;age &lt; 2&apos;).addListener((puppies, changes) =&gt; &#123; // 更新UI以响应插入的对象 changes.insertions.forEach((index) =&gt; &#123; let insertedDog = puppies[index]; ... &#125;); // 更新UI以响应修改的对象 changes.modifications.forEach((index) =&gt; &#123; let modifiedDog = puppies[index]; ... &#125;); // 更新UI以响应已删除的对象 changes.deletions.forEach((index) =&gt; &#123; // 已删除的对象无法直接访问 // 支持即将访问已删除的对象... ... &#125;); &#125;);// 取消注册所有的通知realm.removeAllListeners(); 同步Realm移动平台（RMP）通过网络扩展了Realm移动数据库，实现了跨设备的数据自动同步。为了做到这一点，提供了一组支持这些同步Realm的类型和类;这些新类别与现有的Realm Mobile数据库相加。 用户Realm对象服务器中的中心对象是与同步Realm相关联的Realm用户（Realm.Sync.User）。User可以通过用户名/密码方案或通过多种第三方身份验证方法对共享的Realm进行身份验证。 创建和登录用户需要两件事情： 要连接到的Realm对象服务器的URL。 用于认证机制的证书，该认证机制根据该机制描述用户（即，用户名/密码，访问密钥等）。 认证认证用于建立用户的身份并登录。请参阅我们的身份验证文档，了解Realm Mobile Platform支持的认证提供者列表。 可以通过以下几种方式之一创建给定用户的凭据信息： 提供有效的用户名/密码组合 提供从受支持的第三方身份验证服务获取的令牌 提供令牌和自定义验证提供程序（请参阅自定义验证） 用户名和密码认证完全由Realm对象服务器管理，可以完全控制应用程序的用户管理。 对于其他身份验证方法，您的应用程序负责登录外部服务并获取身份验证令牌。 以下是与各种提供程序设置凭据的一些示例。 用户名/密码1Realm.Sync.User.login(&apos;http://my.realm-auth-server.com:9080&apos;, &apos;username&apos;, &apos;p@s$w0rd&apos;, (error, user) =&gt; &#123; /* ... */ &#125;); 在用户登录之前，必须创建该帐户。您可以使用管理控制台在服务器上提前执行此操作，也可以通过调用register方法： 1Realm.Sync.User.register(&apos;http://my.realm-auth-server.com:9080&apos;, &apos;username&apos;, &apos;p@s$w0rd&apos;, (error, user) =&gt; &#123; /* ... */ &#125;); Google12const googleAccessToken = &apos;acc3ssT0ken...&apos;;Realm.Sync.User.registerWithProvider(&apos;http://my.realm-auth-server.com:9080&apos;, &apos;google&apos;, googleAccessToken, (error, user) =&gt; &#123; /* ... */ &#125;); Facebook12const fbAccessToken = &apos;acc3ssT0ken...&apos;;Realm.Sync.User.registerWithProvider(&apos;http://my.realm-auth-server.com:9080&apos;, &apos;facebook&apos;, fbAccessToken, (error, user) =&gt; &#123; /* ... */ &#125;); 自定义认证123456789// The user token provided by your authentication serverconst accessToken = &apos;acc3ssT0ken...&apos;;const user = Realm.Sync.User.registerWithProvider( &apos;http://my.realm-auth-server.com:9080&apos;, &apos;custom/fooauth&apos;, accessToken, (error, user) =&gt; &#123; /* ... */ &#125;); 注意：JavaScript SDK当前不允许您发送其他数据。如果您需要发送多个单个令牌，请将附加数据编码为JSON，并通过accessToken参数传递，并对服务器端的此字符串进行解码。 注销注销同步的Realm很简单： 1user.logout(); 当用户注销时，同步将停止。退出的用户将无法再打开同步的Realm。 Working with Users同步服务器URL可以包含波形符号（“〜”），它将被透明地扩展以表示用户的唯一标识符。这个方案很容易让您编写应用程序以满足其个人用户需求。磁盘上共享realm的位置由框架管理，但如果需要可以覆盖。 123456789101112131415Realm.Sync.User.login(/* ... */, (error, user) =&gt; &#123; if (!error) &#123; var realm = new Realm(&#123; sync: &#123; user: user, url: &apos;realm://object-server-url:9080/~/my-realm&apos;, &#125;, schema: [/* ... */] &#125;); realm.write(() =&gt; &#123; /* ... */ &#125;) &#125;&#125;) Realm.Sync.User.current可用于获取当前登录的用户。如果没有用户登录或全部已经注销，它将返回 undefined。如果有多个登录用户，将会抛出一个错误。 1let user = Realm.Sync.User.current; 如果可能有多个用户登录，您可以通过调用Realm.Sync.User.all获取它们的一个集合。如果没有用户登录，这将是空的。 1234567let users = Realm.Sync.User.all;for(const key in users) &#123; const user = users[key]; // do something with the user. &#125;) 打开同步Realm一旦您使用一个Realm对象服务器的URL和一个用户对象打开Realm，您可以像JavaScript中的其他Realm一样进行交互。 12345realm.write(() =&gt; &#123; realm.create(&apos;MyObject&apos;, jsonData);&#125;);var objects = realm.object(&apos;MyObject&apos;); 如果Realm具有只读权限，那么您必须按照异步打开Realm的描述使用openAsync。在没有openAsync的情况下打开只读领域会导致错误。 同步会话同步的Realm与Realm对象服务器的连接由Session对象表示。可以通过调用realm.syncSession来检索会话对象。 可以使用state属性检索基础会话的状态。这可以用于检查会话是活动的，未连接到服务器还是处于错误状态。 访问控制Realm移动平台提供灵活的访问控制机制，以限制哪些用户与哪些Realm文件同步。例如，这可以用于创建多个用户写入同一个Realm的协作应用程序。它也可以用于在发布者/订阅者场景中共享数据，其中单个写入用户与具有读取权限的许多用户共享数据。 有三个权限可以控制用户给定Realm的访问级别： mayRead 示允许用户从Realm读取。 mayWrite 表示允许用户写入Realm。 mayManage 表示允许用户更改Realm的权限。 除非明确修改权限，否则只有领域的所有者（创建者）可以访问它。唯一的例外是管理员用户：他们总是授予服务器上所有Realm的所有权限。 Write-only permissions (i.e., mayWrite set without mayRead) are not currently supported. 当前不支持只写权限（即，mayWrite没有mayRead的设置）。 请参阅访问控制的通用Realm Object Server文档，以了解有关概念的更多信息。 管理 Realm所有访问级管理操作都是通过写入管理realm来执行的。管理realm就像一个常规的同步realm，但是Realm对象服务器是专门针对默认情况而设计的。权限修改对象可以添加到realm，以将这些更改应用于Realm文件的访问控制设置。 要获取给定用户的管理realm，请调用其user.openManagementRealm()方法： 1const managementRealm = user.openManagementRealm(); 修改权限通过向管理Realm添加权限对象实例来修改Realm文件的访问控制设置。目前，支持两个工作流程： PermissionChangePermissionChange对象允许您直接控制Realm的访问控制设置。当您已经知道要向其授予权限的用户的Ids或希望向每个人授予权限时，这是非常有用的。 123456789managementRealm.write(() =&gt; &#123; managementRealm.create(&apos;PermissionChange&apos;, &#123; id: generateUniqueId(), // 实现创建唯一ID的内容。 createdAt: new Date(), updatedAt: new Date(), userId: &apos;...&apos;, realmUrl: &apos;...&apos;, &#125;);&#125;); 要应用用户管理的所有Realm的权限更改，请指定一个realmURL值*。 要对使用对象服务器授权的所有用户应用权限更改，请指定userId值*。 如果您不提供mayRead，mayWrite或mayManage的值，或者提供null，read，write或manage权限将保持不变。这可能是有用的，例如，如果您要授予用户读取权限，但不想从已拥有该权限的用户取走写入权限： 123456789101112managementRealm.write(() =&gt; &#123; for(const userId in users) &#123; managementRealm.create(&apos;PermissionChange&apos;, &#123; id: generateUniqueId(), createdAt: new Date(), updatedAt: new Date(), userId: userId, realmUrl: realmUrl, mayRead: true &#125;); &#125;);&#125;); 这样，列表中的所有用户将被授予读取权限，但是具有 write 和 manage 访问权限的用户将不会丢失它。 PermissionOffer/PermissionResponsePermissionOffer和PermissionOfferResponse对类允许您设计共享方案，其中，邀请者生成令牌，然后可以由一个或多个用户使用令牌： 1234567891011121314151617181920managementRealm.write(() =&gt; &#123; let expirationDate = new Date(); expirationDate.setDate(expirationDate.getDate() + 7); // 一周内过期 managementRealm.create(&apos;PermissionOffer&apos;, &#123; id: generateUniqueId(), createdAt: new Date(), updatedAt: new Date(), userId: userId, realmUrl: realmUrl, mayRead: true, mayWrite: true, mayManage: false, expiresAt: expirationDate &#125;);&#125;);/* 等待报价处理 */var token = permissionOffer.token;/* 将令牌发送给其他用户 */ 与PermissionChange类似，在提供的realmUrl中有一些参数控制Realm的读取，写入和管理访问。您可以提供的另外一个参数是expiresAt，它控制令牌何时不再是可消耗的。如果您不传递值或通过null，则该报价永远不会过期。请注意，使用该优惠的用户在过期后不会失去访问权限。 一旦用户获得了令牌，他们就可以使用它： 12345678910111213141516171819202122232425const managementRealm = anotherUser.openManagementRealm();let offerResponse;managementRealm.write(() =&gt;&#123; offerResponse = managementRealm.create(&apos;PermissionOfferResponse&apos;, &#123; id: generateUniqueId(), createdAt: new Date(), token: token &#125;);&#125;);/* Wait for the offer to be processed */const realmUrl = offerResponse.realmUrl;// Now we can open the shared realm:var realm = new Realm(&#123; sync: &#123; user: anotherUser, url: realmUrl, &#125;, schema: [/* ... */]&#125;); 请注意，通过使用PermissionOffer授予的权限是相加的，即如果用户已经具有write权限并且接受授予read权限的PermissionOffer，则它们不会丢失其write权限。 PermissionOffers可以通过从管理域中删除或将过期设置为expiresAt日期来撤销。这将阻止新用户接受该优惠，但不会在之前消费的用户撤销任何权限。 一旦对象服务器处理了在权限对象中编码的操作，它将设置该对象的statusCode和statusMessage属性。 React Native ListView如果要使用List或Results实例作为ListView的数据，强烈建议您使用由 realm/react-native 模块提供的ListView和ListView.DataSource： 1import &#123; ListView &#125; from &apos;realm/react-native&apos;; API与React.ListView完全相同，因此您可以参考ListView文档获取使用信息。 加密请注意我们的许可证的出口合规部分，因为如果您位于美国出口限制或禁运的国家/地区，则会对其使用限制。 Realm支持使用AES-256+SHA2通过在创建Realm时提供64字节的加密密钥来加密磁盘上的数据库文件。 12345var key = new Int8Array(64); // pupulate with a secure keyvar realm = new Realm(&#123;schema: [CarObject], encryptionKey: key&#125;);// Use the Realm as normalvar dogs = realm.objects(&apos;Car&apos;); 这使得所有存储在磁盘上的数据都可以根据需要使用AES-256进行透明加密和解密，并通过SHA-2 HMAC进行验证。必须在每次获得Realm实例时提供相同的加密密钥。 使用加密的Realms时，性能下降很小（通常低于10％）。 故障排除Missing Realm Constructor如果您的应用程序崩溃，告诉您Realm构造函数未找到，您可以尝试几件事情： 首先，运行 react-native link realm 如果没有帮助，并且您的问题在Android上，请尝试: 在MainApplication.java文件中添加以下内容：java import io.realm.react.RealmReactPackage; 并将RealmReactPackage添加到软件包列表中： 123456protected List getPackages() &#123; return Arrays.asList( new MainReactPackage(), new RealmReactPackage() // add this line );&#125; 在settings.gradle中添加以下两行： 12include &apos;:realm&apos;project(&apos;:realm&apos;).projectDir = new File(settingsDir, &apos;../node_modules/realm/android&apos;) 如果您的问题在iOS上，请尝试：1.关闭所有模拟器/设备构建2.停止在终端中运行的软件包管理器（或更好的是，只需重新启动终端）3.在finder 4中打开应用程序根目录中的ios文件夹。Go进入构建文件夹（注意：你不会看到这个构建文件夹在原子，所以只需右键单击ios并单击打开查找器）5.删除构建文件夹内的所有内容（只是移动到垃圾桶，并保持垃圾，以防万一’担心）6.运行反应本机运行以重建整个事情 崩溃报告我们建议您在应用程序中使用崩溃记录。许多Realm的操作可能会在运行时失败（像任何其他磁盘IO），因此从应用程序收集崩溃报告将有助于识别您（或我们）可以改进错误处理和修复崩溃错误的区域。 大多数商业崩溃记录者可以选择收集日志。我们强烈建议您启用此功能。Realm在抛出异常和不可恢复的情况下记录元数据信息（但不包含用户数据），并且这些消息可以帮助在出现问题时进行调试。 提交Realm问题如果您发现了Realm的问题，请在GitHub上提出问题，或者发送电子邮件至help@realm.io，尽可能多地了解和重现您的问题。 以下信息对我们非常有用： Bug名称. 预期结果. 实际结果. 重现步骤. 强调问题的代码示例（我们可以自己编译的全部工作项目是比较理想的）. Realm版本. 崩溃日志 &amp; 堆栈信息.有关详细信息，请参阅上述崩溃报告.]]></content>
      <categories>
        <category>database</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[在路上]]></title>
    <url>%2F2017%2F07%2F19%2Fon-road%2F</url>
    <content type="text"><![CDATA[前记：夜归上海，一丝迷茫。 当有一天，我不复永忘 请不要将我遗忘 因为我在路上 当有一天，我内心绝望 请给我一缕阳光 因为我在路上 当有一天，我无奈返乡 请给我一点赞扬 因为我在路上 可能有那么一天，我提笔成章 请给我一丝墨香 因为你的理解，让我天涯勇闯 或许有那么一天，我把生命的歌逆风而唱 请你要迎风守望 因为你的目光，让我安心远航 在路上，我的希望 在路上，你的期望]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Create React App 脚手架的使用说明]]></title>
    <url>%2F2017%2F06%2F19%2Fcreate-react-app%2F</url>
    <content type="text"><![CDATA[This project was bootstrapped with Create React App. 这个项目是由Create React App工具引导创建。 Below you will find some information on how to perform common tasks. 下面你会找到一些有关如何执行常见任务的信息。 You can find the most recent version of this guide here. 您可以在这里找到本指南的最新版本。 Table of Contents(目录) Updating to New Releases 更新到新版本 Sending Feedback 发送反馈 Folder Structure 文件夹结构 Available Scripts 可用脚本 npm start npm test npm run build npm run eject Supported Language Features and Polyfills 支持的语言功能和Polyfills (Polyfills是Remy Sharp提出的一个术语，用来补充因缺乏对新API支持而缺失的功能) Syntax Highlighting in the Editor 编辑器中的语法突出显示 Displaying Lint Output in the Editor 在编辑器中显示Lint输出 Debugging in the Editor 在编辑器中调试 Changing the Page &lt;title&gt; 更改页面&lt;title&gt; Installing a Dependency 安装依赖 Importing a Component 导入组件 Code Splitting 代码拆分 Adding a Stylesheet 添加样式表 Post-Processing CSS CSS后期处理 Adding a CSS Preprocessor (Sass, Less etc.) 添加CSS预处理器（Sass，Less等） Adding Images, Fonts, and Files 添加图像，字体和文件 Using the public Folder 使用public文件夹 Changing the HTML 更改HTML Adding Assets Outside of the Module System 在模块系统之外添加资源 When to Use the public Folder 何时使用public文件夹 Using Global Variables 使用全局变量 Adding Bootstrap 添加Bootstrap库 Using a Custom Theme 使用自定义主题 Adding Flow 添加流 Adding Custom Environment Variables 添加自定义环境变量 Referencing Environment Variables in the HTML 引用HTML中的环境变量 Adding Temporary Environment Variables In Your Shell 在Shell中添加临时环境变量 Adding Development Environment Variables In .env 在.env中添加开发环境变量 Can I Use Decorators? 我可以使用装饰器吗？ Integrating with an API Backend 与后端API集成 Node Ruby on Rails Proxying API Requests in Development 在开发中代理API请求 “Invalid Host Header” Errors After Configuring Proxy 配置代理后的“主机头无效”错误 Configuring the Proxy Manually 手动配置代理 Using HTTPS in Development 在开发中使用HTTPS Generating Dynamic &lt;meta&gt; Tags on the Server 在服务器上生成动态&lt;meta&gt;标签 Pre-Rendering into Static HTML Files 预渲染成静态HTML文件 Injecting Data from the Server into the Page 将数据从服务器注入页面 Running Tests 运行测试 Filename Conventions 文件名约定 Command Line Interface 命令行界面 Version Control Integration 版本控制集成 Writing Tests 写测试 Testing Components 测试组件 Using Third Party Assertion Libraries 使用第三方断言库 Initializing Test Environment 初始化测试环境 Focusing and Excluding Tests 聚焦和排除测试 Coverage Reporting 覆盖报告 Continuous Integration 持续整合 Disabling jsdom 禁用jsdom Snapshot Testing 快照测试 Editor Integration 编辑器集成 Making a Progressive Web App 制作一个渐进的Web应用程序 Offline-First Considerations 离线优先注意事项 Progressive Web App Metadata 不断改进的Web应用程序元数据 Deployment 部署 Static Server 静态服务器 Other Solutions 其他解决方案 Serving Apps with Client-Side Routing 使用客户端路由的服务应用程序 Building for Relative Paths 相对路径建设 Azure Firebase GitHub Pages Heroku Modulus Netlify Now S3 and CloudFront Surge Advanced Configuration 高级配置 Troubleshooting 故障排除 npm start doesn’t detect changes npm start不能检测到更改 npm test hangs on macOS Sierra npm test挂在macOS Sierra上 npm run build silently fails npm run build默认失败 npm run build fails on Heroku npm run build在Heroku上失败 Moment.js locales are missing Moment.js语言环境丢失 Something Missing? 还缺少什么？ Updating to New Releases更新到新版本Create React App is divided into two packages: 创建React应用程序分为两个包： create-react-app is a global command-line utility that you use to create new projects. create-react-app 是用于创建新项目的全局命令行实用工具. react-scripts is a development dependency in the generated projects (including this one). react-scripts 是用于生成项目的开发依赖（包括这个项目）. You almost never need to update create-react-app itself: it delegates all the setup to react-scripts. 您几乎不需要更新 create-react-app 本身：它将所有设置委托给 react-scripts. When you run create-react-app, it always creates the project with the latest version of react-scripts so you’ll get all the new features and improvements in newly created apps automatically. 当您运行create-react-app时，它始终使用最新版本的react-scripts创建项目，以便您自动获得新创建的应用程序的所有新功能和改进。 To update an existing project to a new version of react-scripts, open the changelog, find the version you’re currently on (check package.json in this folder if you’re not sure), and apply the migration instructions for the newer versions. 要将现有项目更新为新版本的react-scripts，请打开更改日志，找到当前版本（如果您不确定，请检查此文件夹中的 package.json ），然后应用更新的迁移说明版本。 In most cases bumping the react-scripts version in package.json and running npm install in this folder should be enough, but it’s good to consult the changelog for potential breaking changes. 在大多数情况下，在package.json中更改react-scripts版本并在此文件夹中运行npm install应该是可以顺利更新的，但是对于潜在的突破性更改，请参考更改日志。 We commit to keeping the breaking changes minimal so you can upgrade react-scripts painlessly. 我们致力于保持最小化的变化，从而可以无痛地升级react-scripts。 Sending Feedback发送反馈We are always open to your feedback. 我们总是对您的反馈开放。 Folder Structure文件夹结构After creation, your project should look like this: 创建后，您的项目结构应如下所示： 1234567891011121314my-app/ README.md node_modules/ package.json public/ index.html favicon.ico src/ App.css App.js App.test.js index.css index.js logo.svg For the project to build, these files must exist with exact filenames: 对于要构建的项目，这些文件必须存在精确的文件名： public/index.html is the page template; public/index.html 是页面模板; src/index.js is the JavaScript entry point. src/index.js 是JavaScript入口点. You can delete or rename the other files. 您可以删除或重命名其他文件。 You may create subdirectories inside src. For faster rebuilds, only files inside src are processed by Webpack.You need to put any JS and CSS files inside src, or Webpack won’t see them. 您可以在src内创建子目录。对于更快的重建，只有src中的文件才能被Webpack处理.您需要将任何JS和CSS文件放在src中，否则Webpack将不会发现它们。 Only files inside public can be used from public/index.html.Read instructions below for using assets from JavaScript and HTML. public/index.html中只能使用public内的文件.阅读使用JavaScript和HTML资源的说明. You can, however, create more top-level directories.They will not be included in the production build so you can use them for things like documentation. 但是，您可以创建更多的顶级目录.它们不会被包含在生产构建中，因此您可以将它们用于文档等内容. Available Scripts可用脚本In the project directory, you can run: 在项目目录中，您可以运行： npm startRuns the app in the development mode.Open http://localhost:3000 to view it in the browser. 在开发模式下运行应用程序.打开 http://localhost:3000在浏览器中查看。 The page will reload if you make edits.You will also see any lint errors in the console. 如果进行修改，页面将重新加载.您还将在控制台中看到任何lint错误。 npm testLaunches the test runner in the interactive watch mode.See the section about running tests for more information. 以交互观察模式启动test runner.有关更多信息，请参阅有关 running tests 的部分。 npm run buildBuilds the app for production to the build folder.It correctly bundles React in production mode and optimizes the build for the best performance. 构建生产应用程序到 build 文件夹. 它在生产模式下正确地捆绑了React，并优化了构建以获得最佳性能。 The build is minified and the filenames include the hashes.Your app is ready to be deployed! 构建已经被细化，文件名包括散列. 您的应用程序已准备好部署了！ See the section about deployment for more information. 有关详细信息，请参阅有关部署的部分。 npm run ejectNote: this is a one-way operation. Once you eject, you can’t go back! 注意：这是一个单向操作。一旦你弹出，你不能返回！ If you aren’t satisfied with the build tool and configuration choices, you can eject at any time. This command will remove the single build dependency from your project. 如果您对构建工具和配置选项不满意，您可以随时弹出。此命令将从项目中删除单个构建依赖关系。 Instead, it will copy all the configuration files and the transitive dependencies (Webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except eject will still work, but they will point to the copied scripts so you can tweak them. At this point you’re on your own. 相反，它会将所有配置文件和传递依赖项（Webpack，Babel，ESLint等）直接复制到您的项目中，以便您可以完全控制它们。除弹出之外的所有命令仍将起作用，但它们将指向复制的脚本，以便您可以调整它们。在这一点上，你是你自己的。 You don’t have to ever use eject. The curated feature set is suitable for small and middle deployments, and you shouldn’t feel obligated to use this feature. However we understand that this tool wouldn’t be useful if you couldn’t customize it when you are ready for it. 你不必使用弹出。策划的功能集适用于中小型部署，您不应该有义务使用此功能。但是，我们明白，如果您无法自定义此工具，则此工具将无用。 Supported Language Features and Polyfills支持的语言功能和PolyfillsPolyfills是Remy Sharp提出的一个术语，用来补充因缺乏对新API支持而缺失的功能 This project supports a superset of the latest JavaScript standard.In addition to ES6 syntax features, it also supports: 该项目支持最新JavaScript标准的超集. 除了ES6语法功能之外，它还支持： Exponentiation Operator (ES2016).【指数运算符】 Async/await (ES2017).【异步&amp;等待关键词】 Object Rest/Spread Properties (stage 3 proposal).【对象休眠/扩展属性（第3阶段提案）】 Dynamic import() (stage 3 proposal)【动态导入（第3阶段提案）】 Class Fields and Static Properties (stage 2 proposal).【类字段和静态属性（第3阶段提案）】 JSX and Flow syntax.【JSX和Flow语法】 Learn more about different proposal stages. 了解有关不同阶段的更多信息。 While we recommend to use experimental proposals with some caution, Facebook heavily uses these features in the product code, so we intend to provide codemods if any of these proposals change in the future. 虽然我们建议您谨慎使用实验性建议书，但Facebook在产品代码中大量使用这些功能，因此，如果将来有任何这些提案发生变化，我们打算提供代码。 Note that the project only includes a few ES6 polyfills: 请注意，该项目仅包括几个ES6 polyfills： Object.assign() via object-assign. Promise via promise. fetch() via whatwg-fetch. If you use any other ES6+ features that need runtime support (such as Array.from() or Symbol), make sure you are including the appropriate polyfills manually, or that the browsers you are targeting already support them. 如果您使用任何需要运行时支持的其他ES6功能(例如 Array.from() or Symbol)，请确保您手动包含相应的polyfills，或者您定位的浏览器已经支持它们。 Syntax Highlighting in the Editor编辑器中的语法突出显示To configure the syntax highlighting in your favorite text editor, head to the relevant Babel documentation page and follow the instructions. Some of the most popular editors are covered. 要在您喜欢的文本编辑器中配置语法高亮，请转到相关的Babel文档页面，然后按照说明进行操作。一些最流行的编辑被覆盖。 Displaying Lint Output in the Editor在编辑器中显示Lint输出 Note: this feature is available with `react-scripts@0.2.0` and higher.It also only works with npm 3 or higher. 注意：此功能可用在react-scripts@0.2.0及更高版本. 它也只适用于npm 3或更高版本。 Some editors, including Sublime Text, Atom, and Visual Studio Code, provide plugins for ESLint. 一些编辑器，包括Sublime Text，Atom和Visual Studio Code，可以为其提供ESLint插件。 They are not required for linting. You should see the linter output right in your terminal as well as the browser console. However, if you prefer the lint results to appear right in your editor, there are some extra steps you can do. 它们不需要进行Linting。您应该在终端以及浏览器控制台中看到信息输出。但是，如果您喜欢在编辑器中显示lint结果，则可以执行一些额外的步骤。 You would need to install an ESLint plugin for your editor first. Then, add a file called .eslintrc to the project root: 您需要先为编辑器安装ESLint插件。然后，将一个名为.eslintrc的文件添加到项目根目录中： 123&#123; "extends": "react-app"&#125; Now your editor should report the linting warnings. 现在你的编辑器应该报告出那些检索出的警告。 Note that even if you edit your .eslintrc file further, these changes will only affect the editor integration. They won’t affect the terminal and in-browser lint output. This is because Create React App intentionally provides a minimal set of rules that find common mistakes. 请注意，即使您进一步编辑.eslintrc文件，这些更改只会影响编辑器的集成。它们不会影响终端和浏览器中的lint输出。这是因为Create React App 有意提供了一组最常见的错误的规则。 If you want to enforce a coding style for your project, consider using Prettier instead of ESLint style rules. 如果要为项目强制执行编码风格，请考虑使用Prettier而不是ESLint样式规则。 Debugging in the Editor在编辑器中调试This feature is currently only supported by Visual Studio Code editor. 此功能目前仅支持 Visual Studio Code 编辑器。 Visual Studio Code supports debugging out of the box with Create React App. This enables you as a developer to write and debug your React code without leaving the editor, and most importantly it enables you to have a continuous development workflow, where context switching is minimal, as you don’t have to switch between tools. Visual StudioCode支持使用Create React App进行开箱调试。这使您可以作为开发人员编写和调试您的React代码，而不必离开编辑器，最重要的是它可以让您拥有持续的开发工作流程，其中编辑器环境切换是最小的，因为您不必在工具之间进行切换。 You would need to have the latest version of VS Code and VS Code Chrome Debugger Extension installed. 您需要安装VS Code和VS Code Chrome调试器扩展的最新版本。 Then add the block below to your launch.json file and put it inside the .vscode folder in your app’s root directory. 然后将下面的代码块添加到您的launch.json文件中，并将其放在应用程序根目录中的.vscode文件夹中。 1234567891011121314&#123; "version": "0.2.0", "configurations": [&#123; "name": "Chrome", "type": "chrome", "request": "launch", "url": "http://localhost:3000", "webRoot": "$&#123;workspaceRoot&#125;/src", "userDataDir": "$&#123;workspaceRoot&#125;/.vscode/chrome", "sourceMapPathOverrides": &#123; "webpack:///src/*": "$&#123;webRoot&#125;/*" &#125; &#125;]&#125; Start your app by running npm start, and start debugging in VS Code by pressing F5 or by clicking the green debug icon. You can now write code, set breakpoints, make changes to the code, and debug your newly modified code—all from your editor. 通过运行 npm start 启动您的应用程序，并通过按F5或单击绿色调试图标在VS代码中开始调试。您现在可以编辑代码，设置断点，更改代码，并从编辑器调试新修改的代码。 Changing the Page &lt;title&gt;更改页面&lt;title&gt;You can find the source HTML file in the public folder of the generated project. You may edit the &lt;title&gt; tag in it to change the title from “React App” to anything else. 您可以在生成的项目的 public 文件夹中找到源HTML文件。您可以编辑其中的&lt;title&gt;标签，将标题从“React App”更改为其他任何内容。 Note that normally you wouldn’t edit files in the public folder very often. For example, adding a stylesheet is done without touching the HTML. 请注意，通常您不会经常在 public 文件夹中编辑文件。例如，通过添加样式表完成，而不修改HTML文件。 If you need to dynamically update the page title based on the content, you can use the browser document.title API. For more complex scenarios when you want to change the title from React components, you can use React Helmet, a third party library. 如果您需要根据内容动态更新页面标题，可以使用浏览器的document.title API。对于要从React组件更改标题的更复杂的场景，可以使用React Helmet(一个第三方库)。 If you use a custom server for your app in production and want to modify the title before it gets sent to the browser, you can follow advice in this section. Alternatively, you can pre-build each page as a static HTML file which then loads the JavaScript bundle, which is covered here. 如果您在生产中为自己的应用程序使用自定义服务器，并且要在将标题发送到浏览器之前修改标题，则可以在本节中遵循建议。或者，您可以将每个页面预先构建为一个静态HTML文件，然后加载JavaScript包，此处将在此介绍。 Installing a Dependency安装依赖关系The generated project includes React and ReactDOM as dependencies. It also includes a set of scripts used by Create React App as a development dependency. You may install other dependencies (for example, React Router) with npm: 生成的项目包含React和ReactDOM作为依赖关系。它还包括Create React App用作开发依赖关系的一组脚本。您可以使用npm安装其他依赖项（例如React Router） 1npm install --save &lt;library-name&gt; Importing a Component导入组件This project setup supports ES6 modules thanks to Babel. 感谢Babel开源模块，因为这个项目设置支持ES6模块. While you can still use require() and module.exports, we encourage you to use import and export instead. 虽然您仍然可以使用 require() 和 module.exports, 但我们建议您改用导入和导出。 For example: 例如: Button.js1234567891011import React, &#123; Component &#125; from 'react';class Button extends Component &#123; render() &#123; // ... &#125;&#125;// Don’t forget to use export default!// 不要忘记使用export default!export default Button; DangerButton.js12345678910111213import React, &#123; Component &#125; from 'react';// Import a component from another file// 从另一个文件导入组件import Button from './Button'; class DangerButton extends Component &#123; render() &#123; return &lt;Button color="red" /&gt;; &#125;&#125;export default DangerButton; Be aware of the difference between default and named exports. It is a common source of mistakes. 请注意默认和命名导出之间的区别。这是错误的常见来源。 We suggest that you stick to using default imports and exports when a module only exports a single thing (for example, a component). That’s what you get when you use export default Button and import Button from &#39;./Button&#39;. 我们建议您在模块仅导出单个对象(例如，组件)时坚持使用默认导入和导出。这就是你使用时所得到的 export default Button 和 import Button from &#39;./Button&#39;. Named exports are useful for utility modules that export several functions. A module may have at most one default export and as many named exports as you like. 命名导出对导出多个功能的实用程序模块很有用。一个模块最多可能有一个默认的导出，并且有许多命名的导出。 Learn more about ES6 modules: 了解有关ES6模块的更多信息 When to use the curly braces? 何时使用花括号？ Exploring ES6: Modules 探索ES6：模块 Understanding ES6: Modules 了解ES6：模块 Code Splitting代码拆分Instead of downloading the entire app before users can use it, code splitting allows you to split your code into small chunks which you can then load on demand. 用户可以使用代码分割，而不是下载整个应用程序，您可以将代码拆分成小块，然后可以按需加载。 This project setup supports code splitting via dynamic import(). Its proposal is in stage 3. The import() function-like form takes the module name as an argument and returns a Promise which always resolves to the namespace object of the module. 此项目设置支持通过 dynamic import()进行代码分割。它的提议处于阶段3。 import() 函数式表单将模块名称作为参数，并返回一个 Promise ，它始终解析为模块的命名空间对象。 Here is an example: 这是一个例子： moduleA.js123const moduleA = 'Hello';export &#123; moduleA &#125;; App.js1234567891011121314151617181920212223import React, &#123; Component &#125; from 'react';class App extends Component &#123; handleClick = () =&gt; &#123; import('./moduleA') .then((&#123; moduleA &#125;) =&gt; &#123; // Use moduleA &#125;) .catch(err =&gt; &#123; // Handle failure &#125;); &#125;; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;Load&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default App; This will make moduleA.js and all its unique dependencies as a separate chunk that only loads after the user clicks the ‘Load’ button. 这将使moduleA.js及其所有唯一的依赖关系作为单独的块，仅在用户单击“加载”按钮后加载。 You can also use it with async / await syntax if you prefer it. 如果您愿意，也可以使用 async / await 语法。 Adding a Stylesheet添加样式表This project setup uses Webpack for handling all assets. Webpack offers a custom way of “extending” the concept of import beyond JavaScript. To express that a JavaScript file depends on a CSS file, you need to import the CSS from the JavaScript file: 此项目设置使用 Webpack 处理所有资源。 Webpack提供了一种“定制”的方式，将 import 概念扩展到JavaScript之外。要表示一个JavaScript文件依赖于一个CSS文件，您需要从JavaScript文件导入CSS： Button.css123.Button &#123; padding: 20px;&#125; Button.js123456789101112import React, &#123; Component &#125; from 'react';// Tell Webpack that Button.js uses these styles// 告诉Webpack，Button.js使用这些样式import './Button.css'; class Button extends Component &#123; render() &#123; // You can use them as regular CSS styles // 您可以将它们用作常规CSS样式 return &lt;div className="Button" /&gt;; &#125;&#125; This is not required for React but many people find this feature convenient. You can read about the benefits of this approach here. However you should be aware that this makes your code less portable to other build tools and environments than Webpack. 对于React这不是必需的，但很多人发现这个功能很方便。您可以在这里阅读这种方法的好处。但是，您应该意识到，相比Webpack，这使得您的代码不便于其他构建工具和环境。 In development, expressing dependencies this way allows your styles to be reloaded on the fly as you edit them. In production, all CSS files will be concatenated into a single minified .css file in the build output. 在开发中，通过这种方式表达依赖关系，可以在编辑它们时快速重新加载样式。在生产中，所有的CSS文件将被连接到构建输出中的一个最小化的.css文件中。 If you are concerned about using Webpack-specific semantics, you can put all your CSS right into src/index.css. It would still be imported from src/index.js, but you could always remove that import if you later migrate to a different build tool. 如果您关心使用特定于Webpack的语义，可以将所有CSS正确放入src/index.css。它仍将从src/index.js导入，但如果以后迁移到其他构建工具，则可以随时删除该导入。 Post-Processing CSSCSS后期处理This project setup minifies your CSS and adds vendor prefixes to it automatically through Autoprefixer so you don’t need to worry about it. 这个项目设置可以减少你的CSS，并通过 Autoprefixer 自动添加浏览器供应商的前缀，所以你不需要担心。 For example, this: 例如： 12345.App &#123; display: flex; flex-direction: row; align-items: center;&#125; becomes this: 成为这样 123456789101112.App &#123; display: -webkit-box; display: -ms-flexbox; display: flex; -webkit-box-orient: horizontal; -webkit-box-direction: normal; -ms-flex-direction: row; flex-direction: row; -webkit-box-align: center; -ms-flex-align: center; align-items: center;&#125; If you need to disable autoprefixing for some reason, follow this section. 如果由于某些原因需要禁用autoprefixing，请参照这一节。 Adding a CSS Preprocessor (Sass, Less etc.)添加CSS预处理器(Sass,Less等)Generally, we recommend that you don’t reuse the same CSS classes across different components. For example, instead of using a .Button CSS class in &lt;AcceptButton&gt; and &lt;RejectButton&gt; components, we recommend creating a &lt;Button&gt; component with its own .Button styles, that both &lt;AcceptButton&gt; and &lt;RejectButton&gt; can render (but not inherit). 通常，我们建议您不要在不同的组件之间重复使用相同的CSS类。例如，不要在&lt;AcceptButton&gt;和&lt;RejectButton&gt;组件中使用.Button CSS类，我们建议使用自己的.Button样式创建一个&lt;Button&gt;组件，&lt;AcceptButton&gt;和&lt;RejectButton&gt;可以呈现（但不能继承）。 Following this rule often makes CSS preprocessors less useful, as features like mixins and nesting are replaced by component composition. You can, however, integrate a CSS preprocessor if you find it valuable. In this walkthrough, we will be using Sass, but you can also use Less, or another alternative. 遵循这条规则往往使CSS预处理器不太有用，因为诸如混合和嵌套之类的功能被组件的组合所替代。但是，如果您发现它有价值，您可以集成CSS预处理器。在本演练中，我们将使用Sass，但您也可以使用Less或另一种选择。 First, let’s install the command-line interface for Sass: 首先，我们通过命令行界面来安装Sass： 1npm install node-sass-chokidar --save-dev Then in package.json, add the following lines to scripts: 然后在package.json中，将以下行添加到脚本中： 123456 "scripts": &#123;+ "build-css": "node-sass-chokidar src/ -o src/",+ "watch-css": "npm run build-css &amp;&amp; node-sass-chokidar src/ -o src/ --watch --recursive", "start": "react-scripts start", "build": "react-scripts build", "test": "react-scripts test --env=jsdom", Note: To use a different preprocessor, replace build-css and watch-css commands according to your preprocessor’s documentation. 注意：要使用不同的预处理器，请根据预处理器的文档替换build-css和watch-css命令。 Now you can rename src/App.css to src/App.scss and run npm run watch-css. The watcher will find every Sass file in src subdirectories, and create a corresponding CSS file next to it, in our case overwriting src/App.css. Since src/App.js still imports src/App.css, the styles become a part of your application. You can now edit src/App.scss, and src/App.css will be regenerated. 现在，您可以将 src/App.css 重命名为 src/App.scss 并运行 npm run watch-css。观察器将在src子目录中找到每个Sass文件，并在其旁边创建一个相应的CSS文件，在我们的例子中覆盖src/App.css。由于src/App.js 仍然导入 src/App.css，样式将成为您的应用程序的一部分。您现在可以编辑 src/App.scss,，并重新生成src/App.css 。 To share variables between Sass files, you can use Sass imports. For example, src/App.scss and other component style files could include @import &quot;./shared.scss&quot;; with variable definitions. 要在Sass文件之间共享变量，可以使用Sass导入。例如， src/App.scss 和其他组件样式文件可以包括使用变量定义的@import &quot;./shared.scss&quot;。 To enable importing files without using relative paths, you can add the --include-path option to the command in package.json. 要在不使用相对路径的情况下导入文件，可以在package.json中的命令块中添加--include-path选项。 12&quot;build-css&quot;: &quot;node-sass-chokidar --include-path ./src --include-path ./node_modules src/ -o src/&quot;,&quot;watch-css&quot;: &quot;npm run build-css &amp;&amp; node-sass-chokidar --include-path ./src --include-path ./node_modules src/ -o src/ --watch --recursive&quot;, This will allow you to do imports like 这样将会允许你可以像这样导入 1234567// assuming a styles directory under src/// 假设在src/下的一个样式目录中@import 'styles/_colors.scss'; // importing a css file from the nprogress node module// 从nprogress节点模块导入一个css文件@import 'nprogress/nprogress'; At this point you might want to remove all CSS files from the source control, and add src/**/*.css to your .gitignore file. It is generally a good practice to keep the build products outside of the source control. 此时，您可能需要从源代码控件中删除所有的CSS文件，并将 src/**/*.css 添加到.gitignore 文件中。将构建产品保留在源代码控制之外是一个很好的做法。 As a final step, you may find it convenient to run watch-css automatically with npm start, and run build-css as a part of npm run build. You can use the &amp;&amp; operator to execute two scripts sequentially. However, there is no cross-platform way to run two scripts in parallel, so we will install a package for this: 作为最后一步，您可能会发现使用 npm start自动运行 watch-css 是方便的，并运行build-css作为 npm run build的一部分。 1npm install --save-dev npm-run-all Then we can change start and build scripts to include the CSS preprocessor commands: 然后我们可以更改 start 和 build 脚本用来包含CSS预处理器命令： 1234567891011 "scripts": &#123; "build-css": "node-sass-chokidar src/ -o src/", "watch-css": "npm run build-css &amp;&amp; node-sass-chokidar src/ -o src/ --watch --recursive",- "start": "react-scripts start",- "build": "react-scripts build",+ "start-js": "react-scripts start",+ "start": "npm-run-all -p watch-css start-js",+ "build": "npm run build-css &amp;&amp; react-scripts build", "test": "react-scripts test --env=jsdom", "eject": "react-scripts eject" &#125; Now running npm start and npm run build also builds Sass files. 现在运行npm start和npm run build还构建了Sass文件。 Why node-sass-chokidar? 为什么使用 node-sass-chokidar? node-sass has been reported as having the following issues: node-sass 据说存在以下问题： node-sass --watch has been reported to have performance issues in certain conditions when used in a virtual machine or with docker. node-sass --watch 据说，在虚拟机或docker容器中使用时，在某些情况下会出现性能问题。 Infinite styles compiling #1939 无限风格编译 node-sass has been reported as having issues with detecting new files in a directory #1891 node-sass 已被报告为检测目录中的新文件有问题 #1891 node-sass-chokidar is used here as it addresses these issues. node-sass-chokidar 在这里用于解决这些问题。 Adding Images, Fonts, and Files添加图像，字体和文件With Webpack, using static assets like images and fonts works similarly to CSS. 使用Webpack，使用像图像和字体的静态资源与CSS类似。 You can import a file right in a JavaScript module. This tells Webpack to include that file in the bundle. Unlike CSS imports, importing a file gives you a string value. This value is the final path you can reference in your code, e.g. as the src attribute of an image or the href of a link to a PDF. 您可以直接在JavaScript模块中导入文件。这告诉Webpack将该文件包括在包中。不像CSS导入，导入一个文件会给你一个字符串值。此值是您可以在代码中引用的最终路径，例如作为图像的 src 属性或链接到PDF的href。 To reduce the number of requests to the server, importing images that are less than 10,000 bytes returns a data URI instead of a path. This applies to the following file extensions: bmp, gif, jpg, jpeg, and png. SVG files are excluded due to #1153. 为了减少对服务器的请求数量，导入少于10000个字节的图像可以返回数据URI 而不是路径。这适用于以下文件扩展名：bmp，gif，jpg，jpeg和png。由于#1153导致SVG文件被排除在外 Here is an example: 123456789101112131415import React from 'react';// Tell Webpack this JS file uses this image// 告诉Webpack这个JS文件使用这个图像import logo from './logo.png'; console.log(logo); // /logo.84287d09.pngfunction Header() &#123; // Import result is the URL of your image // 导入结果是您图像的URL return &lt;img src=&#123;logo&#125; alt="Logo" /&gt;;&#125;export default Header; This ensures that when the project is built, Webpack will correctly move the images into the build folder, and provide us with correct paths. 这样可以确保项目建成后，Webpack将正确地将图像移动到构建文件夹中，并为我们提供正确的路径。 This works in CSS too: 这也适用于CSS： 123.Logo &#123; background-image: url(./logo.png);&#125; Webpack finds all relative module references in CSS (they start with ./) and replaces them with the final paths from the compiled bundle. If you make a typo or accidentally delete an important file, you will see a compilation error, just like when you import a non-existent JavaScript module. The final filenames in the compiled bundle are generated by Webpack from content hashes. If the file content changes in the future, Webpack will give it a different name in production so you don’t need to worry about long-term caching of assets. Webpack查找CSS中的所有相关模块引用（它们以./开头），并从编译的捆绑包中替换最终路径。如果您输入错误或意外删除重要文件，则会出现编译错误，就像导入不存在的JavaScript模块时一样。编译包中的最终文件名由Webpack利用内容的哈希值生成。如果将来文件内容发生变化，Webpack会在生产中给出不同的名称，因此您不必担心资源的长期缓存。 Please be advised that this is also a custom feature of Webpack. 请注意，这也是Webpack的自定义功能。 It is not required for React but many people enjoy it (and React Native uses a similar mechanism for images).An alternative way of handling static assets is described in the next section. 对于React它不是必需的，但很多人都喜欢它(和React Native使用类似的图像机制). 下一节将介绍处理静态资源的另一种方法。 Using the public Folder使用public文件夹 Note: this feature is available with `react-scripts@0.5.0` and higher. 注意：此功能可用在react-scripts@0.5.0及更高版本。 Changing the HTML更改HTMLThe public folder contains the HTML file so you can tweak it, for example, to set the page title. The &lt;script&gt; tag with the compiled code will be added to it automatically during the build process. public 文件夹包含HTML文件，以便您可以调整它，例如设置页面标题。 编译代码的&lt;script&gt;标签将在构建过程中自动添加。 Adding Assets Outside of the Module System在模块系统之外添加资源You can also add other assets to the public folder.Note that we normally encourage you to import assets in JavaScript files instead.For example, see the sections on adding a stylesheet and adding images and fonts.This mechanism provides a number of benefits: 您还可以将其他资源添加到 public 文件夹。请注意，我们通常鼓励您以JavaScript文件import 资源。例如，请参阅添加样式表和添加图像和字体的部分。这个机制提供了许多好处： Scripts and stylesheets get minified and bundled together to avoid extra network requests. 脚本和样式表被缩小并捆绑在一起，以避免额外的网络请求。 Missing files cause compilation errors instead of 404 errors for your users. 缺少文件会导致编译错误，而不是用户的404错误。 Result filenames include content hashes so you don’t need to worry about browsers caching their old versions. 结果文件名包括内容散列，因此您不必担心浏览器会缓存其旧版本。 However there is an escape hatch that you can use to add an asset outside of the module system. 但是，您可以使用一个可用于在模块系统外部添加资产的逃生舱口。 If you put a file into the public folder, it will not be processed by Webpack. Instead it will be copied into the build folder untouched. To reference assets in the public folder, you need to use a special variable called PUBLIC_URL. 如果将文件放入 public 文件夹，则不会被Webpack处理。相反，它将被复制到构建文件夹中。要引用 public 文件夹中的资源，您需要使用一个名为PUBLIC_URL的特殊变量。 Inside index.html, you can use it like this: 在index.html里面，你可以这样使用： 1&lt;link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico"&gt; Only files inside the public folder will be accessible by %PUBLIC_URL% prefix. If you need to use a file from src or node_modules, you’ll have to copy it there to explicitly specify your intention to make this file a part of the build. 只有public文件夹中的文件才能被％PUBLIC_URL％前缀访问。如果您需要使用src或node_modules中的文件，那么您必须将其复制到其中才能明确指定您将该文件作为构建的一部分。 When you run npm run build, Create React App will substitute %PUBLIC_URL% with a correct absolute path so your project works even if you use client-side routing or host it at a non-root URL. 当你运行 npm run build时，Create React App将使用正确的绝对路径替换％PUBLIC_URL％，这样即使您使用客户端路由或将其托管在非根URL，您的项目也可以工作。 In JavaScript code, you can use process.env.PUBLIC_URL for similar purposes: 在JavaScript代码中，您可以使用process.env.PUBLIC_URL进行类似的操作： 12345678910render() &#123; // Note: this is an escape hatch and should be used sparingly! // Normally we recommend using `import` for getting asset URLs // as described in “Adding Images and Fonts” above this section. // 注意：这是一个逃生舱口，应该谨慎使用！ // 通常，我们建议使用`import`获取资源URL // 如本节上面的“添加图像和字体”中所述。 return &lt;img src=&#123;process.env.PUBLIC_URL + '/img/logo.png'&#125; /&gt;;&#125; Keep in mind the downsides of this approach: 记住这种方法的缺点： None of the files in public folder get post-processed or minified. public 文件夹中的任何文件都不能进行后处理或缩小。 Missing files will not be called at compilation time, and will cause 404 errors for your users. 在编译时不会调用缺少的文件，并会为您的用户造成404错误。 Result filenames won’t include content hashes so you’ll need to add query arguments or rename them every time they change. 结果文件名不会包含内容散列，因此您需要添加查询参数或每次更改时重命名它们。 When to Use the public Folder何时使用public文件夹Normally we recommend importing stylesheets, images, and fonts from JavaScript.The public folder is useful as a workaround for a number of less common cases: 通常我们建议从JavaScript导入样式表，图像和字体。 public 文件夹作为一些不太常见情况的解决方法是有用的： You need a file with a specific name in the build output, such as manifest.webmanifest. 您需要在构建输出中具有特定名称的文件，如 manifest.webmanifest. You have thousands of images and need to dynamically reference their paths. 您有成千上万的图像，需要动态引用他们的路径。 You want to include a small script like pace.js outside of the bundled code. 您希望在捆绑代码之外加入一个像 pace.js 一样的脚本。 Some library may be incompatible with Webpack and you have no other option but to include it as a &lt;script&gt; tag. 某些库可能与Webpack不兼容，您没有其他选项，但将其作为&lt;script&gt;标签。 Note that if you add a &lt;script&gt; that declares global variables, you also need to read the next section on using them. 请注意，如果添加声明全局变量的&lt;script&gt;，则还需要阅读下一节如何使用它们。 Using Global Variables使用全局变量When you include a script in the HTML file that defines global variables and try to use one of these variables in the code, the linter will complain because it cannot see the definition of the variable. 当您在定义全局变量的HTML文件中包含一个脚本并尝试在代码中使用这些变量之一时，linter会抱怨，因为它看不到变量的定义。 You can avoid this by reading the global variable explicitly from the window object, for example: 您可以通过从 window 对象显式读取全局变量来避免这种情况，例如： 1const $ = window.$; This makes it obvious you are using a global variable intentionally rather than because of a typo. 这显然你有意使用全局变量，而不是因为打字错误。 Alternatively, you can force the linter to ignore any line by adding // eslint-disable-line after it. 或者，您可以通过在其后添加// eslint-disable-line来强制linter忽略任何行。 Adding Bootstrap添加Bootstrap库You don’t have to use React Bootstrap together with React but it is a popular library for integrating Bootstrap with React apps. If you need it, you can integrate it with Create React App by following these steps: 您不必与React一起使用React Bootstrap，但它是将Bootstrap与React应用程序集成的流行库。如果需要，可以通过以下步骤将其与创建应用程序集成： Install React Bootstrap and Bootstrap from npm. React Bootstrap does not include Bootstrap CSS so this needs to be installed as well: 从npm库中安装React Bootstrap和Bootstrap。React Bootstrap不包括Bootstrap CSS，因此还需要安装它们： 12npm install react-bootstrap --savenpm install bootstrap@3 --save Import Bootstrap CSS and optionally Bootstrap theme CSS in the beginning of your file:12345678在 ```src/index.js``` 文件的开头导入Bootstrap CSS和可选的Bootstrap主题CSS：```jsimport &apos;bootstrap/dist/css/bootstrap.css&apos;;import &apos;bootstrap/dist/css/bootstrap-theme.css&apos;;// Put any other imports below so that CSS from your components takes precedence over default styles.// 在下面放置任何其他导入，以使您的组件中的CSS优先于默认样式。 Import required React Bootstrap components within file or your custom component files:12345在 ```src/App.js``` 文件或您的自定义组件文件中导入所需的React Bootstrap组件：```jsimport &#123; Navbar, Jumbotron, Button &#125; from &apos;react-bootstrap&apos;; Now you are ready to use the imported React Bootstrap components within your component hierarchy defined in the render method. Here is an example App.js redone using React Bootstrap. 现在，您可以使用导入的React Bootstrap组件在render方法中定义组件层次结构。以下是使用React Bootstrap重做App.js的示例。 Using a Custom Theme使用自定义主题Sometimes you might need to tweak the visual styles of Bootstrap (or equivalent package).We suggest the following approach: 有时您可能需要调整Bootstrap（或等效包）的视觉样式. 我们建议采纳以下方法： Create a new package that depends on the package you wish to customize, e.g. Bootstrap. 创建一个取决于您要自定义的包的新包, e.g. Bootstrap. Add the necessary build steps to tweak the theme, and publish your package on npm. 添加必要的构建步骤来调整主题，并在npm发布您的包。 Install your own theme npm package as a dependency of your app. 安装您自己的主题npm软件包作为您的应用程序的依赖。 Here is an example of adding a customized Bootstrap that follows these steps. 以下是添加按照这些步骤进行自定义的Bootstrap的示例。 Adding Flow添加流Flow is a static type checker that helps you write code with fewer bugs. Check out this introduction to using static types in JavaScript if you are new to this concept. Flow是一种静态类型的检查器，可以帮助您编写更少错误的代码。如果您是这个概念的新手，请参阅JavaScript中使用静态类型的介绍 。 Recent versions of Flow work with Create React App projects out of the box. Flow的最新版本可以使用“Create React App”工具的开箱即用功能。 To add Flow to a Create React App project, follow these steps: 要将Flow添加到使用Create React App工具创建的项目中，请按照下列步骤操作： Run npm install --save-dev flow-bin (or yarn add --dev flow-bin). Add &quot;flow&quot;: &quot;flow&quot; to the scripts section of your package.json. Run npm run flow -- init (or yarn flow -- init) to create a .flowconfig file in the root directory. Add // @flow to any files you want to type check (for example, to src/App.js). ​ 运行 npm install --save-dev flow-bin (或 yarn add --dev flow-bin)。 将 &quot;flow&quot;: &quot;flow&quot; 添加到您的package.json的 scripts 部分。 运行 npm run flow -- init (或 yarn flow -- init)以在根目录中创建一个.flowconfig文件。 将 // @flow 添加到要进行类型检查的任何文件中（例如，到src/App.js）。 Now you can run npm run flow (or yarn flow) to check the files for type errors. You can optionally use an IDE like Nuclide for a better integrated experience. In the future we plan to integrate it into Create React App even more closely. 现在，您可以运行 npm run flow (或 yarn flow) 来检查文件的类型错误。您可以选择使用像Nuclide 这样的IDE来获得更好的集成体验。在将来，我们计划更加紧密地将其整合到Create React App工具中。 To learn more about Flow, check out its documentation. 要了解有关Flow的更多信息，请查看其文档。 Adding Custom Environment Variables添加自定义环境变量 Note: this feature is available with `react-scripts@0.2.3` and higher. 注意：此功能可用在`react-scripts@0.2.3`及更高版本。 Your project can consume variables declared in your environment as if they were declared locally in your JS files. By default you will have NODE_ENV defined for you, and any other environment variables starting withREACT_APP_. 您的项目可以在您的环境中使用声明的变量，就像它们在JS文件中本地声明一样。默认情况下，您将为您定义NODE_ENV，以及以REACT_APP_开头的任何其他环境变量。 The environment variables are embedded during the build time. Since Create React App produces a static HTML/CSS/JS bundle, it can’t possibly read them at runtime. To read them at runtime, you would need to load HTML into memory on the server and replace placeholders in runtime, just like described here. Alternatively you can rebuild the app on the server anytime you change them. 环境变量在构建时嵌入。由于Create React App生成了一个静态的HTML/CSS/JS包，所以在运行时无法读取它们。要在运行时读取它们，您需要将HTML加载到服务器上的内存中，并在运行时替换占位符，就像这里所述。或者，您可以在更改服务器时重新构建应用程序。 Note: You must create custom environment variables beginning with REACT_APP_. Any other variables except NODE_ENV will be ignored to avoid accidentally exposing a private key on the machine that could have the same name. Changing any environment variables will require you to restart the development server if it is running. 注意：您必须创建以REACT_APP_开头的自定义环境变量。除了NODE_ENV之外的任何其他变量将被忽略，以避免意外暴露可能具有相同名称的机器上的私钥。更改任何环境变量将需要重新启动开发服务器，如果它正在运行。 These environment variables will be defined for you on process.env. For example, having an environmentvariable named REACT_APP_SECRET_CODE will be exposed in your JS as process.env.REACT_APP_SECRET_CODE. 这些环境变量将在process.env上为您定义。例如，将一个名为REACT_APP_SECRET_CODE的环境变量作为process.env.REACT_APP_SECRET_CODE暴露在您的JS中。 There is also a special built-in environment variable called NODE_ENV. You can read it from process.env.NODE_ENV. When you run npm start, it is always equal to &#39;development&#39;, when you run npm test it is always equal to &#39;test&#39;, and when you run npm run build to make a production bundle, it is always equal to &#39;production&#39;. You cannot override NODE_ENV manually. This prevents developers from accidentally deploying a slow development build to production. 还有一个特殊的内置环境变量NODE_ENV。你可以从process.env.NODE_ENV读取它。当你运行npm start时，它总是等于development，当你运行npm test它总是等于test，当你运行 npm run build 来生成一个生产包，它总是等于production 。您不能手动覆盖NODE_ENV。这样可以防止开发人员意外地将缓慢的开发构建部署到生产环境中。 These environment variables can be useful for displaying information conditionally based on where the project is deployed or consuming sensitive data that lives outside of version control. 这些环境变量对于有条件地显示信息[可能会有助于基于项目的部署位置或消费存在于版本控制之外的敏感数据]。 First, you need to have environment variables defined. For example, let’s say you wanted to consume a secret defined in the environment inside a &lt;form&gt;: 首先，您需要定义环境变量。例如，假设您想要使用&lt;form&gt;中的环境中定义的秘钥： 12345678910render() &#123; return ( &lt;div&gt; &lt;small&gt;You are running this application in &lt;b&gt;&#123;process.env.NODE_ENV&#125;&lt;/b&gt; mode.&lt;/small&gt; &lt;form&gt; &lt;input type="hidden" defaultValue=&#123;process.env.REACT_APP_SECRET_CODE&#125; /&gt; &lt;/form&gt; &lt;/div&gt; );&#125; During the build, process.env.REACT_APP_SECRET_CODE will be replaced with the current value of the REACT_APP_SECRET_CODE environment variable. Remember that the NODE_ENV variable will be set for you automatically. 在构建期间，process.env.REACT_APP_SECRET_CODE将被REACT_APP_SECRET_CODE环境变量的当前值替换。请记住，NODE_ENV变量将自动为您设置。 When you load the app in the browser and inspect the &lt;input&gt;, you will see its value set to abcdef, and the bold text will show the environment provided when using npm start: 当您在浏览器中加载应用程序并检查&lt;input&gt;时，您将看到其值设置为abcdef，粗体文本将显示使用 npm start时提供的环境： 123456&lt;div&gt; &lt;small&gt;You are running this application in &lt;b&gt;development&lt;/b&gt; mode.&lt;/small&gt; &lt;form&gt; &lt;input type="hidden" value="abcdef" /&gt; &lt;/form&gt;&lt;/div&gt; The above form is looking for a variable called REACT_APP_SECRET_CODE from the environment. In order to consume this value, we need to have it defined in the environment. This can be done using two ways: either in your shell or in a .env file. Both of these ways are described in the next few sections. 上面的表单正在从环境中寻找一个名为REACT_APP_SECRET_CODE的变量。为了消耗这个值，我们需要在环境中定义它。这可以通过两种方式完成：在shell或.env文件中。这两种方法将在接下来的几节中进行描述。 Having access to the NODE_ENV is also useful for performing actions conditionally: 访问NODE_ENV对于有条件地执行操作也很有用： 123if (process.env.NODE_ENV !== 'production') &#123; analytics.disable();&#125; When you compile the app with npm run build, the minification step will strip out this condition, and the resulting bundle will be smaller. 当您使用 npm run build编译应用程序时，缩小步骤将剥离此条件，并且生成的包将更小。 Referencing Environment Variables in the HTML引用HTML中的环境变量 Note: this feature is available with `react-scripts@0.9.0` and higher. 注意：此功能可用在`react-scripts@0.9.0`及更高版本。 You can also access the environment variables starting with REACT_APP_ in the public/index.html. For example: 您还可以访问 public/index.html中的REACT_APP_开头的环境变量。例如： 1&lt;title&gt;%REACT_APP_WEBSITE_NAME%&lt;/title&gt; Note that the caveats from the above section apply: 请注意，上述部分的注意事项适用于： Apart from a few built-in variables (NODE_ENV and PUBLIC_URL), variable names must start with REACT_APP_ to work. 除了几个内置变量(NODE_ENV 和 PUBLIC_URL)，变量名必须以REACT_APP_开头。 The environment variables are injected at build time. If you need to inject them at runtime, follow this approach instead. 环境变量在构建时注入。如果您需要在运行时注入它们，请按照此方法。 Adding Temporary Environment Variables In Your Shell在Shell中添加临时环境变量Defining environment variables can vary between OSes. It’s also important to know that this manner is temporary for the life of the shell session. 定义环境变量会根据操作系统而定。知道这种方式对于shell会话的生命是暂时的也很重要。 Windows (cmd.exe)1set REACT_APP_SECRET_CODE=abcdef&amp;&amp;npm start (Note: the lack of whitespace is intentional.)(注意：缺乏空白是有意的。) Linux, macOS (Bash)1REACT_APP_SECRET_CODE=abcdef npm start Adding Development Environment Variables In .env在.env添加开发环境变量 Note: this feature is available with `react-scripts@0.5.0` and higher. 注意：此功能可用在react-scripts@0.5.0及更高版本。 To define permanent environment variables, create a file called .env in the root of your project: 要定义永久环境变量，请在项目的根目录中创建一个名为.env的文件： 1REACT_APP_SECRET_CODE=abcdef .env files should be checked into source control (with the exclusion of .env*.local). What other .env files are can be used?还可以使用什么其他.env文件？ Note: this feature is available with `react-scripts@1.0.0` and higher. 注意：此功能可用在react-scripts@1.0.0及更高版本。 .env: Default. .env: 默认. .env.local: Local overrides. This file is loaded for all environments except test. .env.local: 本地覆盖。该文件加载除了测试之外的所有环境. .env.development, .env.test, .env.production: Environment-specific settings. .env.development, .env.test, .env.production: 环境特定设. .env.development.local, .env.test.local, .env.production.local: Local overrides of environment-specific settings. .env.development.local, .env.test.local, .env.production.local: 本地覆盖环境特定的设置. Files on the left have more priority than files on the right: 左边的文件比右边的文件更优先： npm start: .env.development.local, .env.development, .env.local, .env npm run build: .env.production.local, .env.production, .env.local, .env npm test: .env.test.local, .env.test, .env (note .env.local is missing。缺少 .env.local ) These variables will act as the defaults if the machine does not explicitly set them.Please refer to the dotenv documentation for more details. 如果机器没有明确设置它们，这些变量将作为默认值. 有关详细信息，请参阅dotenv文档。 Note: If you are defining environment variables for development, your CI and/or hosting platform will most likely needthese defined as well. Consult their documentation how to do this. For example, see the documentation for Travis CI or Heroku. 注意：如果要定义用于开发的环境变量，则您的CI and/or 托管平台最有可能需要这些定义。请咨询他们的文档如何做到这一点。例如，请参阅 Travis CI 或 Heroku的文档。 Can I Use Decorators?我可以使用装饰器吗？Many popular libraries use decorators in their documentation.Create React App doesn’t support decorator syntax at the moment because: 许多受欢迎的库在其文档中使用装饰器。 Create React App目前不支持装饰器语法，因为： It is an experimental proposal and is subject to change. 这是一个实验性提案，可能会改变。 The current specification version is not officially supported by Babel. 目前的规范版本没有被Babel正式支持。 If the specification changes, we won’t be able to write a codemod because we don’t use them internally at Facebook. 如果规范发生变化，我们将无法编写一个codemod，因为我们不在Facebook内部使用它们。 However in many cases you can rewrite decorator-based code without decorators just as fine.Please refer to these two threads for reference: 但是，在许多情况下，您可以重新编写基于装饰器的代码，而不需要装饰器就可以了. 请参考这两个线程以供参考： #214 #411 Create React App will add decorator support when the specification advances to a stable stage. 当规范进展到稳定的阶段时，Create React App将添加装饰器支持。 Integrating with an API Backend与后端API集成These tutorials will help you to integrate your app with an API backend running on another port, using fetch() to access it. 这些教程将帮助您将应用程序与在另一个端口上运行的API后端集成，使用fetch() 来访问它。 NodeCheck out this tutorial. You can find the companion GitHub repository here. 看看这个教程。您可以在这里找到配套的GitHub库。 Ruby on RailsCheck out this tutorial.You can find the companion GitHub repository here. 看看这个教程。您可以在这里找到配套的GitHub库。 Proxying API Requests in Development在开发中代理API请求 Note: this feature is available with `react-scripts@0.2.3` and higher. 注意：此功能可用在react-scripts@0.2.3及更高版本。 People often serve the front-end React app from the same host and port as their backend implementation.For example, a production setup might look like this after the app is deployed: 人们经常从后端实施相同的主机和端口为前端的React应用程序提供服务. 例如，应用程序部署后，生产设置可能会如下所示： 123/ - static server returns index.html with React app/todos - static server returns index.html with React app/api/todos - server handles any /api/* requests using the backend implementation Such setup is not required. However, if you do have a setup like this, it is convenient to write requests like fetch(&#39;/api/todos&#39;) without worrying about redirecting them to another host or port during development. 不需要这样的设置。但是，如果您有这样的设置，可以方便地编写fetch(&#39;/api/todos&#39;) 等请求，而不用担心在开发过程中将它们重定向到另一个主机或端口。 To tell the development server to proxy any unknown requests to your API server in development, add a proxy field to your package.json, for example: 在开发中,要告诉开发服务器代理对您的API服务器的任何未知请求，请向您的package.json添加一个proxy字段，例如： 1"proxy": "http://localhost:4000", This way, when you fetch(&#39;/api/todos&#39;) in development, the development server will recognize that it’s not a static asset, and will proxy your request to http://localhost:4000/api/todos as a fallback. The development server will only attempt to send requests without a text/html accept header to the proxy. 这样，当您在开发中fetch(&#39;/api/todos&#39;) 时，开发服务器将会认识到它不是静态资源，并将代理您的请求到http://localhost:4000/api/todos 作为回调。开发服务器将只尝试发送没有 text/html 接收标头的请求到代理端口。 Conveniently, this avoids CORS issues and error messages like this in development: 这样可以方便地避免在开发过程中发生CORS issues和错误消息： 1Fetch API cannot load http://localhost:4000/api/todos. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://localhost:3000&apos; is therefore not allowed access. If an opaque response serves your needs, set the request&apos;s mode to &apos;no-cors&apos; to fetch the resource with CORS disabled. Keep in mind that proxy only has effect in development (with npm start), and it is up to you to ensure that URLs like /api/todos point to the right thing in production. You don’t have to use the /api prefix. Any unrecognized request without a text/html accept header will be redirected to the specified proxy. 请记住，代理仅在开发中有效 (使用 npm start)，并且由您来确保像 /api/todos 这样的URL指向生产中的正确的东西。您不必使用 /api 前缀。任何无法识别的没有 text/html 接收标头的请求，将被重定向到指定的 proxy. The proxy option supports HTTP, HTTPS and WebSocket connections.If the proxy option is not flexible enough for you, alternatively you can: proxy 选项支持HTTP，HTTPS和WebSocket连接. 如果 proxy 选项对您不够灵活，或者您可以： Configure the proxy yourself 自己配置代理 Enable CORS on your server (here’s how to do it for Express). 在您的服务器上启用CORS（以下是Express的操作方法）。 Use environment variables to inject the right server host and port into your app. 使用环境变量 将正确的服务器主机和端口注入到应用程序中。 “Invalid Host Header” Errors After Configuring Proxy配置代理后的“主机头无效”错误When you enable the proxy option, you opt into a more strict set of host checks. This is necessary because leaving the backend open to remote hosts makes your computer vulnerable to DNS rebinding attacks. The issue is explained in this article and this issue. 启用代理选项后，您可以选择更严格的主机检查。这是必要的，因为将后端打开到远程主机会使您的计算机容易受到DNS重新绑定攻击。此问题在这篇文章和这个问题进行了解释。 This shouldn’t affect you when developing on localhost, but if you develop remotely like described here, you will see this error in the browser after enabling the proxy option: 这应该不影响你在本地主机上开发，但是如果你像这里描述的那样进行远程开发，启用代理选项后，您将在浏览器中看到此错误： Invalid Host header 主机头无效 To work around it, you can specify your public development host in a file called .env.development in the root of your project: 要解决它，您可以在项目根目录中的一个名为.env.development的文件中指定您的公共开发主机： 1HOST=mypublicdevhost.com If you restart the development server now and load the app from the specified host, it should work. 如果现在重新启动开发服务器并从指定的主机加载该应用程序，它应该会正常工作。 If you are still having issues or if you’re using a more exotic environment like a cloud editor, you can bypass the host check completely by adding a line to .env.development.local. Note that this is dangerous and exposes your machine to remote code execution from malicious websites: 如果您仍然遇到问题，或者如果您正在使用更加异域情调的环境，如云编辑器，您可以通过向.env.development.local添加一行来完全绕过主机检查。 1234# NOTE: THIS IS DANGEROUS! 注意：这是危险的！# It exposes your machine to attacks from the websites you visit.# 它暴露您的机器将会导致您访问的的网站被攻击。DANGEROUSLY_DISABLE_HOST_CHECK=true We don’t recommend this approach. 我们不推荐这种方法。 Configuring the Proxy Manually手动配置代理 Note: this feature is available with `react-scripts@1.0.0` and higher. 注意：此功能可用在react-scripts@1.0.0及更高版本。 If the proxy option is not flexible enough for you, you can specify an object in the following form (in package.json).You may also specify any configuration value http-proxy-middleware or http-proxy supports. 如果代理选项对您不够灵活，您可以使用以下格式指定一个对象（在package.json中）。 您还可以指定任何配置值 http-proxy-middleware 或 http-proxy 支持。 1234567891011&#123; // ... "proxy": &#123; "/api": &#123; "target": "&lt;url&gt;", "ws": true // ... &#125; &#125; // ...&#125; All requests matching this path will be proxies, no exceptions. This includes requests for text/html, which the standard proxy option does not proxy. 与此路径匹配的所有请求都将是代理，没有例外。这包括 text/html的请求，标准代理选项不代理。 If you need to specify multiple proxies, you may do so by specifying additional entries. You may also narrow down matches using * and/or **, to match the path exactly or any subpath. 如果需要指定多个代理，则可以通过指定其他条目来实现。您还可以使用 * 和/或 **缩小匹配，以准确匹配路径或任何子路径。 12345678910111213141516171819202122232425262728293031&#123; // ... "proxy": &#123; // Matches any request starting with /api "/api": &#123; "target": "&lt;url_1&gt;", "ws": true // ... &#125;, // Matches any request starting with /foo "/foo": &#123; "target": "&lt;url_2&gt;", "ssl": true, "pathRewrite": &#123; "^/foo": "/foo/beta" &#125; // ... &#125;, // Matches /bar/abc.html but not /bar/sub/def.html "/bar/*.html": &#123; "target": "&lt;url_3&gt;", // ... &#125;, // Matches /bar/abc.html and /bar/sub/def.html "/baz/**/*.html": &#123; "target": "&lt;url_4&gt;" // ... &#125; &#125; // ...&#125; Using HTTPS in Development在开发中使用HTTPS Note: this feature is available with `react-scripts@0.4.0` and higher. 注意：此功能可用在react-scripts@0.4.0及更高版本。 You may require the dev server to serve pages over HTTPS. One particular case where this could be useful is when using the “proxy” feature to proxy requests to an API server when that API server is itself serving HTTPS. To do this, set the HTTPS environment variable to true, then start the dev server as usual with npm start: 您可能需要开发服务器提供HTTPS页面服务。一个特别的情况可能是有用的，当API服务器本身服务于HTTPS时，使用“代理”功能来代理对API服务器的请求。 为此，请将HTTPS环境变量设置为true，然后像以往那样以npm start启动开发服务器： Windows (cmd.exe)1set HTTPS=true&amp;&amp;npm start (Note: the lack of whitespace is intentional.注意：缺乏空白是有意的。) Linux, macOS (Bash)1HTTPS=true npm start Note that the server will use a self-signed certificate, so your web browser will almost definitely display a warning upon accessing the page. 请注意，服务器将使用自签名证书，因此您的Web浏览器几乎肯定会在访问页面时显示警告。 Generating Dynamic &lt;meta&gt; Tags on the Server在服务器上生成动态&lt;meta&gt;标签Since Create React App doesn’t support server rendering, you might be wondering how to make &lt;meta&gt; tags dynamic and reflect the current URL. To solve this, we recommend to add placeholders into the HTML, like this: 由于Create React App不支持服务器渲染，您可能会想知道如何使&lt;meta&gt;标签动态化并反映当前的URL。为了解决这个问题，我们建议在HTML中添加占位符，如下所示： 12345&lt;!doctype html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta property="og:title" content="__OG_TITLE__"&gt; &lt;meta property="og:description" content="__OG_DESCRIPTION__"&gt; Then, on the server, regardless of the backend you use, you can read index.html into memory and replace __OG_TITLE__, __OG_DESCRIPTION__, and any other placeholders with values depending on the current URL. Just make sure to sanitize and escape the interpolated values so that they are safe to embed into HTML! 然后，在服务器上，无论您使用的后端如何，您可以将index.html读入内存，并根据当前URL替换__OG_TITLE__，__OG_DESCRIPTION__和任何其他具有值的占位符。只需确保清理和转义内插的值，以便它们可以安全地嵌入到HTML中！ If you use a Node server, you can even share the route matching logic between the client and the server. However duplicating it also works fine in simple cases. 如果使用节点服务器，您甚至可以在客户端和服务器之间共享路由匹配逻辑。但是在简单的情况下，复制它也可以正常工作。 Pre-Rendering into Static HTML Files预渲染成静态HTML文件If you’re hosting your build with a static hosting provider you can use react-snapshot to generate HTML pages for each route, or relative link, in your application. These pages will then seamlessly become active, or “hydrated”, when the JavaScript bundle has loaded. 如果您使用静态主机提供商托管您的构建程序，则可以使用react-snapshot为应用程序中的每个路由或相对链接生成HTML页面。然后，这些页面将在JavaScript软件包加载时无缝地变为活动状态或“水合”。 There are also opportunities to use this outside of static hosting, to take the pressure off the server when generating and caching routes. 还有机会在静态托管之外使用它，在生成和缓存路由时将压力从服务器上取下。 The primary benefit of pre-rendering is that you get the core content of each page with the HTML payload—regardless of whether or not your JavaScript bundle successfully downloads. It also increases the likelihood that each route of your application will be picked up by search engines. 预渲染的主要优点是您可以使用HTML有效内容获取每个页面的核心内容，而不管您的JavaScript软件包是否成功下载。这也增加了您的应用程序的每个路由将被搜索引擎拾取的可能性。 You can read more about zero-configuration pre-rendering (also called snapshotting) here. 您可以在这里阅读有关零配置预渲染的更多信息（也称为快照）。 Injecting Data from the Server into the Page将数据从服务器注入页面Similarly to the previous section, you can leave some placeholders in the HTML that inject global variables, for example: 与上一节类似，您可以在注入全局变量的HTML中留下一些占位符，例如： 123456&lt;!doctype html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;script&gt; window.SERVER_DATA = __SERVER_DATA__; &lt;/script&gt; Then, on the server, you can replace __SERVER_DATA__ with a JSON of real data right before sending the response. The client code can then read window.SERVER_DATA to use it. Make sure to sanitize the JSON before sending it to the client as it makes your app vulnerable to XSS attacks. 然后，在服务器上，您可以在发送响应之前将__SERVER_DATA__替换为真实数据的JSON。客户端代码可以读取window.SERVER_DATA来使用它。确保在将JSON发送到客户端之前进行清理 ，因为它使您的应用程序易受XSS攻击。 Running Tests运行测试 Note: this feature is available with `react-scripts@0.3.0` and higher.Read the migration guide to learn how to enable it in older projects! 注意：此功能可用在react-scripts@0.3.0及更高版本。 阅读迁移指南，了解如何在旧项目中启用它！ Create React App uses Jest as its test runner. To prepare for this integration, we did a major revamp of Jest so if you heard bad things about it years ago, give it another try. Create React App使用Jest作为其测试运行器。为了做好这个整合的准备，我们做了一个重大改革的Jest，所以如果你听到很多年前的坏事，再试一次。 Jest is a Node-based runner. This means that the tests always run in a Node environment and not in a real browser. This lets us enable fast iteration speed and prevent flakiness. Jest是一个基于Node的运行器。这意味着测试总是在Node环境中运行，而不是在真实的浏览器中运行。这使我们能够实现加快迭代速度并防止碎片化。 While Jest provides browser globals such as window thanks to jsdom, they are only approximations of the real browser behavior. Jest is intended to be used for unit tests of your logic and your components rather than the DOM quirks. 虽然Jest提供浏览器全局变量，如 window 感谢 jsdom，但它们只是和真正的浏览器的行为相似。 Jest旨在用于您的逻辑和组件的单元测试，而不是DOM的差异。 We recommend that you use a separate tool for browser end-to-end tests if you need them. They are beyond the scope of Create React App. 如果需要，我们建议您使用单独的浏览器端到端测试工具。它们超出了Create React App的范围。 Filename Conventions文件名约定Jest will look for test files with any of the following popular naming conventions: Jest将使用以下任何常见的命名规则来查找测试文件： Files with .js suffix in __tests__ folders. __tests__文件夹中带有.js后缀的文件。 Files with .test.js suffix. 带有.test.js后缀的文件。 Files with .spec.js suffix. 带有.spec.js后缀的文件。 The .test.js / .spec.js files (or the __tests__ folders) can be located at any depth under the src top level folder. .test.js / .spec.js 文件（或__tests__文件夹）可以位于src顶级文件夹下的任意深度。 We recommend to put the test files (or __tests__ folders) next to the code they are testing so that relative imports appear shorter. For example, if App.test.js and App.js are in the same folder, the test just needs to import App from &#39;./App&#39; instead of a long relative path. Colocation also helps find tests more quickly in larger projects. 我们建议将测试文件（或__tests__文件夹）放在正在测试的代码旁边，以使相对导入更短。例如，如果App.test.js和App.js在同一个文件夹中，测试只需要 import App from &#39;./App&#39; ，而不是长的相对路径。这样还有助于在更大的项目中更快地找到测试。 Command Line Interface命令行界面When you run npm test, Jest will launch in the watch mode. Every time you save a file, it will re-run the tests, just like npm start recompiles the code. 当您运行npm test时，Jest将以观察模式启动。每次保存文件时，都会重新运行测试，就像 npm start 重新编译代码一样。 The watcher includes an interactive command-line interface with the ability to run all tests, or focus on a search pattern. It is designed this way so that you can keep it open and enjoy fast re-runs. You can learn the commands from the “Watch Usage” note that the watcher prints after every run: 观察者包括交互式命令行界面，具有运行所有测试的能力，或专注于搜索模式。它是这样设计的，以便您可以保持打开并享受快速重新运行。您可以从“观察使用情况”注意中了解每次运行后观察者打印的命令： Version Control Integration版本控制集成By default, when you run npm test, Jest will only run the tests related to files changed since the last commit. This is an optimization designed to make your tests runs fast regardless of how many tests you have. However it assumes that you don’t often commit the code that doesn’t pass the tests. 默认情况下，当您运行npm test时，Jest将仅运行与上次提交后更改的文件相关的测试。这是一个优化，旨在使您的测试快速运行，无论您有多少测试。但是，它假定您不经常提交不通过测试的代码。 Jest will always explicitly mention that it only ran tests related to the files changed since the last commit. You can also press a in the watch mode to force Jest to run all tests. Jest将始终明确提到，它只运行与上次提交后更改的文件相关的测试。您也可以按观察表模式强制Jest运行所有测试。 Jest will always run all tests on a continuous integration server or if the project is not inside a Git or Mercurial repository. Jest将始终在持续集成的服务器上运行所有测试，或者该项目不在Git或Mercurial资源库中。 Writing Tests写测试To create tests, add it() (or test()) blocks with the name of the test and its code. You may optionally wrap them in describe() blocks for logical grouping but this is neither required nor recommended. Jest provides a built-in expect() global function for making assertions. A basic test could look like this: 要创建测试，请使用测试名称及其代码添加it() (or test())块。您可以选择将其包装在 describe() 块中进行逻辑分组，但这不是必需的，也不是推荐的。 Jest提供了一个内置的 expect() 全局函数来进行断言。基本测试可能如下所示： 123456import sum from './sum';it('sums numbers', () =&gt; &#123; expect(sum(1, 2)).toEqual(3); expect(sum(2, 2)).toEqual(4);&#125;); All expect() matchers supported by Jest are extensively documented here.You can also use jest.fn() and expect(fn).toBeCalled() to create “spies” or mock functions. Jest支持的所有expect()匹配器都在这里进行了广泛的记录。 您也可以使用 jest.fn() and expect(fn).toBeCalled()创建“间谍”或模拟函数。 Testing Components测试组件There is a broad spectrum of component testing techniques. They range from a “smoke test” verifying that a component renders without throwing, to shallow rendering and testing some of the output, to full rendering and testing component lifecycle and state changes. 这有广泛的组件测试技术。它们的范围从“Smoke Test” ，验证组件是否在不抛出的情况下渲染，浅渲染和测试某些输出，完全渲染和测试组件生命周期和状态更改。 Different projects choose different testing tradeoffs based on how often components change, and how much logic they contain. If you haven’t decided on a testing strategy yet, we recommend that you start with creating simple smoke tests for your components: 不同的项目根据组件变化的频率及其包含的逻辑选择不同的测试权衡进行取舍。如果您尚未决定测试策略，我们建议您首先为组件创建简单的Smoke Test： 12345678import React from 'react';import ReactDOM from 'react-dom';import App from './App';it('renders without crashing', () =&gt; &#123; const div = document.createElement('div'); ReactDOM.render(&lt;App /&gt;, div);&#125;); This test mounts a component and makes sure that it didn’t throw during rendering. Tests like this provide a lot value with very little effort so they are great as a starting point, and this is the test you will find in src/App.test.js. 该测试挂在了一个组件，并确保它在渲染过程中没有抛出错误。这样的测试通过很少的努力提供了很多价值，所以他们是伟大的起点，这是你将在src/App.test.js中找到的测试。 When you encounter bugs caused by changing components, you will gain a deeper insight into which parts of them are worth testing in your application. This might be a good time to introduce more specific tests asserting specific expected output or behavior. 当您遇到由更改组件导致的错误时，您将深入了解其中哪些部分在您的应用程序中值得测试。这可能是引入更具体的测试来判断具体的预期输出或行为的好时机。 If you’d like to test components in isolation from the child components they render, we recommend using shallow() rendering API from Enzyme. You can write a smoke test with it too: 如果您想要从他们呈现的子组件中孤立测试组件，我们建议使用Enzyme中的shallow() 渲染 API 。你也可以写Smoke Test： 1npm install --save-dev enzyme react-test-renderer 1234567import React from 'react';import &#123; shallow &#125; from 'enzyme';import App from './App';it('renders without crashing', () =&gt; &#123; shallow(&lt;App /&gt;);&#125;); Unlike the previous smoke test using ReactDOM.render(), this test only renders &lt;App&gt; and doesn’t go deeper. For example, even if &lt;App&gt; itself renders a &lt;Button&gt; that throws, this test will pass. Shallow rendering is great for isolated unit tests, but you may still want to create some full rendering tests to ensure the components integrate correctly. Enzyme supports full rendering with mount(), and you can also use it for testing state changes and component lifecycle. 与以前使用ReactDOM.render()的Smoke Test不同，这个测试仅仅渲染&lt;App&gt;，而不会更深入。例如，即使&lt;App&gt;本身渲染抛出的&lt;Button&gt;，此测试也将通过。浅渲染非常适合隔离单元测试，但您仍然可能需要创建一些完整的渲染测试，以确保组件正确集成。Enzyme支持使用mount()完全呈现，还可以使用它来测试状态更改和组件生命周期。 You can read the Enzyme documentation for more testing techniques. Enzyme documentation uses Chai and Sinon for assertions but you don’t have to use them because Jest provides built-in expect() and jest.fn() for spies. Here is an example from Enzyme documentation that asserts specific output, rewritten to use Jest matchers: 您可以阅读Enzyme文档了解更多测试技术。Enzyme文档使用Chai和Sinon作为断言，但您不必使用它们，因为Jest为间谍提供了内置的 expect() 和 jest.fn() 。 以下是Enzyme文档中的一个例子，该文档声明了特定输出，重写为使用Jest匹配器： 12345678910import React from 'react';import &#123; shallow &#125; from 'enzyme';import App from './App';it('renders welcome message', () =&gt; &#123; const wrapper = shallow(&lt;App /&gt;); const welcome = &lt;h2&gt;Welcome to React&lt;/h2&gt;; // expect(wrapper.contains(welcome)).to.equal(true); expect(wrapper.contains(welcome)).toEqual(true);&#125;); All Jest matchers are extensively documented here.Nevertheless you can use a third-party assertion library like Chai if you want to, as described below. 所有Jest匹配器在这里被广泛记录。 不过，如下所述，您可以使用像 Chai 这样的第三方断言库。 Additionally, you might find jest-enzyme helpful to simplify your tests with readable matchers. The above contains code can be written simpler with jest-enzyme. 此外，您可能会发现jest-enzyme有助于简化您的测试与可读匹配器。以上包含的代码可以用jest-enzyme更简单。 1expect(wrapper).toContainReact(welcome) To setup jest-enzyme with Create React App, follow the instructions for initializing your test environment to import jest-enzyme. Note that currently only version 2.x is compatible with Create React App. 要使用Create React App设置jest-enzyme，请按照初始化测试环境的说明导入jest-enzyme。请注意，目前只有2.x版本与Create React App兼容 1npm install --save-dev jest-enzyme@2.x 12// src/setupTests.jsimport 'jest-enzyme'; Using Third Party Assertion Libraries使用第三方断言库We recommend that you use expect() for assertions and jest.fn() for spies. If you are having issues with them please file those against Jest, and we’ll fix them. We intend to keep making them better for React, supporting, for example, pretty-printing React elements as JSX. 我们建议您使用 expect() 的断言和 jest.fn() 作为间谍。如果您遇到问题，请提交给Jest，我们会解决这些问题。我们打算继续使他们更好地支持React，例如，完美的打印React元素作为JSX。 However, if you are used to other libraries, such as Chai and Sinon, or if you have existing code using them that you’d like to port over, you can import them normally like this: 但是，如果您习惯于其他库，例如Chai和Sinon，或者如果您现有的代码使用您想要移植的代码，则可以像这样导入它们： 12import sinon from 'sinon';import &#123; expect &#125; from 'chai'; and then use them in your tests like you normally do. 然后在你的测试中像你通常那样使用它们。 Initializing Test Environment初始化测试环境 Note: this feature is available with `react-scripts@0.4.0` and higher. 注意：此功能可用在react-scripts@0.4.0及更高版本。 If your app uses a browser API that you need to mock in your tests or if you just need a global setup before running your tests, add a src/setupTests.js to your project. It will be automatically executed before running your tests. For example: 如果您的应用程序使用您需要模仿测试的浏览器API，或者在运行测试之前需要全局设置，请将src/setupTests.js添加到您的项目中。它将在运行测试之前自动执行。 例如: src/setupTests.js123456const localStorageMock = &#123; getItem: jest.fn(), setItem: jest.fn(), clear: jest.fn()&#125;;global.localStorage = localStorageMock Focusing and Excluding Tests聚焦和排除测试You can replace it() with xit() to temporarily exclude a test from being executed.Similarly, fit() lets you focus on a specific test without running any other tests. 您可以用xit()替换it()以临时排除测试被执行。 同样， fit() 可以让您专注于特定的测试，而无需运行任何其他测试。 Coverage ReportingJest has an integrated coverage reporter that works well with ES6 and requires no configuration.Run npm test -- --coverage (note extra -- in the middle) to include a coverage report like this: Jest有一个综合报道记者，与ES6工作良好，不需要配置。 运行 npm test -- --coverage（在中间注意额外参数 -- ）包括覆盖率报告如下： Note that tests run much slower with coverage so it is recommended to run it separately from your normal workflow. 请注意，测试的运行速度要慢得多，因此建议您从正常的工作流程中分离运行它。 Continuous Integration持续整合By default npm test runs the watcher with interactive CLI. However, you can force it to run tests once and finish the process by setting an environment variable called CI. 默认情况下，npm test使用交互式CLI运行观察器。但是，您可以强制运行测试一次，并通过设置一个名为CI的环境变量来完成该过程。 When creating a build of your application with npm run build linter warnings are not checked by default. Like npm test, you can force the build to perform a linter warning check by setting the environment variable CI. If any warnings are encountered then the build fails. 当使用npm run build创建一个应用程序的构建时，默认情况下不会检查linter警告。像npm test一样，您可以通过设置环境变量CI来强制构建执行linter警告检查。如果遇到任何警告，则构建失败。 Popular CI servers already set the environment variable CI by default but you can do this yourself too: 流行的CI服务器默认已经设置了环境变量CI，但您也可以自己做这个： On CI servers在CI服务器上Travis CI Following the Travis Getting started guide for syncing your GitHub repository with Travis. You may need to initialize some settings manually in your profile page. 遵循Travis入门指南，将您的GitHub存储库与Travis同步。您可能需要在个人资料页面中手动初始化某些设置。 Add a .travis.yml file to your git repository. 将.travis.yml文件添加到git存储库。 12345678910language: node_jsnode_js: - 4 - 6cache: directories: - node_modulesscript: - npm test - npm run build Trigger your first build with a git push. 用git push来触发你的第一个build。 Customize your Travis CI Build if needed. 如果需要，定制您的Travis CI Build。 On your own environment在你自己的环境中Windows (cmd.exe)1set CI=true&amp;&amp;npm test 1set CI=true&amp;&amp;npm run build (Note: the lack of whitespace is intentional.注意：缺乏空白是有意的。) Linux, macOS (Bash)1CI=true npm test 1CI=true npm run build The test command will force Jest to run tests once instead of launching the watcher. 测试命令将强制Jest运行测试一次，而不是启动观察器。 If you find yourself doing this often in development, please file an issue to tell us about your use case because we want to make watcher the best experience and are open to changing how it works to accommodate more workflows. 如果您发现自己在开发中经常遇到这种情况，请提出一个问题来告诉我们您的用例，因为我们希望让观察者获得最佳体验，并且可以随时更改工作流程以适应更多的工作流程。 The build command will check for linter warnings and fail if any are found. 构建命令将检查linter警告，如果找到任何警告，则会失败。 Disabling jsdom禁用jsdomBy default, the package.json of the generated project looks like this: 默认情况下，生成的项目的package.json如下所示： 12345// ..."scripts": &#123; // ... "test": "react-scripts test --env=jsdom"&#125; If you know that none of your tests depend on jsdom, you can safely remove --env=jsdom, and your tests will run faster.To help you make up your mind, here is a list of APIs that need jsdom: 如果你知道你的测试都不依赖于jsdom，你可以安全地删除--env = jsdom，这样你的测试运行得更快。 为了帮助您解决问题，以下是需要jsdom的API列表： Any browser globals like window and document 任何浏览器全局变量，如 window 和 document ReactDOM.render() TestUtils.renderIntoDocument() (a shortcut for the above) mount() in Enzyme In contrast, jsdom is not needed for the following APIs: 相比之下，以下API不需要jsdom： TestUtils.createRenderer() (shallow rendering) shallow() in Enzyme Finally, jsdom is also not needed for snapshot testing. 最后，快照测试也不需要jsdom。 Snapshot Testing快照测试Snapshot testing is a feature of Jest that automatically generates text snapshots of your components and saves them on the disk so if the UI output changes, you get notified without manually writing any assertions on the component output. Read more about snapshot testing. 快照测试是Jest的一个功能，可自动生成组件的文本快照并将其保存在磁盘上，以便在UI输出更改时，您可以在不在组件输出上手动写入任何断言的情况下获得通知。阅读有关快照测试的更多信息. Editor Integration编辑器集成If you use Visual Studio Code, there is a Jest extension which works with Create React App out of the box. This provides a lot of IDE-like features while using a text editor: showing the status of a test run with potential fail messages inline, starting and stopping the watcher automatically, and offering one-click snapshot updates. 如果您使用Visual Studio Code，则有一个Jest扩展名可以与Create React App开箱即用。这在使用文本编辑器时提供了很多类似IDE的功能：使用潜在的故障消息内联显示测试运行的状态，自动启动和停止观察器，并提供一键式快照更新。 Developing Components in Isolation处于隔离状态开发组件Usually, in an app, you have a lot of UI components, and each of them has many different states.For an example, a simple button component could have following states: 通常，在应用程序中，您有很多UI组件，并且每个都有许多不同的状态。例如，一个简单的按钮组件可以具有以下状态： In a regular state, with a text label.在正常状态下，带有文本标签。 In the disabled mode.禁用模式。 In a loading state.加载状态。 Usually, it’s hard to see these states without running a sample app or some examples. 通常，在不运行示例应用程序或一些示例的情况下，很难看到这些状态。 Create React App doesn’t include any tools for this by default, but you can easily add Storybook for React (source) to your project. It is a third-party tool that lets you develop components and see all their states in isolation from your app. 默认情况下，Create React App不包含任何工具，但您可以轻松地将 Storybook for React (source)添加到您的项目中。它是一个第三方工具，可让您开发组件，并与您的应用程序隔离，查看所有状态。 A storybook can also be deployed as a static app. This way, everyone in your team can view and review different states of UI components without starting a backend server or creating an account in your app. 故事书也可以作为静态应用程序部署。这样，您的团队中的每个人都可以查看和查看UI组件的不同状态，而无需启动后端服务器或在应用程序中创建一个帐户。 Setup your app with StorybookFirst, install the following npm package globally: 首先，全局安装以下npm软件包： 1npm install -g @storybook/cli Then, run the following command inside your app’s directory: 然后，在你的应用程序的目录中运行以下命令： 1getstorybook After that, follow the instructions on the screen. 之后，请按照屏幕上的说明进行操作。 Learn more about React Storybook: 了解更多关于React Storybook： Screencast: Getting Started with React Storybook GitHub Repo Documentation Snapshot Testing with React Storybook Making a Progressive Web App制作一个渐进的Web应用程序By default, the production build is a fully functional, offline-first Progressive Web App. 默认情况下，生产构建的是一个功能齐全的离线优先的渐进式的Web应用程序。 Progressive Web Apps are faster and more reliable than traditional web pages, and provide an engaging mobile experience: 渐进式Web应用程序比传统网页更快，更可靠，并提供引人入胜的移动体验： All static site assets are cached so that your page loads fast on subsequent visits, regardless of network connectivity (such as 2G or 3G). Updates are downloaded in the background. 所有静态网站资源均被缓存，无论网络连接是2G还是3G，您的网页在后续访问中都能快速加载。更新在后台下载。 Your app will work regardless of network state, even if offline. This means your users will be able to use your app at 10,000 feet and on the Subway. 无论网络状态如何，您的应用都会工作，即使离线。这意味着您的用户将能够在10,000英尺外的地铁上使用您的应用程序。 On mobile devices, your app can be added directly to the user’s home screen, app icon and all. You can also re-engage users using web push notifications. This eliminates the need for the app store. 在移动设备上，您的应用程序可以将应用程序图标和其他所有的东西直接添加到用户的主屏幕。您也可以使用网络推送通知重新吸引用户。这样就省去了应用商店的需要。 The sw-precache-webpack-plugin is integrated into production configuration,and it will take care of generating a service worker file that will automatically precache all of your local assets and keep them up to date as you deploy updates. The service worker will use a cache-first strategy for handling all requests for local assets, including the initial HTML, ensuring that you web app is reliably fast, even on a slow or nreliable network. sw-precache-webpack-plugin 被集成到生产配置中，它将负责生成一个服务工作者文件，它将自动预处理所有本地资源，并在部署更新时保持最新状态。服务工作者将使用缓存优先策略来处理本地资源的所有请求，包括初始HTML，确保您的Web应用程序可靠地快速运行，即使在较慢或不可靠的网络中。 If you would prefer not to enable service workers prior to your initial production deployment, then remove the call to serviceWorkerRegistration.register() from src/index.js. 如果您不希望在初始生产部署之前启用服务工作者，请从 src/index.js中删除对 serviceWorkerRegistration.register()的调用。 If you had previously enabled service workers in your production deployment and have decided that you would like to disable them for all your existing users, you can swap out the call to serviceWorkerRegistration.register() in src/index.js with a call to serviceWorkerRegistration.unregister(). After the user visits a page that has serviceWorkerRegistration.unregister(), the service worker will be uninstalled. 如果您之前已经在生产部署中启用了服务工作者，并且已经决定要对所有现有用户禁用它们，您可以通过调用serviceWorkerRegistration.unregister()将 src/index.js 中调用的serviceWorkerRegistration.register()换掉。用户访问具有serviceWorkerRegistration.unregister()的页面后，服务工作者将被卸载。 Offline-First Considerations离线优先注意事项 Service workers require HTTPS,although to facilitate local testing, that policydoes not apply to localhost.If your production web server does not support HTTPS, then the service workerregistration will fail, but the rest of your web app will remain functional. 服务工作者需要HTTPS，尽管为了方便本地测试，但该策略不适用于localhost。如果您的生产Web服务器不支持HTTPS，则服务工作者注册将失败，但您的Web应用程序的其余部分将保持有效。 Service workers are not currently supportedin all web browsers. Service worker registration won’t be attemptedon browsers that lack support. 所有网络浏览器目前不支持服务工作者。在缺乏支持的浏览器上不会尝试服务工作者的注册。 The service worker is only enabled in the production environment,e.g. the output of npm run build. It’s recommended that you do not enable anoffline-first service worker in a development environment, as it can lead tofrustration when previously cached assets are used and do not include the latestchanges you’ve made locally. 服务工作者只能在生产环境中启用，例如npm run build的输出。建议您不要在开发环境中启用离线优先的服务工作者，因为在使用先前的缓存资源时可能会导致失败，并且不包括您在本地进行的最新更改。 If you need to test your offline-first service worker locally, buildthe application (using npm run build) and run a simple http server from yourbuild directory. After running the build script, create-react-app will giveinstructions for one way to test your production build locally and the deployment instructions haveinstructions for using other methods. *Be sure to always use anincognito window to avoid complications with your browser cache. 如果您需要在本地测试您的离线优先的服务工作者，请构建应用程序（使用 npm run build），并从构建目录运行简单的http服务器。运行构建脚本后，create-react-app将给出本地测试生产环境的一种方法的说明，部署说明有使用其他方法的说明。 If possible, configure your production environment to serve the generatedservice-worker.js with HTTP caching disabled.If that’s not possible—GitHub Pages, for instance, does notallow you to change the default 10 minute HTTP cache lifetime—then be awarethat if you visit your production site, and then revisit again beforeservice-worker.js has expired from your HTTP cache, you’ll continue to getthe previously cached assets from the service worker. If you have an immediateneed to view your updated production deployment, performing a shift-refreshwill temporarily disable the service worker and retrieve all assets from thenetwork. 如果可能，请配置您的生产环境，以便为禁用HTTP缓存的生成的service-worker.js提供服务。如果这是不可能的 - 例如，GitHub Pages不允许您更改默认的10分钟HTTP缓存生命周期 - 然后请注意，如果您访问生产站点，然后在service-worker.js从HTTP缓存过期之前重新访问，您将继续从服务工作者获取先前缓存的资产。如果您立即需要查看更新的生产部署，执行班次刷新将暂时禁用服务工作者并从网络中检索所有资源。 Users aren’t always familiar with offline-first web apps. It can be useful tolet the user knowwhen the service worker has finished populating your caches (showing a “This webapp works offline!” message) and also let them know when the service worker hasfetched the latest updates that will be available the next time they load thepage (showing a “New content is available; please refresh.” message). Showingthis messages is currently left as an exercise to the developer, but as astarting point, you can make use of the logic included in src/registerServiceWorker.js, whichdemonstrates which service worker lifecycle events to listen for to detect eachscenario, and which as a default, just logs appropriate messages to theJavaScript console. 用户并不总是熟悉离线优先的网络应用程序。让用户知道服务工作者何时完成填充缓存（显示“此Web应用程序脱机工作”消息），并让他们知道服务工作者在获取下次加载页面时可用的最新更新（显示“新内容可用;请刷新”消息）。显示此消息目前作为开发人员的练习，但作为起点，您可以使用 src/registerServiceWorker.js中包含的逻辑，这表明哪些服务工作者生命周期事件要监听以检测每个场景，默认情况下，只需将适当的消息记录到JavaScript控制台。 By default, the generated service worker file will not intercept or cache anycross-origin traffic, like HTTP API requests,images, or embeds loaded from a different domain. If you would like to use aruntime caching strategy for those requests, you can ejectand then configure theruntimeCachingoption in the SWPrecacheWebpackPlugin section ofwebpack.config.prod.js. 默认情况下，生成的服务工作者文件将不会拦截或缓存任何跨原始流量，如HTTP API请求，图像或从其他域加载的嵌入。如果要对这些请求使用运行时缓存策略，可以弹出并在webpack.config.prod.js的SWPrecacheWebpackPlugin部分中配置runtimeCaching选项。 Progressive Web App Metadata渐进式Web应用程序元数据The default configuration includes a web app manifest located at public/manifest.json, that you can customize with details specific to your web application. 默认配置包括位于public/manifest.json的Web应用程序清单，您可以使用特定于Web应用程序的详细信息进行自定义。 When a user adds a web app to their homescreen using Chrome or Firefox on Android, the metadata in manifest.json determines what icons, names, and branding colors to use when the web app is displayed.The Web App Manifest guide provides more context about what each field means, and how your customizations will affect your users’ experience. 当用户在Android上使用Chrome或Firefox添加网页应用程序到主屏幕时，manifest.json 中的元数据决定了在显示Web应用程序时要使用的图标，名称和品牌颜色。Web App清单指南 提供了关于每个字段意味着什么的更多上下文信息，以及您的自定义将如何影响用户的体验。 Deployment部署npm run build creates a build directory with a production build of your app. Set up your favourite HTTP server so that a visitor to your site is served index.html, and requests to static paths like /static/js/main.&lt;hash&gt;.js are served with the contents of the /static/js/main.&lt;hash&gt;.js file. npm run build 使用您的应用程序的生产构建创建了一个 build 目录。设置您最喜欢的HTTP服务器，以便为您的站点的访问者提供index.html，并且静态路径（如/static/js/main.&lt;hash&gt;.js）的请求将与 /static/js/main.&lt;hash&gt;.js 的内容一起提供。 Static Server静态服务器For environments using Node, the easiest way to handle this would be to install serve and let it handle the rest: 对于使用Node的环境，处理这种情况的最简单的方法是安装服务并让其处理其余部分： 12npm install -g serveserve -s build The last command shown above will serve your static site on the port 5000. Like many of serve’s internal settings, the port can be adjusted using the -p or --port flags. 上面显示的最后一个命令将为端口5000上的静态站点提供服务。像许多服务的内部设置一样，可以使用-p或–port标志调整端口。 Run this command to get a full list of the options available: 运行此命令以获取可用选项的完整列表： 1serve -h Other Solutions其他解决方案You don’t necessarily need a static server in order to run a Create React App project in production. It works just as fine integrated into an existing dynamic one. 您不一定需要静态服务器才能在生产中运行Create React App项目。它的工作原理同样适用于现有的动态应用程序。 Here’s a programmatic example using Node and Express: 以下是使用Node和Express的编程示例： 1234567891011const express = require('express');const path = require('path');const app = express();app.use(express.static(path.join(__dirname, 'build')));app.get('/', function (req, res) &#123; res.sendFile(path.join(__dirname, 'build', 'index.html'));&#125;);app.listen(9000); The choice of your server software isn’t important either. Since Create React App is completely platform-agnostic, there’s no need to explicitly use Node. 您的服务器软件的选择也不重要。由于Create React App完全与平台无关，因此无需明确使用Node。 The build folder with static assets is the only output produced by Create React App. 具有静态资源的 build 文件夹是由Create React App生成的唯一输出。 However this is not quite enough if you use client-side routing. Read the next section if you want to support URLs like /todos/42 in your single-page app. 但是，如果您使用客户端路由，这还不够。如果您希望在单页应用程序中支持像 /todos/42 这样的URL，请阅读下一节。 Serving Apps with Client-Side Routing使用客户端路由服务应用程序If you use routers that use the HTML5 pushState history API under the hood (for example, React Router with browserHistory), many static file servers will fail. For example, if you used React Router with a route for /todos/42, the development server will respond to localhost:3000/todos/42 properly, but an Express serving a production build as above will not. 如果您使用的是使用HTML5 pushState history API 的路由器（例如，使用browserHistory的React Router ），则许多静态文件服务器将失败。例如，如果您使用React Router作为/todos/42的路由，则开发服务器将正确响应localhost:3000/todos/42，但是Express将不会像上面所述那样服务于生产构建。 This is because when there is a fresh page load for a /todos/42, the server looks for the file build/todos/42 and does not find it. The server needs to be configured to respond to a request to /todos/42 by serving index.html. For example, we can amend our Express example above to serve index.html for any unknown paths: 这是因为当访问/todos/42有一个新的页面加载时，服务器查找文件build/todos/42，却找不到它。服务器需要配置为通过提供｀index.html｀来响应/todos/42的请求。例如，我们可以修改我们上面的Express示例，为任何未知路径提供index.html： 123456 app.use(express.static(path.join(__dirname, 'build')));-app.get('/', function (req, res) &#123;+app.get('/*', function (req, res) &#123; res.sendFile(path.join(__dirname, 'build', 'index.html')); &#125;); If you’re using Apache, you need to create a .htaccess file in the public folder that looks like this: 如果您使用Apache，则需要在public文件夹中创建一个.htaccess文件，如下所示： 1234Options -MultiViewsRewriteEngine OnRewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteRule ^ index.html [QSA,L] It will get copied to the build folder when you run npm run build. 运行 npm run build时，它将被复制到 build 文件夹。 Now requests to /todos/42 will be handled correctly both in development and in production. 现在，对 /todos/42 的请求将在开发和生产中都被正确处理。 On a production build, and in a browser that supports service workers, the service worker will automatically handle all navigation requests, like for /todos/42, by serving the cached copy of your index.html. Thisservice worker navigation routing can be configured or disabled by ejecting and then modifying the navigateFallback and navigateFallbackWhitelist options of the SWPreachePlugin configuration. 在生产构建中，在支持服务工作者的浏览器中，服务工作者将自动处理所有导航请求，像/todos/42,通过提供index.html的缓存副本。可以通过 ejecting 配置或禁用此服务工作者导航路由，然后修改SWPreachePlugin配置的navigateFallback和navigateFallbackWhitelist选项。 Building for Relative Paths相对路径建设By default, Create React App produces a build assuming your app is hosted at the server root.To override this, specify the homepage in your package.json, for example: 默认情况下，Create React App 会生成一个构建，假设您的应用程序是托管在服务器根目录下。 要覆盖它，请指定package.json中的homepage，例如： 1"homepage": "http://mywebsite.com/relativepath", This will let Create React App correctly infer the root path to use in the generated HTML file. 这将使Create React App正确地推断在生成的HTML文件中使用的根路径。 Serving the Same Build from Different Paths从不同的路径服务于同一构建 Note: this feature is available with `react-scripts@0.9.0` and higher. 注意：此功能可用在react-scripts@0.9.0及更高版本。 If you are not using the HTML5 pushState history API or not using client-side routing at all, it is unnecessary to specify the URL from which your app will be served. Instead, you can put this in your package.json: 如果您没有使用HTML5 pushState历史API，或者根本不使用客户端路由，则无需指定您的应用程式将被送达的URL。相反，你可以把它放在你的package.json中： 1"homepage": ".", This will make sure that all the asset paths are relative to index.html. You will then be able to move your app from http://mywebsite.com to http://mywebsite.com/relativepath or even http://mywebsite.com/relative/path without having to rebuild it. 这将确保所有资产路源都相对于index.html。然后，您可以将您的应用程序从http://mywebsite.com移动到http://mywebsite.com/relativepath或http://mywebsite.com/relative/path，而无需重新构建它。 AzureSee this blog post on how to deploy your React app to Microsoft Azure. 请参阅此博文 ，了解如何将React应用程序部署到 Microsoft Azure。 FirebaseInstall the Firebase CLI if you haven’t already by running npm install -g firebase-tools. Sign up for a Firebase account and create a new project. Run firebase login and login with your previous created Firebase account. Then run the firebase init command from your project’s root. You need to choose the Hosting: Configure and deploy Firebase Hosting sites and choose the Firebase project you created in the previous step. You will need to agree with database.rules.json being created, choose build as the public directory, and also agree to Configure as a single-page app by replying with y. 1234567891011121314151617181920212223242526272829303132=== Project SetupFirst, let's associate this project directory with a Firebase project.You can create multiple project aliases by running firebase use --add,but for now we'll just set up a default project.? What Firebase project do you want to associate as default? Example app (example-app-fd690)=== Database SetupFirebase Realtime Database Rules allow you to define how your data should bestructured and when your data can be read from and written to.? What file should be used for Database Rules? database.rules.json✔ Database Rules for example-app-fd690 have been downloaded to database.rules.json.Future modifications to database.rules.json will update Database Rules when you runfirebase deploy.=== Hosting SetupYour public directory is the folder (relative to your project directory) thatwill contain Hosting assets to uploaded with firebase deploy. If youhave a build process for your assets, use your build's output directory.? What do you want to use as your public directory? build? Configure as a single-page app (rewrite all urls to /index.html)? Yes✔ Wrote build/index.htmli Writing configuration info to firebase.json...i Writing project information to .firebaserc...✔ Firebase initialization complete! Now, after you create a production build with npm run build, you can deploy it by running firebase deploy. 12345678910111213=== Deploying to 'example-app-fd690'...i deploying database, hosting✔ database: rules ready to deploy.i hosting: preparing build directory for upload...Uploading: [============================== ] 75%✔ hosting: build folder uploaded successfully✔ hosting: 8 files uploaded successfullyi starting release process (may take several minutes)...✔ Deploy complete!Project Console: https://console.firebase.google.com/project/example-app-fd690/overviewHosting URL: https://example-app-fd690.firebaseapp.com For more information see Add Firebase to your JavaScript Project. GitHub Pages Note: this feature is available with `react-scripts@0.2.0` and higher. 注意：此功能可用在react-scripts@0.2.0及更高版本。 Step 1: Add homepage to package.jsonThe step below is important!If you skip it, your app will not deploy correctly. Open your package.json and add a homepage field: 1"homepage": "https://myusername.github.io/my-app", Create React App uses the homepage field to determine the root URL in the built HTML file. Step 2: Install gh-pages and add deploy to scripts in package.jsonNow, whenever you run npm run build, you will see a cheat sheet with instructions on how to deploy to GitHub Pages. To publish it at https://myusername.github.io/my-app, run: 1npm install --save-dev gh-pages Add the following scripts in your package.json: 123456// ..."scripts": &#123; // ... "predeploy": "npm run build", "deploy": "gh-pages -d build"&#125; The predeploy script will run automatically before deploy is run. Step 3: Deploy the site by running npm run deployThen run: 1npm run deploy Step 4: Ensure your project’s settings use gh-pagesFinally, make sure GitHub Pages option in your GitHub project settings is set to use the gh-pages branch: Step 5: Optionally, configure the domainYou can configure a custom domain with GitHub Pages by adding a CNAME file to the public/ folder. Notes on client-side routingGitHub Pages doesn’t support routers that use the HTML5 pushState history API under the hood (for example, React Router using browserHistory). This is because when there is a fresh page load for a url like http://user.github.io/todomvc/todos/42, where /todos/42 is a frontend route, the GitHub Pages server returns 404 because it knows nothing of /todos/42. If you want to add a router to a project hosted on GitHub Pages, here are a couple of solutions: You could switch from using HTML5 history API to routing with hashes. If you use React Router, you can switch to hashHistory for this effect, but the URL will be longer and more verbose (for example, http://user.github.io/todomvc/#/todos/42?_k=yknaj). Read more about different history implementations in React Router. Alternatively, you can use a trick to teach GitHub Pages to handle 404 by redirecting to your index.html page with a special redirect parameter. You would need to add a 404.html file with the redirection code to the build folder before deploying your project, and you’ll need to add code handling the redirect parameter to index.html. You can find a detailed explanation of this technique in this guide. HerokuUse the Heroku Buildpack for Create React App.You can find instructions in Deploying React with Zero Configuration. Resolving Heroku Deployment ErrorsSometimes npm run build works locally but fails during deploy via Heroku. Following are the most common cases. “Module not found: Error: Cannot resolve ‘file’ or ‘directory’”If you get something like this: 123remote: Failed to create a production build. Reason:remote: Module not found: Error: Cannot resolve &apos;file&apos; or &apos;directory&apos;MyDirectory in /tmp/build_1234/src It means you need to ensure that the lettercase of the file or directory you import matches the one you see on your filesystem or on GitHub. This is important because Linux (the operating system used by Heroku) is case sensitive. So MyDirectory and mydirectory are two distinct directories and thus, even though the project builds locally, the difference in case breaks the import statements on Heroku remotes. “Could not find a required file.”If you exclude or ignore necessary files from the package you will see a error similar this one: 123456remote: Could not find a required file.remote: Name: `index.html`remote: Searched in: /tmp/build_a2875fc163b209225122d68916f1d4df/publicremote:remote: npm ERR! Linux 3.13.0-105-genericremote: npm ERR! argv &quot;/tmp/build_a2875fc163b209225122d68916f1d4df/.heroku/node/bin/node&quot; &quot;/tmp/build_a2875fc163b209225122d68916f1d4df/.heroku/node/bin/npm&quot; &quot;run&quot; &quot;build&quot; In this case, ensure that the file is there with the proper lettercase and that’s not ignored on your local .gitignore or ~/.gitignore_global. ModulusSee the Modulus blog post on how to deploy your react app to Modulus. NetlifyTo do a manual deploy to Netlify’s CDN: 12npm install netlify-clinetlify deploy Choose build as the path to deploy. To setup continuous delivery: With this setup Netlify will build and deploy when you push to git or open a pull request: Start a new netlify project Pick your Git hosting service and select your repository Click Build your site Support for client-side routing: To support pushState, make sure to create a public/_redirects file with the following rewrite rules: 1/* /index.html 200 When you build the project, Create React App will place the public folder contents into the build output. Nownow offers a zero-configuration single-command deployment. You can use now to deploy your app for free. Install the now command-line tool either via the recommended desktop tool or via node with npm install -g now. Build your app by running npm run build. Move into the build directory by running cd build. Run now --name your-project-name from within the build directory. You will see a now.sh URL in your output like this: 1&gt; Ready! https://your-project-name-tpspyhtdtk.now.sh (copied to clipboard) Paste that URL into your browser when the build is complete, and you will see your deployed app. Details are available in this article. S3 and CloudFrontSee this blog post on how to deploy your React app to Amazon Web Services S3 and CloudFront. SurgeInstall the Surge CLI if you haven’t already by running npm install -g surge. Run the surge command and log in you or create a new account. When asked about the project path, make sure to specify the build folder, for example: 1project path: /path/to/project/build Note that in order to support routers that use HTML5 pushState API, you may want to rename the index.html in your build folder to 200.html before deploying to Surge. This ensures that every URL falls back to that file. Advanced ConfigurationYou can adjust various development and production settings by setting environment variables in your shell or with .env. Variable Development Production Usage BROWSER :white_check_mark: :x: By default, Create React App will open the default system browser, favoring Chrome on macOS. Specify a browser to override this behavior, or set it to none to disable it completely. If you need to customize the way the browser is launched, you can specify a node script instead. Any arguments passed to npm start will also be passed to this script, and the url where your app is served will be the last argument. Your script’s file name must have the .js extension. HOST :white_check_mark: :x: By default, the development web server binds to localhost. You may use this variable to specify a different host. PORT :white_check_mark: :x: By default, the development web server will attempt to listen on port 3000 or prompt you to attempt the next available port. You may use this variable to specify a different port. HTTPS :white_check_mark: :x: When set to true, Create React App will run the development server in https mode. PUBLIC_URL :x: :white_check_mark: Create React App assumes your application is hosted at the serving web server’s root or a subpath as specified in package.json (homepage). Normally, Create React App ignores the hostname. You may use this variable to force assets to be referenced verbatim to the url you provide (hostname included). This may be particularly useful when using a CDN to host your application. CI :large_orange_diamond: :white_check_mark: When set to true, Create React App treats warnings as failures in the build. It also makes the test runner non-watching. Most CIs set this flag by default. Troubleshootingnpm start doesn’t detect changesWhen you save a file while npm start is running, the browser should refresh with the updated code.If this doesn’t happen, try one of the following workarounds: If your project is in a Dropbox folder, try moving it out. If the watcher doesn’t see a file called index.js and you’re referencing it by the folder name, you need to restart the watcher due to a Webpack bug. Some editors like Vim and IntelliJ have a “safe write” feature that currently breaks the watcher. You will need to disable it. Follow the instructions in “Adjusting Your Text Editor”. If your project path contains parentheses, try moving the project to a path without them. This is caused by a Webpack watcher bug. On Linux and macOS, you might need to tweak system settings to allow more watchers. If the project runs inside a virtual machine such as (a Vagrant provisioned) VirtualBox, create an .env file in your project directory if it doesn’t exist, and add CHOKIDAR_USEPOLLING=true to it. This ensures that the next time you run npm start, the watcher uses the polling mode, as necessary inside a VM. If none of these solutions help please leave a comment in this thread. npm test hangs on macOS SierraIf you run npm test and the console gets stuck after printing react-scripts test --env=jsdom to the console there might be a problem with your Watchman installation as described in facebookincubator/create-react-app#713. We recommend deleting node_modules in your project and running npm install (or yarn if you use it) first. If it doesn’t help, you can try one of the numerous workarounds mentioned in these issues: facebook/jest#1767 facebook/watchman#358 ember-cli/ember-cli#6259 It is reported that installing Watchman 4.7.0 or newer fixes the issue. If you use Homebrew, you can run these commands to update it: 123watchman shutdown-serverbrew updatebrew reinstall watchman You can find other installation methods on the Watchman documentation page. If this still doesn’t help, try running launchctl unload -F ~/Library/LaunchAgents/com.github.facebook.watchman.plist. There are also reports that uninstalling Watchman fixes the issue. So if nothing else helps, remove it from your system and try again. npm run build silently failsIt is reported that npm run build can fail on machines with no swap space, which is common in cloud environments. If the symptoms are matching, consider adding some swap space to the machine you’re building on, or build the project locally. npm run build fails on HerokuThis may be a problem with case sensitive filenames.Please refer to this section. Moment.js locales are missingIf you use a Moment.js, you might notice that only the English locale is available by default. This is because the locale files are large, and you probably only need a subset of all the locales provided by Moment.js. To add a specific Moment.js locale to your bundle, you need to import it explicitly.For example: 12import moment from 'moment';import 'moment/locale/fr'; If import multiple locales this way, you can later switch between them by calling moment.locale() with the locale name: 1234567import moment from 'moment';import 'moment/locale/fr';import 'moment/locale/es';// ...moment.locale('fr'); This will only work for locales that have been explicitly imported before. Something Missing?If you have ideas for more “How To” recipes that should be on this page, let us know or contribute some!]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React Navigation 中文]]></title>
    <url>%2F2017%2F06%2F18%2Freact-navigation-index%2F</url>
    <content type="text"><![CDATA[Getting Started 你好移动导航(Hello Mobile Navigation) 嵌套导航器(Nesting Navigators) 配置标题栏(Configuring the Header) Navigators 介绍导航器(Intro to Navigators) 栈导航器(StackNavigator) 标签导航器(TabNavigator) 抽屉导航器(DrawerNavigator) 屏幕导航属性(Screen Navigation Prop) 导航动作(Navigation Actions) 屏幕导航选项(Screen Navigation Options) 自定义导航器(Custom Navigators) Advanced Guides Redux集成(Redux Integration) Web集成(Web Integration) 深链接(Deep Linking) 屏幕追踪(Screen Tracking) 贡献者(Contributors) Routers 路由器(Routers) 自定义路由API(Custom Router API) 栈路由(StackRouter) 标签路由(TabRouter) Views 导航视图(Navigation Views) 转变器(Transitioner)]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Transitioner]]></title>
    <url>%2F2017%2F06%2F17%2Ftransitioner%2F</url>
    <content type="text"><![CDATA[Transitioner is a React component that helps manage transitions for complex animated components. It manages the timing of animations and keeps track of various screens as they enter and leave, but it doesn’t know what anything looks like, because rendering is entirely deferred to the developer. Under the covers, Transitioner is used to implement CardStack, and hence the StackNavigator. The most useful thing Transitioner does is to take in a prop of the current navigation state. When routes are removed from that navigation state, Transitioner will coordinate the transition away from those routes, keeping them on screen even though they are gone from the navigation state. Example12345678910111213class MyNavView extends Component &#123; ... render() &#123; return ( &lt;Transitioner configureTransition=&#123;this._configureTransition&#125; navigation=&#123;this.props.navigation&#125; render=&#123;this._render&#125; onTransitionStart=&#123;this.onTransitionStart&#125; onTransitionEnd=&#123;this.onTransitionEnd&#125; /&gt; );&#125; PropsconfigureTransition functionInvoked on Transitioner.componentWillReceiveProps, this function allows customization of animation parameters such as duration. The value returned from this function will be fed into a timing function, by default Animated.timing(), as its config. Examples12345678_configureTransition(transitionProps, prevTransitionProps) &#123; return &#123; // duration in milliseconds, default: 250 duration: 500, // An easing function from `Easing`, default: Easing.inOut(Easing.ease) easing: Easing.bounce, &#125;&#125; Note: duration and easing are only applicable when the timing function is Animated.timing. We can also use a different timing function and its corresponding config parameters, like so: 123456789_configureTransition(transitionProps, prevTransitionProps) &#123; return &#123; // A timing function, default: Animated.timing. timing: Animated.spring, // Some parameters relevant to Animated.spring friction: 1, tension: 0.5, &#125;&#125; Flow definition1234configureTransition: ( transitionProps: NavigationTransitionProps, prevTransitionProps: ?NavigationTransitionProps,) =&gt; NavigationTransitionSpec, Parameters transitionProps: the current NavigationTransitionProps created from the current navigation state and props prevTransitionProps: the previous NavigationTransitionProps created from the previous navigation state and props Returns An object of type NavigationTransitionSpec that will be fed into an Animated timing function as its config navigation propAn object with state that represents the navigation state, with routes and an active route index. Also includes dispatch and other methods for requesting actions. Example value12345678&#123; // Index refers to the active child route in the routes array. index: 1, routes: [ &#123; key: 'DF2FGWGAS-12', routeName: 'ContactHome' &#125;, &#123; key: 'DF2FGWGAS-13', routeName: 'ContactDetail', params: &#123; personId: 123 &#125; &#125; ]&#125; Flow definition1234export type NavigationState = &#123; index: number, routes: Array&lt;NavigationRoute&gt;,&#125;; For more information about the NavigationRoute type, check out its flow definition. render functionInvoked from Transitioner.render(). This function performs the actual rendering delegated from Transitioner. In this function, we can use the information included in the transitionProps and prevTransitionProps parameters to render scenes, create animations and handle gestures. There are a few important properties of the transitionProps and prevTransitionProps parameters that are useful for the tasks mentioned above: scenes: Array&lt;NavigationScene&gt; - a list of all available scenes position: NavigationAnimatedValue - the progressive index of the transitioner’s navigation state progress: NavigationAnimatedValue - the value that represents the progress of the transition when navigation state changes from one to another. Its numberic value will range from 0 to 1. For the complete list of properties of NavigationTransitionProps, check out its flow definition. ExamplestransitionProps.scenes is the list of all available scenes. It is up to the implementor to determine how to lay them out on the screen. For example, we can render the scenes as a stack of cards like so: 12345678_render(transitionProps, prevTransitionProps) &#123; const scenes = transitionProps.scenes.map(scene =&gt; this._renderScene(transitionProps, scene)); return ( &lt;View style=&#123;styles.stack&#125;&gt; &#123;scenes&#125; &lt;/View&gt; );&#125; We can then use an Animated.View to animate the transition. To create necessary animated style properties, such as opacity, we can interpolate on position and progress values that come with transitionProps: 123456789101112131415_renderScene(transitionProps, scene) &#123; const &#123; position &#125; = transitionProps; const &#123; index &#125; = scene; const opacity = position.interpolate(&#123; inputRange: [index-1, index, index+1], outputRange: [0, 1, 0], &#125;); // The prop `router` is populated when we call `createNavigator`. const Scene = this.props.router.getComponent(scene.route.routeName); return ( &lt;Animated.View style=&#123;&#123; opacity &#125;&#125;&gt; &#123; Scene &#125; &lt;/Animated.View&gt; )&#125; The above code creates a cross fade animation during transition. For a comprehensive tutorial on how to create custom transitions, see this blog post. Flow definition1render: (transitionProps: NavigationTransitionProps, prevTransitionProps: ?NavigationTransitionProps) =&gt; React.Element&lt;*&gt;, Parameters transitionProps: the current NavigationTransitionProps created from the current state and props prevTransitionProps: the previous NavigationTransitionProps created from the previous state and props Returns A ReactElement, which will be used to render the Transitioner component onTransitionStart functionInvoked when the transition animation is about to start. Flow definition1onTransitionStart: (transitionProps: NavigationTransitionProps, prevTransitionProps: ?NavigationTransitionProps) =&gt; void, Parameters transitionProps: the current NavigationTransitionProps created from the current state and props prevTransitionProps: the previous NavigationTransitionProps created from the previous state and props Returns none. onTransitionEnd functionInvoked once the transition animation completes. Flow definition1onTransitionEnd: () =&gt; void Parameters none. Returns none.]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Views]]></title>
    <url>%2F2017%2F06%2F16%2Fnavigation-views%2F</url>
    <content type="text"><![CDATA[Navigation views are presentation components that take a router and a navigation prop, and can display several screens, as specified by the navigation.state. Navigation views are controlled React components that can present the current navigation state. They manage switching of screens, animations and gestures. They also present persistent navigation views such as tab bars and headers. Built in Views CardStack - Present a stack that looks suitable on any platform Card - Present one card from the card stack, with gestures Header - The header view for the card stack Tabs - A configurable tab switcher / pager Drawer - A view with a drawer that slides from the left TransitionerTransitioner manages the animations during the transition and can be used to build fully custom navigation views. It is used inside the CardStack view. Learn more about Transitioner here.]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TabRouter]]></title>
    <url>%2F2017%2F06%2F15%2Ftab-router%2F</url>
    <content type="text"><![CDATA[Manage a set of tabs in the application, handle jumping to tabs, and handle the back button press to jump to the initial tab. Let’s take a look at a simple tabs router: 123456const MyApp = TabRouter(&#123; Home: &#123; screen: HomeScreen &#125;, Settings: &#123; screen: SettingsScreen &#125;,&#125;, &#123; initialRouteName: 'Home',&#125;) RouteConfigA tabs router has a routeConfig for each possible tab: 1234567891011121314const MyApp = TabRouter(&#123; // This is the RouteConfig: Home: &#123; screen: HomeScreen, path: 'main', &#125;, Settings: &#123; // This can be handy to lazily require a tab: getScreen: () =&gt; require('./SettingsScreen').default, // Note: Child navigators cannot be configured using getScreen because // the router will not be accessible. Navigators must be configured // using `screen: MyNavigator` path: 'settings', &#125;,&#125;); Each item in the config may have the following: path - Specify the path for each tab screen - Specify the screen component or child navigator getScreen - Set a lazy getter for a screen component (but not navigators) Tab Router ConfigConfig options that are also passed to the router. initialRouteName - The routeName for the initial tab route when first loading order - Array of routeNames which defines the order of the tabs paths - Provide a mapping of routeName to path config, which overrides the paths set in the routeConfigs. backBehavior - Should the back button cause a tab switch to the initial tab? If yes, set to initialRoute, otherwise none. Defaults to initialRoute behavior. Supported ActionsThe tabs router may respond to the following navigation actions. The router will generally delegate the action handling to a child router, if possible. Navigate - Will jump to the routeName if it matches a tab Back - Goes to the first tab, if not already selected SetParams - An action that a screen dispatches to change the params of the current route.]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[StackRouter]]></title>
    <url>%2F2017%2F06%2F14%2Fstack-router%2F</url>
    <content type="text"><![CDATA[Manage the logical navigation stack, including pushing, popping, and handling path parsing to create a deep stack. Let’s take a look at a simple stack router: 123456const MyApp = StackRouter(&#123; Home: &#123; screen: HomeScreen &#125;, Profile: &#123; screen: ProfileScreen &#125;,&#125;, &#123; initialRouteName: 'Home',&#125;) RouteConfigA basic stack router expects a route config object. Here is an example configuration: 123456789101112131415161718const MyApp = StackRouter(&#123; // This is the RouteConfig: Home: &#123; screen: HomeScreen, path: '', &#125;, Profile: &#123; screen: ProfileScreen, path: 'profile/:name', &#125;, Settings &#123; // This can be handy to lazily require a screen: getScreen: () =&gt; require('Settings').default, // Note: Child navigators cannot be configured using getScreen because // the router will not be accessible. Navigators must be configured // using `screen: MyNavigator` path: 'settings', &#125;,&#125;); Each item in the config may have the following: path - Specify the path and params to be parsed for item in the stack screen - Specify the screen component or child navigator getScreen - Set a lazy getter for a screen component (but not navigators) StackConfigConfig options that are also passed to the stack router. initialRouteName - The routeName for the default route when the stack first loads initialRouteParams - Default params of the initial route paths - Provide a mapping of routeName to path config, which overrides the paths set in the routeConfigs. Supported ActionsThe stack router may respond to the following navigation actions. The router will generally delegate the action handling to a child router, if possible. Navigate - Will push a new route on the stack if the routeName matches one of the router’s routeConfigs Back - Goes back (pops) Reset - Clears the stack and provides new actions to create a fully new navigation state SetParams - An action that a screen dispatches to change the params of the current route.]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Custom Router API]]></title>
    <url>%2F2017%2F06%2F13%2Fcustom-routers-api%2F</url>
    <content type="text"><![CDATA[您可以通过构建具有以下功能的对象来创建自己的路由器： 123456789101112131415const MyRouter = &#123; getStateForAction: (action, state) =&gt; (&#123;&#125;), getActionForPathAndParams: (path, params) =&gt; null, getPathAndParamsForState: (state) =&gt; null, getComponentForState: (state) =&gt; MyScreen, getComponentForRouteName: (routeName) =&gt; MyScreen,&#125;;// 现在，您可以通过将路由器放在其上来制作导航器：class MyNavigator extends React.Component &#123; static router = MyRouter; render() &#123; ... &#125;&#125; 路由器api概念图 记住：路由器经常可组合，并可以委托给子路由器 URI Events：应用程序预计将处理的URL，同时也在唤醒或应用程序执行期间 App Actions：在应用程序运行时来自用户的操作行为 Path and Params：relative path and query parameters URI Output：userd for sharing links or displaying updated URI in browser bar Navigation State： a list of routes,and an index that points to an active route State Logging and Persistence：Log user navigation behavior and persist the nav state to disk to restore the deep navigation state after refresh getStateForAction(action, state)Defines the navigation state in response to a given action. This function will be run when an action gets passed into props.navigation.dispatch(, or when any of the helper functions are called, like navigation.navigate(. Typically this should return a navigation state, with the following form: 1234567891011121314151617&#123; index: 1, // identifies which route in the routes array is active routes: [ &#123; // Each route needs a name to identify the type. routeName: &apos;MyRouteName&apos;, // A unique identifier for this route in the routes array: key: &apos;myroute-123&apos;, // (used to specify the re-ordering of routes) // Routes can have any data, as long as key and routeName are correct ...randomRouteData, &#125;, ...moreRoutes, ]&#125; If the router has handled the action externally, or wants to swallow it without changing the navigation state, this function will return null. getComponentForRouteName(routeName)Returns the child component or navigator for the given route name. Say a router getStateForAction outputs a state like this:1234567&#123; index: 1, routes: [ &#123; key: 'A', routeName: 'Foo' &#125;, &#123; key: 'B', routeName: 'Bar' &#125;, ],&#125; Based on the routeNames in the state, the router is responsible for returning valid components when calling router.getComponentForRouteName(&#39;Foo&#39;) or router.getComponentForRouteName(&#39;Bar&#39;). getComponentForState(state)Returns the active component for a deep navigation state. getActionForPathAndParams(path, params)Returns an optional navigation action that should be used when the user navigates to this path and provides optional query parameters. getPathAndParamsForState(state)Returns the path and params that can be put into the URL to link the user back to the same spot in the app. The path/params that are output from this should form an action when passed back into the router’s getActionForPathAndParams. That action should take you to a similar state once passed through getStateForAction. getScreenOptions(navigation, screenProps)Used to retrieve the navigation options for a screen. Must provide the screen’s current navigation prop and optionally, other props that your navigation options may need to consume. navigation - This is the navigation prop that the screen will use, where the state refers to the screen’s route/state. Dispatch will trigger actions in the context of that screen. screenProps - Other props that your navigation options may need to consume navigationOptions - The previous set of options that are default or provided by the previous configurer Inside an example view, perhaps you need to fetch the configured title:12345678// First, prepare a navigation prop for your child, or re-use one if already available.const screenNavigation = addNavigationHelpers(&#123; // In this case we use navigation.state.index because we want the title for the active route. state: navigation.state.routes[navigation.state.index], dispatch: navigation.dispatch,&#125;);const options = this.props.router.getScreenOptions(screenNavigation, &#123;&#125;);const title = options.title;]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[路由器(Routers)]]></title>
    <url>%2F2017%2F06%2F12%2Frouters%2F</url>
    <content type="text"><![CDATA[路由器定义了一个组件的导航状态，并允许开发人员定义可被处理的路径和动作。 内置路由器(Built-In Routers)react-navigation使用的几个标准的路由器： StackRouter TabRouter 使用路由器(Using Routers)要手动导航，请在组件上放置一个静态路由器。(要快速创建一个使用内置组件的导航器，使用一个 Navigator Factory 将其取代可能会更容易) 1234class MyNavigator extends React.Component &#123; static router = StackRouter(routes, config); ...&#125; 现在您可以将此组件用作另一个导航器中的屏幕，而MyNavigator的导航逻辑将由此StackRouter定义。 自定义路由器(Customizing Routers)请参阅自定义路由器API规范了解StackRouter和TabRouter的API。您可以根据需要覆盖路由器的功能： 自定义导航动作(Custom Navigation Actions)要覆盖导航行为，您可以覆盖getStateForAction中的导航状态逻辑，并手动操作 routes 和 index。 123456789101112131415161718192021222324const MyApp = StackNavigator(&#123; Home: &#123; screen: HomeScreen &#125;, Profile: &#123; screen: ProfileScreen &#125;,&#125;, &#123; initialRouteName: 'Home',&#125;)const defaultGetStateForAction = MyApp.router.getStateForAction;MyApp.router.getStateForAction = (action, state) =&gt; &#123; if (state &amp;&amp; action.type === 'PushTwoProfiles') &#123; const routes = [ ...state.routes, &#123;key: 'A', routeName: 'Profile', params: &#123; name: action.name1 &#125;&#125;, &#123;key: 'B', routeName: 'Profile', params: &#123; name: action.name2 &#125;&#125;, ]; return &#123; ...state, routes, index: routes.length - 1, &#125;; &#125; return defaultGetStateForAction(action, state);&#125;; 阻止导航操作(Blocking Navigation Actions)有时您可能希望防止某些导航活动，具体取决于您的路由。 123456789101112131415161718192021const MyStackRouter = StackRouter(&#123; Home: &#123; screen: HomeScreen &#125;, Profile: &#123; screen: ProfileScreen &#125;,&#125;, &#123; initialRouteName: 'Home',&#125;)const defaultGetStateForAction = MyStackRouter.router.getStateForAction;MyStackRouter.router.getStateForAction = (action, state) =&gt; &#123; if ( state &amp;&amp; action.type === NavigationActions.BACK &amp;&amp; state.routes[state.index].params.isEditing ) &#123; // 从getStateForAction返回null表示操作已被处理/阻止，但没有新的状态 return null; &#125; return defaultGetStateForAction(action, state);&#125;; 处理自定义URI(Handling Custom URIs)也许您的应用程序具有内置路由器无法处理的唯一URI. 您可以随时扩展路由器的getActionForPathAndParams。 1234567891011121314151617181920212223242526import &#123; NavigationActions &#125; from 'react-navigation'const MyApp = StackNavigator(&#123; Home: &#123; screen: HomeScreen &#125;, Profile: &#123; screen: ProfileScreen &#125;,&#125;, &#123; initialRouteName: 'Home',&#125;)const previousGetActionForPathAndParams = MyApp.router.getActionForPathAndParams;Object.assign(MyApp.router, &#123; getActionForPathAndParams(path, params) &#123; if (path === 'my/custom/path' &amp;&amp; params.magic === 'yes') &#123; //返回一个profile导航操作 /my/custom/path?magic=yes return NavigationActions.navigate(&#123; routeName: 'Profile', action: NavigationActions.navigate(&#123;//该子操作将被传递给子路由器ProfileScreen.router.getStateForAction以获取子导航状态。 routeName: 'Friends', &#125;), &#125;); &#125; return previousGetActionForPathAndParams(path, params); &#125;,&#125;);]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[贡献者指南(Contributors Guide)]]></title>
    <url>%2F2017%2F06%2F11%2Fcontributors%2F</url>
    <content type="text"><![CDATA[环境(Environment)最初在macOS 10.12上开发了react navigation，其中使用 node 7+ 和 react-native v0.39+。发现不同环境中的问题时请提交issues。 开发(Development)Fork代码库 在Github 上 fork react-navigation 在终端中运行这些命令在本地下载并安装它 1234git clone https://github.com/&lt;USERNAME&gt;/react-navigation.gitcd react-navigationgit remote add upstream https://github.com/react-community/react-navigation.gitnpm install 运行示例应用程序123456789cd examples/NavigationPlaygroundnpm installcd ../..npm start# 在一个单独的终端标签:npm run run-playground-android# 或:npm run run-playground-ios You can also simply run e.g. react-native run-android from within the example app directory (instead of npm run run-playground-android from the root react-navigation directory); both do the same thing. 你也可以在从示例应用程序目录简单地运行(e.g. react-native run-android )，而不是npm run run-playground-android 从react-navigation根目录;因为都做的是同样的事情。 运行网站对于开发模式和实时重新加载： 123cd websitenpm installnpm start 使用服务器渲染以生产模式运行网站： 1npm run prod 运行测试和类型检查12jestflow 您的更改必须测试通过，才能被接受和合并。 流程尚未传递，但您的代码应该被检查，我们期望您的更改不会引入任何错误。 开发文档The docs are indexed in App.js, where all the pages are declared alongside the titles. To test the docs, follow the above instructions for running the website. Changing existing markdown files should not require any testing. The markdown from the docs folder gets generated and dumped into a json file as a part of the build step. To see updated docs appear in the website, re-run the build step by running npm run build-docs from the react-navigation root folder. 提交文稿新视图或独特功能Often navigation needs are specific to certain apps. If your changes are unique to your app, you may want to fork the view or router that has changed. You can keep the source code in your app, or publish it on npm as a react-navigation compatible view or router. This library is intended to include highly standard and generic navigation patterns. 新视图或独特功能Before embarking on any major changes, please file an issue describing the suggested change and motivation. We may already have thought about it and we want to make sure we all are on the same page before starting on any big changes. 新视图或独特功能Simple bug fixes are welcomed in pull requests! Please check for duplicate PRs before posting. 在提交PR之前，确保与上游状态同步： git fetch upstream git rebase upstream/master]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[屏幕跟踪和分析(Screen tracking and analytics)]]></title>
    <url>%2F2017%2F06%2F10%2Fscreen-tracking%2F</url>
    <content type="text"><![CDATA[此示例显示如何进行屏幕跟踪并发送到Google Analytics（分析）。该方法可以适应任何其他移动分析SDK。 屏幕跟踪(Screen tracking)使用内置导航容器时，可以使用 onNavigationStateChange 方法来跟踪屏幕。 123456789101112131415161718192021222324252627282930313233import &#123; GoogleAnalyticsTracker &#125; from 'react-native-google-analytics-bridge';const tracker = new GoogleAnalyticsTracker(GA_TRACKING_ID);// 从导航状态获取当前屏幕function getCurrentRouteName(navigationState) &#123; if (!navigationState) &#123; return null; &#125; const route = navigationState.routes[navigationState.index]; // 潜入嵌套导航仪 if (route.routes) &#123; return getCurrentRouteName(route); &#125; return route.routeName;&#125;const AppNavigator = StackNavigator(AppRouteConfigs);export default () =&gt; ( &lt;AppNavigator onNavigationStateChange=&#123;(prevState, currentState) =&gt; &#123; const currentScreen = getCurrentRouteName(currentState); const prevScreen = getCurrentRouteName(prevState); if (prevScreen !== currentScreen) &#123; // 以下行使用Google Analytics（分析）跟踪器 // 在此更改跟踪器以使用其他移动分析SDK tracker.trackScreenView(currentScreen); &#125; &#125;&#125; /&gt;); 使用Redux进行屏幕跟踪(Screen tracking with Redux)使用Redux时，我们可以编写一个Redux中间件来跟踪屏幕。为此，我们将从上一节重用 getCurrentRouteName 12345678910111213141516171819202122232425import &#123; NavigationActions &#125; from 'react-navigation';import &#123; GoogleAnalyticsTracker &#125; from 'react-native-google-analytics-bridge';const tracker = new GoogleAnalyticsTracker(GA_TRACKING_ID);const screenTracking = (&#123; getState &#125;) =&gt; next =&gt; (action) =&gt; &#123; if ( action.type !== NavigationActions.NAVIGATE &amp;&amp; action.type !== NavigationActions.BACK ) &#123; return next(action); &#125; const currentScreen = getCurrentRouteName(getState().navigation); const result = next(action); const nextScreen = getCurrentRouteName(getState().navigation); if (nextScreen !== currentScreen) &#123; // 以下行使用Google Analytics（分析）跟踪器 // 在此更改跟踪器以使用其他移动分析SDK tracker.trackScreenView(nextScreen); &#125; return result;&#125;;export default screenTracking; 创建 Redux store 并应用上述中间件screenTracking 中间件可以在创建时应用于store。有关详细信息，请参阅Redux 集成。 12345678910const store = createStore( combineReducers(&#123; navigation: navigationReducer, ... &#125;), applyMiddleware( screenTracking, ... ),);]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深度链接(Deep Linking)]]></title>
    <url>%2F2017%2F06%2F09%2Fdeep-linking%2F</url>
    <content type="text"><![CDATA[在本指南中，我们将设置我们的应用程序来处理外部URI。我们先从我们在入门指南中创建的SimpleApp开始。 在这个例子中，我们希望像mychat://chat/Taylor这样的URI打开我们的应用程序，并直接链接到Taylor的聊天页面中。 配置以前我们已经定义了一个这样的导航器： 1234const SimpleApp = StackNavigator(&#123; Home: &#123; screen: HomeScreen &#125;, Chat: &#123; screen: ChatScreen &#125;,&#125;); 我们希望像 chat/Taylor 这样的路径使用 user 作为参数传递并链接到“Chat”屏幕。让我们重新配置我们的聊天屏幕， path 告诉路由器要匹配的相对路径，以及要提取的参数。这个路径规范将是 chat/:user. 1234567const SimpleApp = StackNavigator(&#123; Home: &#123; screen: HomeScreen &#125;, Chat: &#123; screen: ChatScreen, path: 'chat/:user', &#125;,&#125;); URI前缀接下来，让我们配置我们的导航器，从应用程序的传入URI中提取路径。 123456const SimpleApp = StackNavigator(&#123;...&#125;);// 在Android上，除了scheme之外，URI前缀通常包含一个hostconst prefix = Platform.OS == 'android' ? 'mychat://mychat/' : 'mychat://';const MainApp = () =&gt; &lt;SimpleApp uriPrefix=&#123;prefix&#125; /&gt;; iOSLet’s configure the native iOS app to open based on the mychat:// URI scheme. 让我们根据 mychat:// URI scheme来配置原生iOS应用程序并将其打开。 在 SimpleApp/ios/SimpleApp/AppDelegate.m 中: 12345678910// 在文件顶部添加标题:#import &lt;React/RCTLinkingManager.h&gt;// 在上面添加`@end`:- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation&#123; return [RCTLinkingManager application:application openURL:url sourceApplication:sourceApplication annotation:annotation];&#125; 在Xcode中，在 SimpleApp/ios/SimpleApp.xcodeproj下中打开项目。在侧栏中选择项目，然后导航到信息选项卡。向下滚动到”URL Types” 并添加一个。在新的URL类型中，将标识符和url scheme设置为所需的url scheme。 现在你可以按Xcode play，或在命令行重新构建： 1react-native run-ios 要测试模拟器上的URI，请运行以下命令： 1xcrun simctl openurl booted mychat://chat/Taylor 要测试实际设备上的URI，请打开Safari并键入 mychat://chat/Taylor. Android要在Android中配置外部链接，您可以在清单中创建新的意图。 在 SimpleApp/android/app/src/main/AndroidManifest.xml 中,在MainActivity条目中添加新的 VIEW 类型意图过滤器(intent-filter)： 1234567&lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;data android:scheme=&quot;mychat&quot; android:host=&quot;mychat&quot; /&gt;&lt;/intent-filter&gt; 现在，重新安装该应用程序： 1react-native run-android To test the intent handling in Android, run the following: 要测试Android中的意图处理，请运行以下命令： 1adb shell am start -W -a android.intent.action.VIEW -d &quot;mychat://mychat/chat/Taylor&quot; com.simpleapp]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Web集成(Web Integration)]]></title>
    <url>%2F2017%2F06%2F08%2Fweb-integration%2F</url>
    <content type="text"><![CDATA[React导航路由器可以在web上工作，并允许您与本机应用程序共享导航逻辑。目前在 react-navigation 中捆绑的视图目前只适用于React Native，但这可能会与面向未来的项目（如 react-primitives）发生变化。 示例应用程序(Example App)该网站是使用React Navigation构建的，具体使用createNavigator和TabRouter。 在这里查看网站的源代码:App.js. 要了解应用程序如何在服务器上呈现，请参阅Server.js。在浏览器上，App被唤醒并使用BrowserAppContainer.js渲染。 更多即将推出(More Coming Soon)不久之后，本指南将被Web上的react-navigation使用的更彻底的演练所取代。]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redux集成(Redux Integration)]]></title>
    <url>%2F2017%2F06%2F07%2Fredux-Integration%2F</url>
    <content type="text"><![CDATA[要在redux中处理您的应用程序的导航状态，您可以将自己的导航(navigation)属性传递给导航器。您的导航属性必须提供当前状态，以及访问分发者(dispatcher)来处理导航选项。 使用redux，您的应用程序的状态由reducer定义。每个导航路由器实际上都有一个reducer，调用getStateForAction。以下是在redux应用程序中如何使用导航器的小示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import &#123; addNavigationHelpers &#125; from &apos;react-navigation&apos;;const AppNavigator = StackNavigator(AppRouteConfigs);const initialState = AppNavigator.router.getStateForAction(AppNavigator.router.getActionForPathAndParams(&apos;Login&apos;));const navReducer = (state = initialState, action) =&gt; &#123; const nextState = AppNavigator.router.getStateForAction(action, state); // 简单实现：如果`nextState`为null或未定义，则返回原来的`state`. return nextState || state;&#125;;const appReducer = combineReducers(&#123; nav: navReducer, ...&#125;);class App extends React.Component &#123; render() &#123; return ( &lt;AppNavigator navigation=&#123;addNavigationHelpers(&#123; dispatch: this.props.dispatch, state: this.props.nav, &#125;)&#125; /&gt; ); &#125;&#125;const mapStateToProps = (state) =&gt; (&#123; nav: state.nav&#125;);const AppWithNavigationState = connect(mapStateToProps)(App);const store = createStore(appReducer);class Root extends React.Component &#123; render() &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;AppWithNavigationState /&gt; &lt;/Provider&gt; ); &#125;&#125; 一旦你这样做，你的导航状态被存储在您的redux store中，在那时你可以使用redux的分发(dispatch)函数来发送导航动作。 请记住，当导航器获得导航属性时，它放弃对其内部状态的控制。这意味着您现在有责任维护好原有的状态，处理任何深链接，集成后退按钮等。 当您嵌套它们时，导航状态将自动从一个导航器传递到另一个导航器。请注意，为了使子导航器从父导航器接收状态，应将其定义为屏幕(screen)。 将其应用于上述示例，您可以将AppNavigator定义为包含嵌套的TabNavigator，如下所示： 123const AppNavigator = StackNavigator(&#123; Home: &#123; screen: MyTabNavigator &#125;,&#125;); 在这种情况下，在AppWithNavigationState中一旦将AppNavigator连接( connect )到Redux完成时，MyTabNavigator将作为导航属性( navigation prop)自动进入导航状态。 完整的例子(Full example)如果你想自己尝试，这里( here )有一个有redux的工作示例应用程序。 模拟测试(Mocking tests)为了使您的react-navigation应用程序可以进行测试，您需要更改package.json中的jest preset，请参阅： 123456&quot;jest&quot;: &#123; &quot;preset&quot;: &quot;react-native&quot;, &quot;transformIgnorePatterns&quot;: [ &quot;node_modules/(?!(jest-)?react-native|react-navigation)&quot; ]&#125;]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自定义导航器(Custom Navigators)]]></title>
    <url>%2F2017%2F06%2F06%2Fcustom-navigators%2F</url>
    <content type="text"><![CDATA[导航器是具有一个路由器( router )的React组件。下面是一个基本的导航器，它使用路由器的API( router’s API )来获取活动组件进行渲染： 1234567891011121314151617181920class MyNavigator extends React.Component &#123; static router = MyRouter; render() &#123; const &#123; state, dispatch &#125; = this.props.navigation; const &#123; routes, index &#125; = state; // 路由器根据导航状态找出要渲染的内容： const Component = MyRouter.getComponentForState(state); // 活动子屏幕的状态可以在routes [index] let childNavigation = &#123; dispatch, state: routes[index] &#125;; // 如果我们想要，我们也可以修改这里的分发功能来限制或增加我们孩子的行为 // 假设我们的子屏幕想要方便地调用.navigate（） // 我们应该调用addNavigationHelpers来增强我们的导航属性(navigation prop)： childNavigation = addNavigationHelpers(childNavigation); return &lt;Component navigation=&#123;childNavigation&#125; /&gt;; &#125;&#125; 导航属性(Navigation Prop)传递给导航器的导航属性(navigation prop)只包括状态( state) 和分发( dispatch)。这是导航器的当前状态，以及发送动作请求的事件通道。 所有导航器都是受控组件：它们总是显示通过props.navigation.state进入的内容，而他们改变状态的唯一方法是将动作发送到props.navigation.dispatch中。 导航器可以通过自定义路由器( customizing their router)来指定父导航器的自定义行为。例如，导航器能够通过从router.getStateForAction返回null来指定应该何时阻止执行动作。或者导航器可以通过重写router.getActionForPathAndParams来指定自定义URI处理，以输出相关的导航动作，并在router.getStateForAction中处理该动作。 导航状态(Navigation State)传递到导航器的props.navigation.state的导航状态具有以下结构： 12345678910111213141516&#123; index: 1, // 识别路由数组中的哪个路由是活动的 routes: [ &#123; // 每个路由都需要一个名称，路由器将用于将每个路由与一个React组件相关联 routeName: &apos;MyRouteName&apos;, // 此路由的唯一ID，用于在路由数组中保持顺序： key: &apos;myroute-123&apos;, // 路由可以有任何其他数据。包含路由器有的`params` ...customRouteData, &#125;, ...moreRoutes, ]&#125; 导航分发(Navigation Dispatchers)导航器可以发送导航动作，例如“转到URI”( ‘Go to a URI’)，“返回”(‘Go back’)。 如果动作成功处理，分发者将返回true，否则返回false。 用于构建自定义导航器的API为了帮助开发人员实现自定义导航器，React Navigation提供了以下实用函数： createNavigator该实用函数以标准方式将路由器( router )和导航视图( navigation view )组合在一起： 1const MyApp = createNavigator(MyRouter)(MyView); 所有这一切在幕后是： 1234const MyApp = (&#123; navigation &#125;) =&gt; ( &lt;MyView router=&#123;MyRouter&#125; navigation=&#123;navigation&#125; /&gt;);MyApp.router = MyRouter; addNavigationHelpers进入一个使用状态( state )和分发(dispatch )的裸导航器导航属性，并使用【屏幕导航属性中的所有各种函数如 navigation.navigate() 和navigation.goBack()】增强它。这些功能只是帮助人员创建动作并将其发送到dispatch。 createNavigationContainer如果您希望导航器可用作顶级组件，（没有导航属性被传入），你可以使用createNavigationContainer。当导航属性丢失时，此实用函数将使您的导航器像顶级导航器。它将管理应用程序状态，并与应用程序级别的导航功能集成，如处理传入和传出链接以及Android返回按钮行为。]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[屏幕导航选项(Screen Navigation Options)]]></title>
    <url>%2F2017%2F06%2F05%2Fscreen-nav-options%2F</url>
    <content type="text"><![CDATA[每个屏幕可以配置关于如何在父导航器中呈现的几个方面。 两种方式来指定每个选项静态配置(Static configuration): 每个导航选项都可以直接分配： 12345class MyScreen extends React.Component &#123; static navigationOptions = &#123; title: 'Great', &#125;; ... 动态配置(Dynamic Configuration) 或者，选项可以是一个接受以下参数的函数，并返回导航选项的对象，该对象将覆盖路由定义和导航器定义的navigationOptions。 props - 可用于屏幕组件的共同的属性 navigation -屏幕的导航属性( navigation prop)，和在navigation.state里的屏幕路由 screenProps - 从导航器组件上传递过来的属性 navigationOptions - 未提供新值时将使用的默认或先前设置的选项 123456class ProfileScreen extends React.Component &#123; static navigationOptions = (&#123; navigation, screenProps &#125;) =&gt; (&#123; title: navigation.state.params.name + "'s Profile!", headerRight: &lt;Button color=&#123;screenProps.tintColor&#125; &#123;...&#125; /&gt;, &#125;); ... screenProps在渲染时传入。如果此屏幕托管在SimpleApp导航器中： 1234&lt;SimpleApp screenProps=&#123;&#123;tintColor: 'blue'&#125;&#125; // navigation=&#123;&#123;state, dispatch&#125;&#125; // optionally control the app/&gt; 通用导航选项(Generic Navigation Options)标题 title 导航选项在每个导航器之间是通用的。它用于设置给定屏幕的标题字符串。 12345class MyScreen extends React.Component &#123; static navigationOptions = &#123; title: 'Great', &#125;; ... 与导航器视图仅使用的其他导航选项不同，环境中可以使用标题选项来更新浏览器窗口或应用程序切换器中的标题。 默认导航选项(Default Navigation Options)在屏幕上定义navigationOptions是非常常见的，但有时也可以在导航器上定义navigationOptions也很有用 想象下面的情况：您的TabNavigator表示应用程序中的一个屏幕，并嵌套在顶级StackNavigator中： 1234StackNavigator(&#123; route1: &#123; screen: RouteOne &#125;, route2: &#123; screen: MyTabNavigator &#125;,&#125;); 现在，当route2处于活动状态时，您想更改标题的色调颜色。对于route1来说很容易做到，对于route2也是很容易的。这是默认导航选项 - 它们只是在导航器上设置的导航选项： 12345678const MyTabNavigator = TabNavigator(&#123; profile: ProfileScreen, ...&#125;, &#123; navigationOptions: &#123; headerTintColor: 'blue', &#125;,&#125;); 请注意，您仍然可以决定在叶级别的屏幕上指定navigationOptions。上面的ProfileScreen屏幕上的navigationOptions将逐个合并到导航器的默认选项。无论什么时候导航器和屏幕都定义和相同的选项（例如headerTintColor），屏幕将会覆盖导航器的navigationOptions。因此，通过执行以下操作，您可以在ProfileScreen处于活动状态时更改色彩： 123456class ProfileScreen extends React.Component &#123; static navigationOptions = &#123; headerTintColor: 'black', &#125;; ...&#125; 导航选项参考(Navigation Option Reference)可用的导航选项列表取决依赖于添加屏幕的导航器。 检查以下可用选项： drawer navigator stack navigator tab navigator]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[导航动作(Navigation Actions)]]></title>
    <url>%2F2017%2F06%2F04%2Fnavigation-actions%2F</url>
    <content type="text"><![CDATA[所有导航动作返回【可以使用navigation.dispatch（）方法发送到路由器】的对象。 请注意，如果要发送(dispatch) react-navigation动作，则应使用此库中提供的动作创建者(action creators)。 支持以下操作： Navigate - 导航到另一个路由 Reset - 使用新状态替换当前状态 Back - 返回上一个状态 Set Params - 给指定的路由设置参数 Init - 如果状态未定义，则使用初始化的第一个状态 导航(Navigate)导航(Navigate)动作将通过导航(Navigate)动作的结果更新当前状态。 routeName - String - 必需 - 已在应用程序的路由器中某处注册的目标routeName params - Object - 可选 - 将参数合并到目标路由中 action - Object - 可选 - （高级）如果屏幕是导航器，则在子路由器中运行的子操作。本文档中描述的任何一个操作都可以设置为子操作。 123456789101112import &#123; NavigationActions &#125; from 'react-navigation'const navigateAction = NavigationActions.navigate(&#123; routeName: 'Profile', params: &#123;&#125;, action: NavigationActions.navigate(&#123; routeName: 'SubProfileRoute'&#125;)&#125;)this.props.navigation.dispatch(navigateAction) 复位(Reset)复位 Reset 动作会擦除整个导航状态，并将其替换为多个动作的结果 index - number - required - 在导航状态的路由数组上的活动路由索引. actions - array - required - 导航动作的阵列将取代导航状态. 123456789import &#123; NavigationActions &#125; from 'react-navigation'const resetAction = NavigationActions.reset(&#123; index: 0, actions: [ NavigationActions.navigate(&#123; routeName: 'Profile'&#125;) ]&#125;)this.props.navigation.dispatch(resetAction) 如何使用索引 index 参数索引 index 参数用于指定当前的活动路由。 例如：给定一个使用两个路由配置的（Profile和Settings）基本的堆栈导航。要将状态重置为活动屏幕为Settings但将其堆叠在Profile屏幕顶部的位置，则可以执行以下操作： 12345678910import &#123; NavigationActions &#125; from 'react-navigation'const resetAction = NavigationActions.reset(&#123; index: 1, actions: [ NavigationActions.navigate(&#123; routeName: 'Profile'&#125;), NavigationActions.navigate(&#123; routeName: 'Settings'&#125;) ]&#125;)this.props.navigation.dispatch(resetAction) 返回(Back)返回上一屏幕并关闭当前屏幕。返回( back )动作创建者具有一个可选参数： key - string or null - 可选 - 如果设置，导航将从给定的键返回。如果为空，导航将返回任何地方. 123456import &#123; NavigationActions &#125; from 'react-navigation'const backAction = NavigationActions.back(&#123; key: 'Profile'&#125;)this.props.navigation.dispatch(backAction) 设置参数(SetParams)当发送SetParams动作时，路由器将产生一个新的状态，该状态改变了特定路由的参数，由密钥标识 params - object - required - 新的参数将被合并到现有的路由参数中 key - string - required - 路由密钥应该得到新的参数 1234567import &#123; NavigationActions &#125; from 'react-navigation'const setParamsAction = NavigationActions.setParams(&#123; params: &#123; title: 'Hello' &#125;, key: 'screen-123',&#125;)this.props.navigation.dispatch(setParamsAction)]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[屏幕导航属性(Screen Navigation Prop)]]></title>
    <url>%2F2017%2F06%2F03%2Fscreen-navigation-prop%2F</url>
    <content type="text"><![CDATA[您应用中的每个屏幕都会收到一个包含以下内容的导航属性(navigation prop)： navigate - (helper) 链接到其他屏幕 state - 屏幕的当前状态/路由 setParams - (helper) 更改路由的参数 goBack - (helper) 关闭活动屏幕并返回 dispatch - 向路由器发送动作(action) 注意：navigation prop传递到每个导航感知组件，包括导航器。一个很大的例外是导航器的navigation prop可能没有辅助功能（navigate，goBack等）;它可能只有 state 和 dispatch 。为了 navigate 使用导航器的navigation prop，您将不得不使用动作创建者(action creator)进行调度(dispatch). 关于与Redux挂钩的注意事项 人们并不总是使用Redux正确地勾勒出来，因为他们误解导航器的顶级API，导航属性( navigation prop)是可选的。如果导航器没有获得导航属性( navigation prop)，导航器将保持其状态，但这并不是您通过使用redux挂起应用程序时通常希望使用的功能。对于嵌套在主导航器中的导航器，您总是希望通过屏幕的导航属性( navigation prop)往下传递。这允许您的根导航器与所有子导航器通信并提供状态。只有您的根路由器需要与redux集成，因为所有其他路由器都在其中。 navigate - 链接到其他屏幕Call this to link to another screen in your app. Takes the following arguments: 调用此函数链接到您应用中的另一个屏幕。获得以下参数： navigate(routeName, params, action) routeName - 已经在应用程序路由器中某处注册的目标routeName params - 参数合并到目的地路由 action - （高级）在子路由器中运行的子操作，如果屏幕是导航器。有关支持的操作的完整列表，请参阅操作文档。 123456789101112131415class HomeScreen extends React.Component &#123; render() &#123; const &#123;navigate&#125; = this.props.navigation; return ( &lt;View&gt; &lt;Text&gt;This is the home screen of the app&lt;/Text&gt; &lt;Button onPress=&#123;() =&gt; navigate('Profile', &#123;name: 'Brent'&#125;)&#125; title="Go to Brent's profile" /&gt; &lt;/View&gt; ) &#125;&#125; state - 屏幕的当前状态/路由屏幕可以通过this.props.navigation.state访问其路由。每个都将返回一个具有以下内容的对象： 12345678&#123; // 路由器中配置的路由名称 routeName: 'profile', // 用于对路由进行排序的唯一标识符 key: 'main0', //此屏幕的字符串选项的可选对象 params: &#123; hello: 'world' &#125;&#125; 123456789class ProfileScreen extends React.Component &#123; render() &#123; const &#123;state&#125; = this.props.navigation; // state.routeName === 'Profile' return ( &lt;Text&gt;Name: &#123;state.params.name&#125;&lt;/Text&gt; ); &#125;&#125; setParams - 更改路由参数启动setParams操作允许屏幕(组件)更改路由中的参数，这对于更新按钮和标题很有用。 1234567891011class ProfileScreen extends React.Component &#123; render() &#123; const &#123;setParams&#125; = this.props.navigation; return ( &lt;Button onPress=&#123;() =&gt; setParams(&#123;name: 'Lucy'&#125;)&#125; title="Set title name to 'Lucy'" /&gt; ) &#125;&#125; goBack - 关闭活动的屏幕并返回(可选)提供一个键，它指定要从中返回的路由。默认情况下，goBack将关闭调用它的路由。如果目标是回到任何地方，不用指定要关闭的路由，请调用.goBack（null） 123456789101112131415161718192021class HomeScreen extends React.Component &#123; render() &#123; const &#123;goBack&#125; = this.props.navigation; return ( &lt;View&gt; &lt;Button onPress=&#123;() =&gt; goBack()&#125; title="Go back from this HomeScreen" /&gt; &lt;Button onPress=&#123;() =&gt; goBack(null)&#125; title="Go back anywhere" /&gt; &lt;Button onPress=&#123;() =&gt; goBack('screen-123')&#125; title="Go back from screen-123" /&gt; &lt;/View&gt; ) &#125;&#125; dispatch - 发送一个动作(action)到路由器(router)使用dispatch向路由器发送任何导航动作(navigation action)。其他导航功能在幕后使用分发(dispatch)。 请注意，如果要发送react-navigation动作，则应使用此库中提供的动作创建者(action creators)。 有关可用动作的完整列表，请参阅导航动作文档( Navigation Actions Docs )。 12345678910import &#123; NavigationActions &#125; from 'react-navigation'const navigateAction = NavigationActions.navigate(&#123; routeName: 'Profile', params: &#123;&#125;, // navigate can have a nested navigate action that will be run inside the child router action: NavigationActions.navigate(&#123; routeName: 'SubProfileRoute'&#125;)&#125;)this.props.navigation.dispatch(navigateAction)]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[抽屉导航器(DrawerNavigator)]]></title>
    <url>%2F2017%2F06%2F02%2Fdrawer-navigator%2F</url>
    <content type="text"><![CDATA[用于轻松设置带抽屉导航的屏幕。有关实例，请参阅我们的展示Demo( our expo demo)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class MyHomeScreen extends React.Component &#123; static navigationOptions = &#123; drawerLabel: 'Home', drawerIcon: (&#123; tintColor &#125;) =&gt; ( &lt;Image source=&#123;require('./chats-icon.png')&#125; style=&#123;[styles.icon, &#123;tintColor: tintColor&#125;]&#125; /&gt; ), &#125;; render() &#123; return ( &lt;Button onPress=&#123;() =&gt; this.props.navigation.navigate('Notifications')&#125; title="Go to notifications" /&gt; ); &#125;&#125;class MyNotificationsScreen extends React.Component &#123; static navigationOptions = &#123; drawerLabel: 'Notifications', drawerIcon: (&#123; tintColor &#125;) =&gt; ( &lt;Image source=&#123;require('./notif-icon.png')&#125; style=&#123;[styles.icon, &#123;tintColor: tintColor&#125;]&#125; /&gt; ), &#125;; render() &#123; return ( &lt;Button onPress=&#123;() =&gt; this.props.navigation.goBack()&#125; title="Go back home" /&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; icon: &#123; width: 24, height: 24, &#125;,&#125;);const MyApp = DrawerNavigator(&#123; Home: &#123; screen: MyHomeScreen, &#125;, Notifications: &#123; screen: MyNotificationsScreen, &#125;,&#125;); 要打开和关闭抽屉导航器，分别导航到DrawerOpen和DrawerClose。 12this.props.navigation.navigate('DrawerOpen'); // 打开抽屉导航器this.props.navigation.navigate('DrawerClose'); // 关闭抽屉导航器 API 定义1DrawerNavigator(RouteConfigs, DrawerNavigatorConfig) 路由配置(RouteConfigs)路由配置对象是从路由名称到路由配置的映射，它告诉导航器该路由的内容，请参阅StackNavigator中的示例。 抽屉导航器配置(DrawerNavigatorConfig) drawerWidth - 抽屉导航器的宽度 drawerPosition - 选项：left 和 right ，默认的位置是左侧left contentComponent - 用于呈现抽屉导航器内容的组件，例如导航项。接收抽屉导航器的 navigation 属性 。默认为DrawerItems。有关详细信息，请参阅下文。 contentOptions - 配置抽屉导航器内容，见下文。 示例:默认DrawerView不可滚动。要实现可滚动视图，您必须使用contentComponent自定义容器，如下面的示例所示。 12345&#123; drawerWidth: 200, drawerPosition: 'right', contentComponent: props =&gt; &lt;ScrollView&gt;&lt;DrawerItems &#123;...props&#125; /&gt;&lt;/ScrollView&gt;&#125; 下面几个选项被传递到底层路由器来修改导航逻辑： initialRouteName - 初始路由的routeName。 order - 定义抽屉导航器项顺序的routeNames数组。 paths -提供routeName到路径配置的映射，该配置将覆盖routeConfigs中设置的路径。 backBehavior - 按下后退按钮是否会切换到初始路由？如果是，设置为initialRoute，否则为none。默认为initialRoute行为。 提供自定义的contentComponent您可以轻松地覆盖 react-navigation使用的默认组件： 12345678910111213import &#123; DrawerItems &#125; from 'react-navigation';const CustomDrawerContentComponent = (props) =&gt; ( &lt;View style=&#123;style.container&#125;&gt; &lt;DrawerItems &#123;...props&#125; /&gt; &lt;/View&gt;);const styles = StyleSheet.create(&#123; container: &#123; flex: 1, &#125;,&#125;); contentOptions for DrawerItems items - 路由数组，可以修改或覆盖 activeItemKey -键确定活动路线 activeTintColor - 活动标签的标题和图标颜色 activeBackgroundColor -活动标签的背景颜色 inactiveTintColor - 非活动标签的标签和图标颜色 inactiveBackgroundColor - 非活动标签的背景颜色 onItemPress(route) - 当按下项(Item)时调用的函数 style - Item内容部分的样式对象 labelStyle - 当您的标签是字符串时，此样式对象将覆盖内容部分中的文本样式 示例:123456contentOptions: &#123; activeTintColor: '#e91e63', style: &#123; marginVertical: 0, &#125;&#125; 屏幕导航器选项(Screen Navigation Options)title可以用作headerTitle和drawerLabel的回退的通用标题 drawerLabel字符串，React元素(组件)或赋予{focused：boolean，tintColor：string}的函数返回一个React元素(组件)，显示在抽屉导航器侧边栏中。未定义时，使用场景标题(title) drawerIconReact元素(组件)或一个函数，给定{focused：boolean，tintColor：string}返回一个React元素(组件)，显示在抽屉侧边栏中。 导航器属性(Navigator Props)由DrawerNavigator（...）创建的导航器组件具有以下属性： screenProps - 向子屏幕传递额外的选项，例如： 1234567const DrawerNav = DrawerNavigator(&#123; // 配置&#125;);&lt;DrawerNav screenProps=&#123;/* 这个属性传递给子屏幕组件，在子屏幕组件中作为this.props.screenProps使用 */&#125;/&gt; Nesting DrawerNavigationPlease bear in mind that if you nest the DrawerNavigation, the drawer will show below the parent navigation.]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[标签导航器(TabNavigator)]]></title>
    <url>%2F2017%2F06%2F01%2Ftab-navigator%2F</url>
    <content type="text"><![CDATA[用于通过TabRouter轻松设置带有多个选项卡的屏幕。有关实例，请参阅我们的展示Demo( our expo demo)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class MyHomeScreen extends React.Component &#123; static navigationOptions = &#123; tabBarLabel: 'Home', // 注意：默认情况下，该图标仅在iOS上显示。搜索下面的showIcon选项. tabBarIcon: (&#123; tintColor &#125;) =&gt; ( &lt;Image source=&#123;require('./chats-icon.png')&#125; style=&#123;[styles.icon, &#123;tintColor: tintColor&#125;]&#125; /&gt; ), &#125;; render() &#123; return ( &lt;Button onPress=&#123;() =&gt; this.props.navigation.navigate('Notifications')&#125; title="Go to notifications" /&gt; ); &#125;&#125;class MyNotificationsScreen extends React.Component &#123; static navigationOptions = &#123; tabBarLabel: 'Notifications', tabBarIcon: (&#123; tintColor &#125;) =&gt; ( &lt;Image source=&#123;require('./notif-icon.png')&#125; style=&#123;[styles.icon, &#123;tintColor: tintColor&#125;]&#125; /&gt; ), &#125;; render() &#123; return ( &lt;Button onPress=&#123;() =&gt; this.props.navigation.goBack()&#125; title="Go back home" /&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; icon: &#123; width: 26, height: 26, &#125;,&#125;);const MyApp = TabNavigator(&#123; Home: &#123; screen: MyHomeScreen, &#125;, Notifications: &#123; screen: MyNotificationsScreen, &#125;,&#125;, &#123; tabBarOptions: &#123; activeTintColor: '#e91e63', &#125;,&#125;); API 定义1TabNavigator(RouteConfigs, TabNavigatorConfig) 路由配置(RouteConfigs)路由配置对象是从路由名称到路由配置的映射，它告诉导航器该路由的内容，请参阅StackNavigator中的示例。 标签导航器配置(TabNavigatorConfig) tabBarComponent - 用作标签栏的组件，例如。 TabBarBottom（这是iOS上的默认），TabBarTop（这是Android上的默认） tabBarPosition - 标签栏的位置可以是“top”或“bottom” swipeEnabled - 是否允许在标签之间进行滑动 animationEnabled - 是否在切换标签时启动动画 lazy - 是否根据需要懒加载标签，而不是提前渲染 tabBarOptions - 配置标签栏，见下文。 这几个选项被传递到底层路由器来修改导航逻辑： initialRouteName - 第一次加载时初始标签路由的routeName order -定义标签卡顺序的routeNames数组 paths - 提供routeName到路径配置的映射，该配置将覆盖routeConfigs中设置的路径.(不太明白) backBehavior - 按下后退按钮是否会使Tab键切换到初始选项卡？如果是，设置为initialRoute，否则为none。默认为initialRoute行为。 tabBarOptions for TabBarBottom (default tab bar on iOS)使用TabBarBottom组件的标签栏选项(tabBarOptions)(在IOS上默认使用此组件) activeTintColor -激活标签的标题和图标的颜色值 activeBackgroundColor - 激活标签的标题和图标的背景颜色值 inactiveTintColor - 非激活标签的标签和图标颜色 inactiveBackgroundColor - 非激活标签的标签和图标的背景颜色值 showLabel - 是否显示标签的标题，默认为true显示 style - 标签栏的样式对象 labelStyle - 标签标题样式对象 tabStyle - 标签的样式对象 示例: 123456789tabBarOptions: &#123; activeTintColor: '#e91e63', labelStyle: &#123; fontSize: 12, &#125;, style: &#123; backgroundColor: 'blue', &#125;,&#125; tabBarOptions for TabBarTop (default tab bar on Android)使用TabBarTop组件的标签栏选项(tabBarOptions)(在Android上默认使用此组件) activeTintColor -激活标签的标题和图标的颜色值 inactiveTintColor - 非激活标签的标签和图标颜色 showIcon - 是否显示标签的图标，默认为false不显示 showLabel - 是否显示标签的标题，默认为true显示 upperCaseLabel - 是否使标签大写，默认为true pressColor - 按压为材质波纹颜色值 (仅Android &gt;= 5.0) pressOpacity - 按压标签的不透明度 (iOS 和 仅Android &lt; 5.0) scrollEnabled - 是否启用可滚动选项卡 tabStyle - 标签的样式对象 indicatorStyle - 标签指示器的样式对象（选项卡底部的行） labelStyle - 标签标题的样式对象 iconStyle - 标签图标的样式对象 style - 标签栏的对象 示例: 12345678tabBarOptions: &#123; labelStyle: &#123; fontSize: 12, &#125;, style: &#123; backgroundColor: 'blue', &#125;,&#125; 屏幕导航选项(Screen Navigation Options)title可用作headerTitle和tabBarLabel的回退的通用标题 tabBarVisibleTrue或false显示或隐藏选项卡栏，如果未设置，则默认为true tabBarIconReact元素(组件)或赋予{focused：boolean，tintColor：string}的一个函数返回一个React元素(组件)，以在tab栏中显示 tabBarLabel标签栏或React元素中显示的标签的标题字符串，或给定{focused：boolean，tintColor：string}的函数返回一个React元素(组件)，用以显示在选项卡栏中。未定义时，使用场景标题(title)。要隐藏，请参阅上一节中的tabBarOptions.showLabel。 导航器属性(Navigator Props)由TabNavigator（...）创建的导航器组件具有以下属性： screenProps - 向子屏幕传递额外的选项和导航选项，例如： 1234567const TabNav = TabNavigator(&#123; // 配置&#125;);&lt;TabNav screenProps=&#123;/* 这个属性传递给子屏幕组件，在子屏幕组件中作为this.props.screenProps使用 */&#125;/&gt;]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[栈导航器(StackNavigator)]]></title>
    <url>%2F2017%2F05%2F31%2Fstack-navigator%2F</url>
    <content type="text"><![CDATA[为您的应用程序提供了一种在每个新屏幕放置在堆栈顶部的屏幕之间转换的方法。 默认情况下，StackNavigator配置为熟悉的iOS和Android设备外观：iOS上的新屏幕从右侧滑出，Android上的新屏幕从底部渐隐。在iOS上，StackNavigator也可以配置为模式风格，让屏幕从底部滑入。 12345678910111213141516171819202122232425class MyHomeScreen extends React.Component &#123; static navigationOptions = &#123; title: 'Home', &#125; render() &#123; return ( &lt;Button onPress=&#123;() =&gt; this.props.navigation.navigate('Profile', &#123;name: 'Lucy'&#125;)&#125; title="Go to Lucy's profile" /&gt; ); &#125;&#125;const ModalStack = StackNavigator(&#123; Home: &#123; screen: MyHomeScreen, &#125;, Profile: &#123; path: 'people/:name', screen: MyProfileScreen, &#125;,&#125;); API 定义1StackNavigator(RouteConfigs, StackNavigatorConfig) 路由配置(RouteConfigs)路由配置对象是从路由名称到路由配置的映射，它告诉导航器该路由要呈现什么内容。 123456789101112131415161718192021StackNavigator(&#123; // 你可以导航到每个屏幕，创建一个新的屏幕，如下所示： Profile: &#123; // `ProfileScreen`是一个React组件，将作为屏幕的主要内容。 screen: ProfileScreen, // 当`ProfileScreen`由StackNavigator加载时，它将被赋予“navigation”属性。 // 可选：在Web应用程序中深链接或使用react-navigation导航时，将使用此路径： path: 'people/:name', // 从路径中提取动作(action)和路由参数. // 可选：覆盖屏幕的`navigationOptions`（即每个组件中的`navigationOptions`） navigationOptions: (&#123;navigation&#125;) =&gt; (&#123; title: `$&#123;navigation.state.params.name&#125;'s Profile'`, &#125;), &#125;, ...MyOtherRoutes,&#125;); 栈导航器配置(StackNavigatorConfig)路由器选项: initialRouteName - 为栈(stack)设置默认的界面，必须和路由配置(route configs)里面的一个key匹配。 initialRouteParams - 初始路由的参数 navigationOptions - 用于屏幕的默认导航选项 paths - 在路由设置(RouteConfigs)里面设置映射路径的覆盖(不太明白) 视觉选项: mode - 定义渲染(rendering)和转换(transitions)的样式式,两种选项(给字符串即可)： card - 使用标准的iOS和Android的界面切换，这是默认的。 modal - 使屏幕从底部滑入，这是一种常见的iOS模式。只适用于iOS，对Android没有作用。 headerMode - 指定标题(Header)应该如何被渲染,选项： float - 渲染一个保持在顶部的标题，并在屏幕更改时显示动画。这是iOS上的常见模式。(即共用一个header 意思就是有title文字渐变效果) screen - 每个屏幕都有一个标题，标题与屏幕一起淡入淡出。这是Android上的常见模式(各用各的header 意思就是没有title文字渐变效果) none - 不会显示标题(没有header) cardStyle - 使用该属性继承或者重载一个在stack中的card的样式. transitionConfig - 定义一个返回覆盖默认屏幕的换场动画的对象的函数. onTransitionStart - 当Card换场动画即将开始时，调用此函数. onTransitionEnd - 当Card换场动画完成时，立即调用此函数. 屏幕导航选项(Screen Navigation Options)title页面的标题：用作headerTitle和tabBarLabel的回退的字符串 headerReact元素(组件)或者一个赋予HeaderProps的函数返回的一个React元素(组件)，显示为一个标题栏。设置为null隐藏标题栏。 headerTitle标题使用的字符串或React元素(组件)。默认为场景值是标题(title) headerBackTitleiOS上的后退按钮使用的标题字符串，或者为空,禁用标签。默认为场景值是标题(title) headerTruncatedBackTitle当headerBackTitle不适合屏幕时，返回按钮使用的标题字符串。默认情况下为”Back”。 headerRight设置显示在标题栏的右侧的React元素(组件) headerLeft设置显示在标题栏的左侧的React元素(组件) headerStyle设置标题栏的样式对象 headerTitleStyle设置标题(title)的样式对象 headerBackTitleStyle设置返回标题(back title)的样式对象 headerTintColor设置标题颜色 headerPressColorAndroid设置按下时的材质波纹颜色 (仅Android &gt;= 5.0) gesturesEnabled是否可以使用手势关闭此屏幕。在iOS上默认为true，在Android上为false。 导航器属性(Navigator Props)由StackNavigator（...）创建的导航器组件具有以下属性： screenProps - 向子屏幕传递额外的选项，例如： 1234567const SomeStack = StackNavigator(&#123; // 配置&#125;);&lt;SomeStack screenProps=&#123;/* 这个属性传递给子屏幕组件，在子屏幕组件中作为this.props.screenProps使用 */&#125;/&gt; 示例(Examples)例子请参阅 SimpleStack.js和 ModalStack.js，您可以在本地运行NavigationPlayground 应用程序的一部分。 您可以通过访问我们的展示Demo( our expo demo)直接在手机上查看这些示例。]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[导航器(Navigator)]]></title>
    <url>%2F2017%2F05%2F30%2Fnavigators%2F</url>
    <content type="text"><![CDATA[导航器允许您定义应用程序的导航结构。导航器还可以渲染你配置过的像标题栏和标签栏等常见元素。在该引擎下，导航器是简单的React组件。 内置导航器react-navigation 包括以下功能来帮助您创建导航器： StackNavigator - 一次呈现一个屏幕，并提供屏幕之间的转换。当新屏幕打开时，它被放置在堆栈的顶部。 TabNavigator - 渲染一个标签栏，让用户在几个屏幕之间切换 DrawerNavigator - 提供从屏幕左(右)侧滑入的抽屉菜单 使用导航器渲染屏幕导航器渲染仅由React组件组成的应用程序屏幕。 要了解如何创建屏幕，请阅读： 屏幕导航属性（Screen navigation prop允许屏幕分发导航动作(navigation actions)，如打开另一个屏幕 屏幕导航选项(Screen navigationOptions)可以通过导航器自定义如何显示屏幕内容（例如头部标题，标签标题） 在根组件上调用导航如果您想要使用相同级别的Navigator，您可以声明它，您可以使用react的ref选项： 12345678910111213const AppNavigator = StackNavigator(SomeAppRouteConfigs);class App extends React.Component &#123; someEvent() &#123; // call navigate for AppNavigator here: this.navigator &amp;&amp; this.navigator.dispatch(&#123; type: 'Navigate', routeName, params &#125;); &#125; render() &#123; return ( &lt;AppNavigator ref=&#123;nav =&gt; &#123; this.navigator = nav; &#125;&#125; /&gt; ); &#125;&#125; 请注意，此解决方案只能在根导航器上使用。 导航容器当导航属性丢失时，内置导航器可以自动表现为根导航器。该功能提供了一个透明的导航容器，这是顶级导航属性的来源。 当渲染其中一个导航器时，导航属性是可选的。当它丢失时，容器进入并管理其自己的导航状态。它还处理URL，外部链接和Android后退按钮集成。 为了方便起见，内置的导航器具有这种能力，因为幕后他们使用createNavigationContainer。通常，导航器需要导航属性才能起作用。 根导航器接受以下属性： onNavigationStateChange(prevState, newState, action)每次由导航器管理的导航状态发生变化，该函数都会被调用。它接收到以前的状态，新的导航状态和发生状态变化的动作。默认情况下会将状态更改打印到控制台。 uriPrefix应用程序可能会处理的URI的前缀。这将在处理深层链接( deep link )以提取路径传递到路由器时使用。]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[配置标题(Configuring the Header)]]></title>
    <url>%2F2017%2F05%2F29%2Fguide-headers%2F</url>
    <content type="text"><![CDATA[标题仅适用于栈导航StackNavigator。 在前面的例子中，我们创建了一个StackNavigator来在我们的应用程序中显示几个屏幕。 导航到聊天屏幕时，我们可以通过将参数提供给导航函数来指定新路由的参数。在这种情况下，我们要在聊天屏幕上提供该人的姓名： 1this.props.navigation.navigate('Chat', &#123; user: 'Lucy' &#125;); 用户 user 参数可以从聊天屏幕访问： 123456class ChatScreen extends React.Component &#123; render() &#123; const &#123; params &#125; = this.props.navigation.state; return &lt;Text&gt;Chat with &#123;params.user&#125;&lt;/Text&gt;; &#125;&#125; 设置标题接下来，标题可以使用屏幕参数配置： 123456class ChatScreen extends React.Component &#123; static navigationOptions = (&#123; navigation &#125;) =&gt; (&#123; title: `Chat with $&#123;navigation.state.params.user&#125;`, &#125;); ...&#125; Android IOS 添加右侧按钮然后我们可以添加一个标题导航选项( header navigation option )，它允许我们添加一个自定义的右侧按钮： 123static navigationOptions = &#123; headerRight: &lt;Button title="Info" /&gt;, ... Android IOS 导航选项可以使用导航属性(navigation prop)定义。让我们根据路由传递过来的参数渲染一个不同的按钮，并设置按钮，同时当按下按钮时调用navigation.setParams。 1234567891011121314static navigationOptions = (&#123; navigation &#125;) =&gt; &#123; const &#123;state, setParams&#125; = navigation; const isInfo = state.params.mode === 'info'; const &#123;user&#125; = state.params; return &#123; title: isInfo ? `$&#123;user&#125;'s Contact Info` : `Chat with $&#123;state.params.user&#125;`, headerRight: ( &lt;Button title=&#123;isInfo ? 'Done' : `$&#123;user&#125;'s info`&#125; onPress=&#123;() =&gt; setParams(&#123; mode: isInfo ? 'none' : 'info'&#125;)&#125; /&gt; ), &#125;;&#125;; 现在，标题可以与屏幕路由/状态(screen route/state)进行交互： Android IOS 要查看其余的标题选项，请参阅导航选项文档(navigation options document).]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[嵌套导航(Nesting Navigators)]]></title>
    <url>%2F2017%2F05%2F28%2Fguide-nested%2F</url>
    <content type="text"><![CDATA[通常在移动应用中组合各种形式的导航。 React Navigation中的路由器和导航器是可组合的，它允许您为应用程序定义一个复杂的导航结构。 对于我们的聊天应用程序，我们要在第一个屏幕上放置几个选项卡，查看最近的聊天和所有联系人。 介绍标签导航(Introducing Tab Navigator)让我们在App.js 创建一个新的 TabNavigator 导航： 123456789101112131415161718import &#123; TabNavigator &#125; from "react-navigation";class RecentChatsScreen extends React.Component &#123; render() &#123; return &lt;Text&gt;List of recent chats&lt;/Text&gt; &#125;&#125;class AllContactsScreen extends React.Component &#123; render() &#123; return &lt;Text&gt;List of all contacts&lt;/Text&gt; &#125;&#125;const MainScreenNavigator = TabNavigator(&#123; Recent: &#123; screen: RecentChatsScreen &#125;, All: &#123; screen: AllContactsScreen &#125;,&#125;); 如果MainScreenNavigator被渲染为顶级导航器组件，它将如下所示： 在一个屏幕中嵌套一个导航器我们希望这些选项卡在应用的第一个屏幕中可见，但是推入栈中的新屏幕应该覆盖当前选项卡屏幕。 让我们将我们的选项卡导航器作为我们在上一步中设置的顶级StackNavigator中的屏幕。 1234const SimpleApp = StackNavigator(&#123; Home: &#123; screen: MainScreenNavigator &#125;, Chat: &#123; screen: ChatScreen &#125;,&#125;); 因为MainScreenNavigator被当做一整个屏幕，所以我们可以给它设置导航选项（ navigationOptions）： 123MainScreenNavigator.navigationOptions = &#123; title: 'My Chats',&#125;; 我们也可以在每个标签组件中添加一个按钮，链接到聊天组件： 1234&lt;Button onPress=&#123;() =&gt; this.props.navigation.navigate('Chat', &#123; user: 'Lucy' &#125;)&#125; title="Chat with Lucy"/&gt; 现在我们将一个导航器放在另一个导航器中，我们可以在导航器之间导航：]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[你好移动导航(Hello Mobile Navigation)]]></title>
    <url>%2F2017%2F05%2F27%2Fguide-intro%2F</url>
    <content type="text"><![CDATA[我们使用React Navigation为Android和iOS构建一个简单的聊天应用程序。 设置与安装首先，确保您都设置好了React Native的环境。接下来，创建一个新项目并添加 react-navigation: 12345678910# 创建一个RN应用react-native init SimpleAppcd SimpleApp# 通过npm包管理器安装最新版本的react-navigationnpm install --save react-navigation# 运行Appreact-native run-android # or:react-native run-ios 验证您是否可以成功查看在iOS或Android设备上运行的示例应用程序： Android IOS 我们想在IOS和Android设备上分享同一套代码，所以，我们应该删除 index.ios.js 和 index.android.js 文件中的代码内容，同时，使用 import &#39;./App&#39;; 进行替换。 现在可以为我们的应用程序实现创建新文件， App.js 。 介绍栈导航( Stack Navigator)对于我们的应用程序，我们想使用StackNavigator，因为我们需要一个概念上的“堆栈”导航，每个新屏幕都放在堆栈的顶部，并返回从堆栈顶部移除一个屏幕。我们从一个屏幕开始： 123456789101112131415161718192021import React from 'react';import &#123; AppRegistry, Text,&#125; from 'react-native';import &#123; StackNavigator &#125; from 'react-navigation';class HomeScreen extends React.Component &#123; static navigationOptions = &#123; title: 'Welcome', &#125;; render() &#123; return &lt;Text&gt;Hello, Navigation!&lt;/Text&gt;; &#125;&#125;const SimpleApp = StackNavigator(&#123; Home: &#123; screen: HomeScreen &#125;,&#125;);AppRegistry.registerComponent('SimpleApp', () =&gt; SimpleApp); 屏幕的标题 title 可以在静态navigationOptions上进行配置，其中可以设置许多选项来配置导航器中的屏幕显示。 现在iPhone和Android应用都会出现相同的屏幕： Android IOS 添加一个新屏幕在我们的 App.js 文件中, 添加一个叫 ChatScreen 新屏幕: 123456789101112class ChatScreen extends React.Component &#123; static navigationOptions = &#123; title: 'Chat with Lucy', &#125;; render() &#123; return ( &lt;View&gt; &lt;Text&gt;Chat with Lucy&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 然后，我们在 HomeScreen 组件中添加一个按钮，并使用路由(routeName)Chat 链接到ChatScreen 组件上。 1234567891011121314151617class HomeScreen extends React.Component &#123; static navigationOptions = &#123; title: 'Welcome', &#125;; render() &#123; const &#123; navigate &#125; = this.props.navigation; return ( &lt;View&gt; &lt;Text&gt;Hello, Chat App!&lt;/Text&gt; &lt;Button onPress=&#123;() =&gt; navigate('Chat')&#125; title="Chat with Lucy" /&gt; &lt;/View&gt; ); &#125;&#125; 我们正在使用屏幕导航属性( screen navigation prop )中的导航功能跳转到ChatScreen 组件上。然后，我们将它添加到我们的栈导航组件StackNavigator中。 1234const SimpleApp = StackNavigator(&#123; Home: &#123; screen: HomeScreen &#125;, Chat: &#123; screen: ChatScreen &#125;,&#125;); 现在，你可以导航到你新创建的ChatScreen组件上，然后返回上一个HomeScreen组件。 Android IOS 传递参数将名称硬编码到ChatScreen中并不理想。如果我们可以动态地传递一个名称来代替，那将会更有用，所以让我们这样做。 除了在导航功能中指定目标组件routeName之外，还可以传递将放入新路由的参数。首先，我们将编辑我们的HomeScreen组件，将 user 参数传递到路由中。 1234567891011121314151617class HomeScreen extends React.Component &#123; static navigationOptions = &#123; title: 'Welcome', &#125;; render() &#123; const &#123; navigate &#125; = this.props.navigation; return ( &lt;View&gt; &lt;Text&gt;Hello, Chat App!&lt;/Text&gt; &lt;Button onPress=&#123;() =&gt; navigate('Chat', &#123; user: 'Lucy' &#125;)&#125; title="Chat with Lucy" /&gt; &lt;/View&gt; ); &#125;&#125; 然后，我们可以编辑我们的ChatScreen组件，以显示通过路由传递的用户参数： 123456789101112131415class ChatScreen extends React.Component &#123; // 导航选项可以定义为屏幕props的函数： static navigationOptions = (&#123; navigation &#125;) =&gt; (&#123; title: `Chat with $&#123;navigation.state.params.user&#125;`, &#125;); render() &#123; // 屏幕的当前路线被传递到`props.navigation.state`： const &#123; params &#125; = this.props.navigation.state; return ( &lt;View&gt; &lt;Text&gt;Chat with &#123;params.user&#125;&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; 现在，当您导航到聊天屏幕时能看到动态专递过来的名字。尝试在HomeScreen中更改用户参数，看看会发生什么！ Android IOS]]></content>
      <categories>
        <category>react navigation</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Uncontrolled Components(不受控组件)]]></title>
    <url>%2F2017%2F04%2F12%2Frad-uncontrolled-components%2F</url>
    <content type="text"><![CDATA[In most cases, we recommend using controlled components to implement forms. In a controlled component, form data is handled by a React component. The alternative is uncontrolled components, where form data is handled by the DOM itself. 在大多数情况下，我们建议使用受控组件来实现表单。 在受控组件中，表单数据由React组件处理。 替代方案是不受控制的组件，其中表单数据由DOM本身处理。 To write an uncontrolled component, instead of writing an event handler for every state update, you can use a ref to get form values from the DOM. 要编写一个不受控组件，而不是为每个状态更新编写事件处理程序，您可以使用ref从DOM获取表单值。 For example, this code accepts a single name in an uncontrolled component: 例如，此代码在不受控的组件中接受单个名称： 123456789101112131415161718192021222324class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleSubmit(event) &#123; alert(&apos;A name was submitted: &apos; + this.input.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; ref=&#123;(input) =&gt; this.input = input&#125; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; ); &#125;&#125; Try it on CodePen. Since an uncontrolled component keeps the source of truth in the DOM, it is sometimes easier to integrate React and non-React code when using uncontrolled components. It can also be slightly less code if you want to be quick and dirty. Otherwise, you should usually use controlled components. 由于不受控组件在DOM中保留了真实的来源，因此在使用不受控制的组件时集成React和Non-React代码有时更为容易。 虽然它也可以稍微减少代码量，但你会快速污染代码环境。 否则，您应该通常使用受控组件。 If it’s still not clear which type of component you should use for a particular situation, you might find this article on controlled versus uncontrolled inputs to be helpful. 如果仍然不清楚您应该为特定情况使用哪种类型的组件，那么您可能会发现这篇关于受控制和不受控制的输入的文章 是有帮助的。 Default Values(默认值)In the React rendering lifecycle, the value attribute on form elements will override the value in the DOM. With an uncontrolled component, you often want React to specify the initial value, but leave subsequent updates uncontrolled. To handle this case, you can specify a defaultValue attribute instead of value. 在React渲染生命周期中，form元素上的value属性将覆盖DOM中的值。 使用不受控制的组件，您通常希望React指定初始值，但不再控制后续更新。 要处理这种情况，可以指定一个defaultValue属性而不是value。 1234567891011121314render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input defaultValue=&quot;Bob&quot; type=&quot;text&quot; ref=&#123;(input) =&gt; this.input = input&#125; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; );&#125; Likewise, &lt;input type=&quot;checkbox&quot;&gt; and &lt;input type=&quot;radio&quot;&gt; support defaultChecked, and &lt;select&gt; and &lt;textarea&gt; supports defaultValue. 同样，&lt;input type =&quot;checkbox&quot;&gt;和&lt;input type =&quot;radio&quot;&gt;支持defaultChecked，而&lt;select&gt;和&lt;textarea&gt;支持defaultValue。]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Refs and the DOM(DOM节点的引用)]]></title>
    <url>%2F2017%2F04%2F11%2Frad-refs-and-the-dom%2F</url>
    <content type="text"><![CDATA[In the typical React dataflow, props are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an instance of a React component, or it could be a DOM element. For both of these cases, React provides an escape hatch. 在典型的React数据流中， props是父组件与子组件互动的唯一方法。 要修改子组件，请用新的props重新渲染。 但是，有几种情况需要在典型数据流之外强制修改子组件。 要修改的子组件可以是React组件的一个实例，也可以是一个DOM元素。 对于这两种情况，React提供了一个逃生舱口。 When to Use Refs (何时使用Refs引用)There are a few good use cases for refs: 在这里有一些关于Refs很好的用例 Managing focus, text selection, or media playback. 管理焦点，文本选择或媒体播放。 Triggering imperative animations. 触发强制性动画。 Integrating with third-party DOM libraries. 与第三方DOM库集成。 Avoid using refs for anything that can be done declaratively. 避免使用refs声明性地做任何事情。 For example, instead of exposing open() and close() methods on a Dialog component, pass an isOpen prop to it. 例如，不要在Dialog组件上暴露open（）和close（）方法，而是将一个isOpen属性传递给它。 Adding a Ref to a DOM Element (添加Ref引用到DOM元素)React supports a special attribute that you can attach to any component. The ref attribute takes a callback function, and the callback will be executed immediately after the component is mounted or unmounted. React支持一个可以附加到任何组件的特殊属性。 ref属性采用回调函数，并且在组件被装载或卸载之后立即执行回调。 When the ref attribute is used on an HTML element, the ref callback receives the underlying DOM element as its argument. For example, this code uses the ref callback to store a reference to a DOM node: 当在HTML元素上使用ref属性时，ref回调接收底层的DOM元素作为其参数。 例如，此代码使用引用回调来存储对DOM节点的引用： 1234567891011121314151617181920212223242526272829303132class CustomTextInput extends React.Component &#123; constructor(props) &#123; super(props); this.focus = this.focus.bind(this); &#125; focus() &#123; // Explicitly focus the text input using the raw DOM API // 使用原始DOM API明确地将文本输入聚焦 this.textInput.focus(); &#125; render() &#123; // Use the `ref` callback to store a reference to the text input DOM // element in an instance field (for example, this.textInput). // 使用`ref`回调来存储对文本输入DOM的引用 // 实例字段中的元素（例如this.textInput） return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;this.focus&#125; /&gt; &lt;/div&gt; ); &#125;&#125; React will call the ref callback with the DOM element when the component mounts, and call it with null when it unmounts. 当组件挂载时，React将使用DOM元素调用ref回调，并在卸载时将其调用为null。 Using the ref callback just to set a property on the class is a common pattern for accessing DOM elements. The preferred way is to set the property in the ref callback like in the above example. There is even a shorter way to write it: ref={input =&gt; this.textInput = input}. 使用ref回调只是为了在类上设置属性，这是访问DOM元素的常见模式。 首选的方法是在ref回调中设置属性，就像上面的例子一样。 甚至有一个较短的写法：ref = {input =&gt; this.textInput = input}。 Adding a Ref to a Class Component (添加Ref引用到类组件)When the ref attribute is used on a custom component declared as a class, the ref callback receives the mounted instance of the component as its argument. For example, if we wanted to wrap the CustomTextInput above to simulate it being clicked immediately after mounting: 当在声明为类的自定义组件中使用ref属性时，ref回调接收组件的已挂载实例作为其参数。 例如，如果我们想要包装上面的CustomTextInput来模拟它在安装后立即被点击： 12345678910111213class AutoFocusTextInput extends React.Component &#123; componentDidMount() &#123; this.textInput.focus(); &#125; render() &#123; return ( &lt;CustomTextInput ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt; ); &#125;&#125; Note that this only works if CustomTextInput is declared as a class: 请注意，这仅在CustomTextInput被声明为类时才有效： 123class CustomTextInput extends React.Component &#123; // ...&#125; Refs and Functional Components (Refs引用和功能组件)You may not use the ref attribute on functional components because they don’t have instances: 您不能在功能组件上使用ref属性，因为它们没有实例： 1234567891011121314function MyFunctionalComponent() &#123; return &lt;input /&gt;;&#125;class Parent extends React.Component &#123; render() &#123; // This will *not* work! // 这样是 不能 运行的 return ( &lt;MyFunctionalComponent ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt; ); &#125;&#125; You should convert the component to a class if you need a ref to it, just like you do when you need lifecycle methods or state. 如果需要Ref去引用它，您应该将组件转换为类，就像在需要生命周期方法或状态时一样。 You can, however, use the ref attribute inside a functional component as long as you refer to a DOM element or a class component: 但是，只要您引用DOM元素或类组件，您可以使用功能组件中的ref属性： 12345678910111213141516171819202122function CustomTextInput(props) &#123; // textInput must be declared here so the ref callback can refer to it // textInput必须在这里声明，所以ref回调可以引用它 let textInput = null; function handleClick() &#123; textInput.focus(); &#125; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;(input) =&gt; &#123; textInput = input; &#125;&#125; /&gt; &lt;input type=&quot;button&quot; value=&quot;Focus the text input&quot; onClick=&#123;handleClick&#125; /&gt; &lt;/div&gt; ); &#125; Don’t Overuse Refs (不要过度使用Refs引用)Your first inclination may be to use refs to “make things happen” in your app. If this is the case, take a moment and think more critically about where state should be owned in the component hierarchy. Often, it becomes clear that the proper place to “own” that state is at a higher level in the hierarchy. See the Lifting State Up guide for examples of this. 您的第一个倾向可能是在应用程序中使用Refs引用“使事情发生”。 如果是这种情况，请花一点时间，更多地关注组件层次结构中的状态应该如何拥有。 通常，很明显，“拥有”该状态的适当位置在层次结构中处于较高级别。 有关示例，请参阅提升状态向导”。 Legacy API: String Refs (旧版API：字符串引用参考)If you worked with React before, you might be familiar with an older API where the ref attribute is a string, like &quot;textInput&quot;, and the DOM node is accessed as this.refs.textInput. We advise against it because string refs have some issues, are considered legacy, and are likely to be removed in one of the future releases. If you’re currently using this.refs.textInput to access refs, we recommend the callback pattern instead. 如果您之前使用过React，您可能会熟悉一个旧的API，其中ref属性是一个字符串，如“textInput”，DOM节点作为this.refs.textInput进行访问。 我们建议反对这样使用它，因为字符串引用有一些问题，被认为是遗留的Bug，并且可能会在以后的版本中被删除。 如果您正在使用this.refs.textInput访问引用，则建议使用回调模式。 Caveats (警告)If the ref callback is defined as an inline function, it will get called twice during updates, first with null and then again with the DOM element. This is because a new instance of the function is created with each render, so React needs to clear the old ref and set up the new one. You can avoid this by defining the ref callback as a bound method on the class, but note that it shouldn’t matter in most cases. 如果ref回调被定义为内联函数，则在更新期间将被调用两次，首先为null，然后再次使用DOM元素。 这是因为每次渲染都创建了一个新的函数实例，所以React需要清除旧的引用并设置新的引用。 您可以通过将ref回调定义为类的绑定方法来避免这种情况，但请注意，在大多数情况下，这并不重要。]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JSX In Depth(深入JSX)]]></title>
    <url>%2F2017%2F04%2F10%2Frad-jsx-in-depth%2F</url>
    <content type="text"><![CDATA[Fundamentally, JSX just provides syntactic sugar for the React.createElement(component, props, ...children) function. The JSX code: 基本上，JSX只是为 React.createElement(component, props, ...children) 函数提供语法糖。 JSX代码： 123&lt;MyButton color="blue" shadowSize=&#123;2&#125;&gt; Click Me&lt;/MyButton&gt; compiles into: 编译成: 12345React.createElement( MyButton, &#123;color: 'blue', shadowSize: 2&#125;, 'Click Me') You can also use the self-closing form of the tag if there are no children. So: 如果没有子标签或子组件，也可以使用标签的自封闭形式。 所以： 1&lt;div className="sidebar" /&gt; compiles into: 编译成: 12345React.createElement( 'div', &#123;className: 'sidebar'&#125;, null) If you want to test out how some specific JSX is converted into JavaScript, you can try out the online Babel compiler%20%7B%0A%20%20return%20%3Cdiv%3EHello%20world!%3C%2Fdiv%3E%3B%0A%7D). 如果您想测试JSX如何转换为JavaScript，您可以使用在线Babel编译器进行尝试。 Specifying The React Element Type(指定React元素类型)The first part of a JSX tag determines the type of the React element. JSX标签的第一部分决定了React元素的类型。 Capitalized types indicate that the JSX tag is referring to a React component. These tags get compiled into a direct reference to the named variable, so if you use the JSX &lt;Foo /&gt; expression, Foo must be in scope. 大写类型表示的JSX标签指的是React组件。 这些标签被编译成对命名变量的直接引用，所以如果使用JSX &lt;Foo /&gt;表达式，Foo必须在范围内。 React Must Be in Scope(React必须在范围内)Since JSX compiles into calls to React.createElement, the React library must also always be in scope from your JSX code. 由于JSX编译成对React.createElement的调用，所以React库也必须始终在JSX代码的范围内。 For example, both of the imports are necessary in this code, even though React and CustomButton are not directly referenced from JavaScript: 例如，即使React和CustomButton不直接从JavaScript引用，这两个导入都是必需的： 1234567import React from &apos;react&apos;;import CustomButton from &apos;./CustomButton&apos;;function WarningButton() &#123; // return React.createElement(CustomButton, &#123;color: &apos;red&apos;&#125;, null); return &lt;CustomButton color=&quot;red&quot; /&gt;;&#125; If you don’t use a JavaScript bundler and added React as a script tag, it is already in scope as a React global. 如果您不使用JavaScript绑定器并将React添加为脚本标记，则它已作为React全局的范围。 Using Dot Notation for JSX Type(对JSX类型使用点表示法)You can also refer to a React component using dot-notation from within JSX. This is convenient if you have a single module that exports many React components. For example, if MyComponents.DatePicker is a component, you can use it directly from JSX with: 您还可以使用JSX中的点表示法引用React组件。 如果您有一个导出许多React组件的单个模块，这很方便。 例如，如果MyComponents.DatePicker是一个组件，则可以直接从JSX中使用它： 1234567891011import React from &apos;react&apos;;const MyComponents = &#123; DatePicker: function DatePicker(props) &#123; return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;; &#125;&#125;function BlueDatePicker() &#123; return &lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;;&#125; User-Defined Components Must Be Capitalized(用户定义的组件必须大写)When an element type starts with a lowercase letter, it refers to a built-in component like &lt;div&gt; or &lt;span&gt; and results in a string &#39;div&#39; or &#39;span&#39; passed to React.createElement. Types that start with a capital letter like &lt;Foo /&gt; compile to React.createElement(Foo) and correspond to a component defined or imported in your JavaScript file. 当元素类型以小写字母开头时，它引用一个内置的组件，如&lt;div&gt;或&lt;span&gt;，并将一个字符串’div’或’span’传递给React.createElement。 以大写字母开头的类型，如&lt;Foo /&gt;编译为React.createElement(Foo)，并对应于您的JavaScript文件中定义或导入的组件。 We recommend naming components with a capital letter. If you do have a component that starts with a lowercase letter, assign it to a capitalized variable before using it in JSX. 我们建议用大写字母命名组件。 如果您的组件以小写字母开头，请在JSX中使用之前将其分配给大写的变量。 For example, this code will not run as expected: 例如，此代码将无法按预期运行： 123456789101112131415import React from &apos;react&apos;;// Wrong! This is a component and should have been capitalized:// 错误！ 这是一个组件，应该被大写：function hello(props) &#123; // Correct! This use of &lt;div&gt; is legitimate because div is a valid HTML tag: // 正确！ 这种使用&lt;div&gt;是合法的，因为div是一个有效的HTML标记： return &lt;div&gt;Hello &#123;props.toWhat&#125;&lt;/div&gt;;&#125;function HelloWorld() &#123; // Wrong! React thinks &lt;hello /&gt; is an HTML tag because it&apos;s not capitalized: // 错了！ React认为&lt;hello /&gt;是一个HTML标签，因为它不大写： return &lt;hello toWhat=&quot;World&quot; /&gt;;&#125; To fix this, we will rename hello to Hello and use &lt;Hello /&gt; when referring to it: 要解决这个问题，我们将重命名hello为Hello，并在引用它时使用&lt;Hello /&gt;： 123456789101112131415import React from &apos;react&apos;;// Correct! This is a component and should be capitalized:// 正确！ 这是一个组件，应该被大写：function Hello(props) &#123; // Correct! This use of &lt;div&gt; is legitimate because div is a valid HTML tag: // 正确！ 这种使用&lt;div&gt;是合法的，因为div是一个有效的HTML标记： return &lt;div&gt;Hello &#123;props.toWhat&#125;&lt;/div&gt;;&#125;function HelloWorld() &#123; // Correct! React knows &lt;Hello /&gt; is a component because it&apos;s capitalized. // 正确！ React知道&lt;Hello /&gt;是一个组件，因为它是大写的。 return &lt;Hello toWhat=&quot;World&quot; /&gt;;&#125; Choosing the Type at Runtime(在运行时选择类型)You cannot use a general expression as the React element type. If you do want to use a general expression to indicate the type of the element, just assign it to a capitalized variable first. This often comes up when you want to render a different component based on a prop: 您不能使用通用表达式作为React元素类型。 如果您想使用通用表达式来表示元素的类型，请先将其分配给大写的变量。 当您要根据属性渲染不同的组件时，会出现这种情况： 12345678910111213import React from &apos;react&apos;;import &#123; PhotoStory, VideoStory &#125; from &apos;./stories&apos;;const components = &#123; photo: PhotoStory, video: VideoStory&#125;;function Story(props) &#123; // Wrong! JSX type can&apos;t be an expression. // 错了！ JSX类型不能是表达式。 return &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;;&#125; To fix this, we will assign the type to a capitalized variable first: 要解决这个问题，我们将首先将类型分配给大写的变量： 1234567891011121314import React from &apos;react&apos;;import &#123; PhotoStory, VideoStory &#125; from &apos;./stories&apos;;const components = &#123; photo: PhotoStory, video: VideoStory&#125;;function Story(props) &#123; // Correct! JSX type can be a capitalized variable. // 正确！ JSX类型可以是大写的变量。 const SpecificStory = components[props.storyType]; return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;&#125; Props in JSX(JSX属性)There are several different ways to specify props in JSX. 在JSX中有几种不同的方式来指定属性。 JavaScript Expressions(JavaScript表达式)You can pass any JavaScript expression as a prop, by surrounding it with {}. For example, in this JSX: 您可以传递任何JavaScript表达式作为属性，通过使用{}围绕它。 例如，在这个JSX中： 1&lt;MyComponent foo=&#123;1 + 2 + 3 + 4&#125; /&gt; For MyComponent, the value of props.foo will be 10 because the expression 1 + 2 + 3 + 4 gets evaluated. 对于MyComponent，因为表达式1 + 2 + 3 + 4会被计算，所以props.foo的值将为10。 if statements and for loops are not expressions in JavaScript, so they can’t be used in JSX directly. Instead, you can put these in the surrounding code. For example: if语句和for循环在JavaScript中不是表达式，所以它们不能直接在JSX中使用。 相反，您可以将它们放在周围的代码中。 例如： 123456789function NumberDescriber(props) &#123; let description; if (props.number % 2 == 0) &#123; description = &lt;strong&gt;even&lt;/strong&gt;; &#125; else &#123; description = &lt;i&gt;odd&lt;/i&gt;; &#125; return &lt;div&gt;&#123;props.number&#125; is an &#123;description&#125; number&lt;/div&gt;;&#125; String Literals(字符串文字)You can pass a string literal as a prop. These two JSX expressions are equivalent: 你可以传递字符串文字作为属性。 这两个JSX表达式是等价的： 123&lt;MyComponent message="hello world" /&gt;&lt;MyComponent message=&#123;'hello world'&#125; /&gt; When you pass a string literal, its value is HTML-unescaped. So these two JSX expressions are equivalent: 当您传递字符串文字时，其值为HTML未转义。 所以这两个JSX表达式是等价的： 123&lt;MyComponent message="&amp;lt;3" /&gt;&lt;MyComponent message=&#123;'&lt;3'&#125; /&gt; This behavior is usually not relevant. It’s only mentioned here for completeness. 这种行为通常是不相关的。 这里只提到完整性。 Props Default to “True”(属性默认为“True”)If you pass no value for a prop, it defaults to true. These two JSX expressions are equivalent: 如果你没有传递一个属性的值，它默认为true。 这两个JSX表达式是等价的： 123&lt;MyTextBox autocomplete /&gt;&lt;MyTextBox autocomplete=&#123;true&#125; /&gt; In general, we don’t recommend using this because it can be confused with the ES6 object shorthand {foo} which is short for {foo: foo} rather than {foo: true}. This behavior is just there so that it matches the behavior of HTML. 一般来说，我们不建议使用它，因为它可能与{foo：foo}而不是{foo：true}的缩写为{foo}的ES6对象简写{foo}混淆。 这种行为就在这里，因此它符合HTML的行为。 Spread Attributes(传递属性)If you already have props as an object, and you want to pass it in JSX, you can use ... as a “spread” operator to pass the whole props object. These two components are equivalent: 如果您已经拥有 props 作为对象，并且想要在JSX中传递，则可以使用...作为“扩展”运算符来传递整个 props 对象。 这两个组件是等效的 12345678function App1() &#123; return &lt;Greeting firstName=&quot;Ben&quot; lastName=&quot;Hector&quot; /&gt;;&#125;function App2() &#123; const props = &#123;firstName: &apos;Ben&apos;, lastName: &apos;Hector&apos;&#125;; return &lt;Greeting &#123;...props&#125; /&gt;;&#125; Spread attributes can be useful when you are building generic containers. However, they can also make your code messy by making it easy to pass a lot of irrelevant props to components that don’t care about them. We recommend that you use this syntax sparingly. 构建通用容器组件时，扩展属性可能很有用。 然而，他们也可以通过将很多不相关的属性传递给不关心它们的组件来使您的代码变得凌乱。 我们建议您谨慎使用此语法。 Children in JSX(JSX中的孩子)In JSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special prop: props.children. There are several different ways to pass children: 在包含开始标签和结束标签的JSX表达式中，这些标签之间的内容作为特殊的属性(props.children)进行传递。 有几种不同的方法来传递子组件： String Literals(字符串文字)You can put a string between the opening and closing tags and props.children will just be that string. This is useful for many of the built-in HTML elements. For example: 您可以在开始和结束标签之间放置一个字符串，而props.children将只是该字符串。 这对于许多内置的HTML元素很有用。 例如： 1&lt;MyComponent&gt;Hello world!&lt;/MyComponent&gt; This is valid JSX, and props.children in MyComponent will simply be the string &quot;Hello world!&quot;. HTML is unescaped, so you can generally write JSX just like you would write HTML in this way: 这是有效的JSX，而组件中的props.children将只是字符串“Hello world！”。 HTML可以是未转义的，所以你一般可以写JSX，就像你用这种方式写HTML： 1&lt;div&gt;This is valid HTML &amp;amp; JSX at the same time.&lt;/div&gt; JSX removes whitespace at the beginning and ending of a line. It also removes blank lines. New lines adjacent to tags are removed; new lines that occur in the middle of string literals are condensed into a single space. So these all render to the same thing: JSX在行的开始和结尾处移除空格。 它也删除空行。 删除与标签相邻的新行; 出现在字符串文字中间的新行被压缩成一个空格。 所以这些渲染都是相同的事情： 123456789101112131415&lt;div&gt;Hello World&lt;/div&gt;&lt;div&gt; Hello World&lt;/div&gt;&lt;div&gt; Hello World&lt;/div&gt;&lt;div&gt; Hello World&lt;/div&gt; JSX Children(JSX子组件)You can provide more JSX elements as the children. This is useful for displaying nested components: 您可以提供更多的JSX元素作为子组件。 这对于显示嵌套组件很有用： 1234&lt;MyContainer&gt; &lt;MyFirstComponent /&gt; &lt;MySecondComponent /&gt;&lt;/MyContainer&gt; You can mix together different types of children, so you can use string literals together with JSX children. This is another way in which JSX is like HTML, so that this is both valid JSX and valid HTML: 你可以混合不同类型的子组件，所以你可以和JSX子组件一起使用字符串文字。 这是JSX的另一种方式，就像HTML一样，JSX和HTML都是有效的： 1234567&lt;div&gt; Here is a list: &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; A React component can’t return multiple React elements, but a single JSX expression can have multiple children, so if you want a component to render multiple things you can wrap it in a div like this. 一个React组件不能返回多个React元素，但单个JSX表达式可以有多个子元素，因此，如果您想要一个组件来呈现多个元素，则可以将其包装在这样的div中。 JavaScript Expressions(JavaScript表达式)You can pass any JavaScript expression as children, by enclosing it within {}. For example, these expressions are equivalent: 您可以将任何JavaScript表达式作为孩子传递，并将其包含在{}中。 例如，这些表达式是等价的： 123&lt;MyComponent&gt;foo&lt;/MyComponent&gt;&lt;MyComponent&gt;&#123;'foo'&#125;&lt;/MyComponent&gt; This is often useful for rendering a list of JSX expressions of arbitrary length. For example, this renders an HTML list: 这对于呈现任意长度的JSX表达式的列表通常很有用。 例如，这将呈现HTML列表： 123456789101112function Item(props) &#123; return &lt;li&gt;&#123;props.message&#125;&lt;/li&gt;;&#125;function TodoList() &#123; const todos = [&apos;finish doc&apos;, &apos;submit pr&apos;, &apos;nag dan to review&apos;]; return ( &lt;ul&gt; &#123;todos.map((message) =&gt; &lt;Item key=&#123;message&#125; message=&#123;message&#125; /&gt;)&#125; &lt;/ul&gt; );&#125; JavaScript expressions can be mixed with other types of children. This is often useful in lieu of string templates: JavaScript表达式可以与其他类型的孩子(这里指字符串)混合使用。 这通常用于代替字符串模板： 123function Hello(props) &#123; return &lt;div&gt;Hello &#123;props.addressee&#125;!&lt;/div&gt;;&#125; Functions as Children(函数作为孩子)Normally, JavaScript expressions inserted in JSX will evaluate to a string, a React element, or a list of those things. However, props.children works just like any other prop in that it can pass any sort of data, not just the sorts that React knows how to render. For example, if you have a custom component, you could have it take a callback as props.children: 通常，插入JSX中的JavaScript表达式将被转换字符串，React元素或这些内容的列表。 然而，props.children就像任何其他的属性一样工作，因为它可以传递任何数据，而不仅仅是React知道如何呈现的种类。 例如，如果您有自定义组件，则可以将其作为props.children进行回调： 1234567891011121314151617// Calls the children callback numTimes to produce a repeated component// 调用子回调 numtimes 以产生一个重复的组件function Repeat(props) &#123; let items = []; for (let i = 0; i &lt; props.numTimes; i++) &#123; items.push(props.children(i)); &#125; return &lt;div&gt;&#123;items&#125;&lt;/div&gt;;&#125;function ListOfTenThings() &#123; return ( &lt;Repeat numTimes=&#123;10&#125;&gt; &#123;(index) =&gt; &lt;div key=&#123;index&#125;&gt;This is item &#123;index&#125; in the list&lt;/div&gt;&#125; &lt;/Repeat&gt; );&#125; Children passed to a custom component can be anything, as long as that component transforms them into something React can understand before rendering. This usage is not common, but it works if you want to stretch what JSX is capable of. 传递给自定义组件的孩子可以是任何东西，只要该组件将它们转换为React在呈现之前可以理解的东西。 这个用法并不常见，但是如果你想扩展JSX的功能，这样也是可以工作的。 Booleans, Null, and Undefined Are Ignored(布尔值，空值和未定义被忽略)false, null, undefined, and true are valid children. They simply don’t render. These JSX expressions will all render to the same thing: false, null, undefined, 和true是有效的孩子。 他们根本不渲染。 这些JSX表达式将全部呈现为相同的东西： 1234567891011&lt;div /&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&#123;false&#125;&lt;/div&gt;&lt;div&gt;&#123;null&#125;&lt;/div&gt;&lt;div&gt;&#123;undefined&#125;&lt;/div&gt;&lt;div&gt;&#123;true&#125;&lt;/div&gt; This can be useful to conditionally render React elements. This JSX only renders a &lt;Header /&gt; if showHeader is true: 这有助于有条件地渲染React元素。 如果showHeader为true，则此JSX仅呈现&lt;Header /&gt;： 1234&lt;div&gt; &#123;showHeader &amp;&amp; &lt;Header /&gt;&#125; &lt;Content /&gt;&lt;/div&gt; One caveat is that some “falsy” values, such as the 0 number, are still rendered by React. For example, this code will not behave as you might expect because 0 will be printed when props.messages is an empty array: 一个值得注意的是，React提供了一些“伪造”值，如0数字。 例如，此代码将不会像您预期的那样运行，因为当props.messages为空数组时将打印0数字： 12345&lt;div&gt; &#123;props.messages.length &amp;&amp; &lt;MessageList messages=&#123;props.messages&#125; /&gt; &#125;&lt;/div&gt; To fix this, make sure that the expression before &amp;&amp; is always boolean: 要解决这个问题，请确保&amp;&amp;之前的表达式始终为布尔值： 12345&lt;div&gt; &#123;props.messages.length &gt; 0 &amp;&amp; &lt;MessageList messages=&#123;props.messages&#125; /&gt; &#125;&lt;/div&gt; Conversely, if you want a value like false, true, null, or undefined to appear in the output, you have to convert it to a string first: 相反，如果您想要一个像 false, true, null, 或 undefined 这样的值出现在输出中，则必须先将其转换为字符串： 123&lt;div&gt; My JavaScript variable is &#123;String(myVariable)&#125;.&lt;/div&gt;]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Thinking in React(React的思想)]]></title>
    <url>%2F2017%2F04%2F08%2Frqd-thinking-in-react%2F</url>
    <content type="text"><![CDATA[React is, in our opinion, the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram. 在我看来，React 是快速 构建大型Web应用的首选方式。它已经在Facebook和Instagram被我们有了广泛的应用。 One of the many great parts of React is how it makes you think about apps as you build them. In this document, we’ll walk you through the thought process of building a searchable product data table using React. React许多优点之一：它使得你在构建 app 的过程中不断思考。在本文里，我将带你经历一次使用 React 构建可搜索的商品数据表的思考过程。 Start With A Mock(从模型开始)Imagine that we already have a JSON API and a mock from our designer. The mock looks like this: 想象我们已经有个一个 JSON API 和一个来自设计师的模型。我们的设计师显然做得不够好，因为模型看起来像这样： Our JSON API returns some data that looks like this: 我们的 JSON API 返回一些看起来像这样的数据： 12345678[ &#123;category: &quot;Sporting Goods&quot;, price: &quot;$49.99&quot;, stocked: true, name: &quot;Football&quot;&#125;, &#123;category: &quot;Sporting Goods&quot;, price: &quot;$9.99&quot;, stocked: true, name: &quot;Baseball&quot;&#125;, &#123;category: &quot;Sporting Goods&quot;, price: &quot;$29.99&quot;, stocked: false, name: &quot;Basketball&quot;&#125;, &#123;category: &quot;Electronics&quot;, price: &quot;$99.99&quot;, stocked: true, name: &quot;iPod Touch&quot;&#125;, &#123;category: &quot;Electronics&quot;, price: &quot;$399.99&quot;, stocked: false, name: &quot;iPhone 5&quot;&#125;, &#123;category: &quot;Electronics&quot;, price: &quot;$199.99&quot;, stocked: true, name: &quot;Nexus 7&quot;&#125;]; Step 1: Break The UI Into A Component Hierarchy第一步：把UI拆分为一些有层级结构的组件The first thing you’ll want to do is to draw boxes around every component (and subcomponent) in the mock and give them all names. If you’re working with a designer, they may have already done this, so go talk to them! Their Photoshop layer names may end up being the names of your React components! 首先你想要做的，是在模型里的每一个组件周围绘制边框，并给它们命名。如果你和设计师一起工作，他们应该已经完成这步了，所以去和他们谈谈！他们的 Photoshop 图层名也许最终会成为你的 React 组件名。 But how do you know what should be its own component? Just use the same techniques for deciding if you should create a new function or object. One such technique is the single responsibility principle, that is, a component should ideally only do one thing. If it ends up growing, it should be decomposed into smaller subcomponents. 但是你如何知道什么东西应该是独立的组件？只需在你创建一个函数或者对象时，根据是否使用过相同技术来做决定。一种这样的技术是单一功能原则（single responsibility principle），也就是一个组件在理想情况下只做一件事情。如果它最终增长了，它就应该被分解为更小的组件。 Since you’re often displaying a JSON data model to a user, you’ll find that if your model was built correctly, your UI (and therefore your component structure) will map nicely. That’s because UI and data models tend to adhere to the same information architecture, which means the work of separating your UI into components is often trivial. Just break it up into components that represent exactly one piece of your data model. 既然你频繁显示一个 JSON 的数据模型给用户，你会发现，如果你的模型构建正确，你的 UI（因此也有你的组件结构）就将映射良好。那是因为 UI 和数据模型趋向附着于相同的 信息架构，这意味着，把你的 UI 分离为组件的工作通常是琐碎的，只需把 UI 拆分成能准确对应数据模型的每块组件。 You’ll see here that we have five components in our simple app. We’ve italicized the data each component represents. 在这里你会看到，在我们的简单的APP里有五个组件。我用斜体表示每个组件的数据。 FilterableProductTable (orange): contains the entirety of the example FilterableProductTable (橙色): 包含示例的整体 SearchBar (blue): receives all user input SearchBar (蓝色): 接收所有 用户输入 ProductTable (green): displays and filters the data collection based on user input ProductTable (绿色): 基于 用户输入 显示和过滤的 数据集合(data collection) ProductCategoryRow (turquoise): displays a heading for each category ProductCategoryRow (蓝绿色): 为每个 分类 显示一个列表头 ProductRow (red): displays a row for each product ProductRow (红色): 为每个 商品 显示一行 If you look at ProductTable, you’ll see that the table header (containing the “Name” and “Price” labels) isn’t its own component. This is a matter of preference, and there’s an argument to be made either way. For this example, we left it as part of ProductTable because it is part of rendering the data collection which is ProductTable‘s responsibility. However, if this header grows to be complex (i.e. if we were to add affordances for sorting), it would certainly make sense to make this its own ProductTableHeader component. 如果你看着 ProductTable，你会看到表头(包含了 “Name” 和 “Price” 标签) 不是独立的组件。这是一个个人喜好问题，并且无论采用哪种方式都有争论。对于这个例子，我把它留做 ProductTable 的一部分，因为它是 data collection渲染的一部分，而 data collection 渲染是 ProductTable 的职责。然而，当列表头增长到复杂的时候(例如：如果我们添加排序功能)，那么使它成为独立的 ProductTableHeader 组件无疑是有意义的。 Now that we’ve identified the components in our mock, let’s arrange them into a hierarchy. This is easy. Components that appear within another component in the mock should appear as a child in the hierarchy: 既然现在我们已经识别出了我们模型中的组件，让我们把他们安排到一个层级中。这很容易。在模型中，出现在一个组件里面的另一组件 ，应该在层级中表现为一种子级关系： FilterableProductTable SearchBar ProductTable ProductCategoryRow ProductRow Step 2: Build A Static Version in React第二步：用React创建一个静态版本See the Pen Thinking In React: Step 2 on CodePen. Now that you have your component hierarchy, it’s time to implement your app. The easiest way is to build a version that takes your data model and renders the UI but has no interactivity. It’s best to decouple these processes because building a static version requires a lot of typing and no thinking, and adding interactivity requires a lot of thinking and not a lot of typing. We’ll see why. 既然你已经了解了组件的层级结构，是时候实现你的app了。简单的方式是构建一个版本，它取走你的数据模型并渲染UI，除了没有互动性。这是将过程解耦的最好办法，因为构建一个静态版本需要不假思索地写很多代码，而添加互动性需要很多思考但不需要太多代码。之后我们将会看到原因。 To build a static version of your app that renders your data model, you’ll want to build components that reuse other components and pass data using props. props are a way of passing data from parent to child. If you’re familiar with the concept of state, don’t use state at all to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don’t need it. 要构建一个静态版本 app 来渲染你的数据模型，你将会想到构建一个重用其它组件并利用 props 传递数据的组件。props 是一种从父级传递数据到子级的方式。如果你对 state 的观念很熟悉，绝不要用state 来构建这个静态版本。State 仅仅是为互动性，也就是随时间变化的数据所预留的。由于这是一个静态版本，你还不需要用到它。 You can build top-down or bottom-up. That is, you can either start with building the components higher up in the hierarchy (i.e. starting with FilterableProductTable) or with the ones lower in it (ProductRow). In simpler examples, it’s usually easier to go top-down, and on larger projects, it’s easier to go bottom-up and write tests as you build. 你可以自顶向下或自底向上的构建。也就是说，你可以既从较高的层级（比如从 FilterableProductTable 开始）也可以从较低的层级（ProductRow）开始构建组件。在较简单的例子里，通常自顶向下要容易一些，然而在更大的项目上，自底向上地构建更容易，并且更方便伴随着构建写测试。 At the end of this step, you’ll have a library of reusable components that render your data model. The components will only have render() methods since this is a static version of your app. The component at the top of the hierarchy (FilterableProductTable) will take your data model as a prop. If you make a change to your underlying data model and call ReactDOM.render() again, the UI will be updated. It’s easy to see how your UI is updated and where to make changes since there’s nothing complicated going on. React’s one-way data flow (also called one-way binding) keeps everything modular and fast. 在这一步的最后，你会获得一个渲染数据模型的可重用组件库。这些组件只有 render() 方法，因为这是一个静态版本。在层级顶端的组件 (FilterableProductTable) 将会接受你的数据模型，并将其作为一个prop。如果你改变了底层数据模型，并且再次调用 React.render() ，UI 将会更新。你可以很容易地看到 UI 是如何更新的，以及哪里变动了，因为这没什么复杂的。React的 单向数据流 (也被称为 单向绑定)使一切保持了模块化和快速。 Simply refer to the React docs if you need help executing this step. 如果你在执行这步时需要帮助，请参阅 React 文档。 A Brief Interlude: Props vs StateThere are two types of “model” data in React: props and state. It’s important to understand the distinction between the two; skim the official React docs if you aren’t sure what the difference is. Step 3: Identify The Minimal (but complete) Representation Of UI State第三步：确定最小（但完备）的 UI state 表达To make your UI interactive, you need to be able to trigger changes to your underlying data model. React makes this easy with state. 要让你的 UI 互动，你需要做到触发底层数据模型发生变化。React用 state 来让此变得容易。 To build your app correctly, you first need to think of the minimal set of mutable state that your app needs. The key here is DRY: Don’t Repeat Yourself. Figure out the absolute minimal representation of the state your application needs and compute everything else you need on-demand. For example, if you’re building a TODO list, just keep an array of the TODO items around; don’t keep a separate state variable for the count. Instead, when you want to render the TODO count, simply take the length of the TODO items array. 要正确的构建你的 app，你首先需要思考你的 app 需要的可变 state 的最小组。这里的关键是 DRY 原则：Don’t Repeat Yourself(不要重复自己)。想出哪些是你的应用需要的绝对最小 state 表达，并按需计算其他任何数据。例如，如果你要构建一个 TODO 列表，只要保持一个 TODO 项的数组；不要为了计数保持一个单独的 state 变量。当你想渲染 TODO 的计数时，简单的采用 TODO 项目的数组长度作为替代。 fdsajhgfiuytretrewq7lkz2Think of all of the pieces of data in our example application. We have: 考虑我们示例应用中的数据所有块，包括： The original list of products 原始的商品列表 The search text the user has entered 用户输入的搜索文本 The value of the checkbox 复选框的值 The filtered list of products 商品的过滤列表 Let’s go through each one and figure out which one is state. Simply ask three questions about each piece of data: 让我们逐个检查出哪一个是state，只需要简单地问以下三个问题: Is it passed in from a parent via props? If so, it probably isn’t state. 它是通过props从父级传递来的吗？如果是，它可能不是 state。 Does it remain unchanged over time? If so, it probably isn’t state. 它随时间变化吗？如果不是,它可能不是 state。 Can you compute it based on any other state or props in your component? If so, it isn’t state. 你能基于其他任何组件里的 state 或者 props 计算出它吗？如果是,它可能不是state. The original list of products is passed in as props, so that’s not state. The search text and the checkbox seem to be state since they change over time and can’t be computed from anything. And finally, the filtered list of products isn’t state because it can be computed by combining the original list of products with the search text and value of the checkbox. 原始的商品列表以 props 传入，所以它不是 state。搜索文本和复选框看起来是 state，因为他们随时间变化并且不能从任何东西计算出。最后，过滤出的商品列表不是 state，因为它可以通过原始列表与搜索文本及复选框的值组合计算得出。 So finally, our state is:(所以最后,我们的 state 是:) The search text the user has entered (用户输入的搜索文本) The value of the checkbox(checkbox 的值) Step 4: Identify Where Your State Should Live第四步：确定你的 state 应该存在于哪里See the Pen Thinking In React: Step 4 by Kevin Lacker (@lacker) on CodePen. OK, so we’ve identified what the minimal set of app state is. Next, we need to identify which component mutates, or owns, this state. OK，我们已经确定好应用的最小 state 集合是什么。接下来，我们需要确定哪个组件可以改变，或者 拥有 这个state. Remember: React is all about one-way data flow down the component hierarchy. It may not be immediately clear which component should own what state. This is often the most challenging part for newcomers to understand, so follow these steps to figure it out: 记住：React 总是在组件层级中单向数据流动的。可能不能立刻明白哪些组件应该拥有哪些 state。 这对于新手在理解上经常是最具挑战的一部分， 所以跟着这几步来弄明白它： For each piece of state in your application:(对于您的应用程序中的每个状态) Identify every component that renders something based on that state. 确定哪些组件要基于 state 来渲染内容。 Find a common owner component (a single component above all the components that need the state in the hierarchy). 找到多个组件的一个共同拥有者（在所有需要这个state组件的层次之上，找出共有的单一组件）。 Either the common owner or another component higher up in the hierarchy should own the state. 要么是共同拥有者，要么是其他在层级里更高级的组件应该拥有这个state。 If you can’t find a component where it makes sense to own the state, create a new component simply for holding the state and add it somewhere in the hierarchy above the common owner component. 如果你找不到一个组件让其可以有意义地拥有这个 state，可以简单地创建一个新的组件 hold 住这个state，并把它添加到比共同拥有者组件更高的层级上。 Let’s run through this strategy for our application: 让我们使用这个策略浏览一遍我们的应用： ProductTable needs to filter the product list based on state and SearchBar needs to display the search text and checked state. ProductTable 需要基于 state 过滤产品列表，SearchBar 需要显示搜索文本和选择状态。 The common owner component is FilterableProductTable. 共同拥有者组件是 FilterableProductTable。 It conceptually makes sense for the filter text and checked value to live in FilterableProductTable 对于过滤文本和选择框值存在于 FilterableProductTable，从概念上讲是有意义的。 Cool, so we’ve decided that our state lives in FilterableProductTable. First, add an instance property this.state = {filterText: &#39;&#39;, inStockOnly: false} to FilterableProductTable‘s constructor to reflect the initial state of your application. Then, pass filterText and inStockOnly to ProductTable and SearchBar as a prop. Finally, use these props to filter the rows in ProductTable and set the values of the form fields in SearchBar. 酷，我们已经确定了我们的 state 存在于 FilterableProductTable。首先，向FilterableProductTable的构造函数添加一个实例属性this.state = {filterText：&#39;，inStockOnly：false}以反映应用程序的初始状态。然后，传递filterText 和 inStockOnly 给 ProductTable 和 SearchBar 作为属性。最后，使用这些属性来过滤 ProductTable 中的行和设置 SearchBar 的表单项的值。 You can start seeing how your application will behave: set filterText to &quot;ball&quot; and refresh your app. You’ll see that the data table is updated correctly. 你可以开始看看你的应用将有怎样的行为了: 设置 filterText 为 &quot;ball&quot; 并刷新你的 app。你将可以看到数据表被正确地更新。 Step 5: Add Inverse Data Flow第五步：添加反向数据流See the Pen Thinking In React: Step 5 on CodePen. So far, we’ve built an app that renders correctly as a function of props and state flowing down the hierarchy. Now it’s time to support data flowing the other way: the form components deep in the hierarchy need to update the state in FilterableProductTable. 到目前为止，我们已经构建了一个应用, 它能够使用 props 和 state的功能沿着自顶向下层级正确渲染。现在是时候支持另一种数据流了：在层级深处的表单组件需要更新 FilterableProductTable 里的 state。 React makes this data flow explicit to make it easy to understand how your program works, but it does require a little more typing than traditional two-way data binding. React让数据流显式流动，使您可以轻松了解程序的工作原理，但它比传统的双向数据绑定需要写更多的代码。 If you try to type or check the box in the current version of the example, you’ll see that React ignores your input. This is intentional, as we’ve set the value prop of the input to always be equal to the state passed in from FilterableProductTable. 如果你尝试在当前版本的示例中输入或者选中复选框，你会发现 React 忽略了你的输入。这是有意的，因为我们已经设置了 input 的 value prop 值总是与 FilterableProductTable 传递过来的 state 一致。 Let’s think about what we want to happen. We want to make sure that whenever the user changes the form, we update the state to reflect the user input. Since components should only update their own state, FilterableProductTable will pass callbacks to SearchBar that will fire whenever the state should be updated. We can use the onChange event on the inputs to be notified of it. The callbacks passed by FilterableProductTable will call setState(), and the app will be updated. 让我们思考下希望发生什么。我们想确保每当用户改变表单，就通过更新 state 来反映用户的输入。由于组件应该只更新自己拥有的 state ， FilterableProductTable 将会传递一个回调函数给 SearchBar ，每当 state 应被更新时回调函数就会被调用。我们可以使用 input 的 onChange 事件来接收它的通知。 FilterableProductTable 传递的回调函数将会调用 setState() ，然后应用将会被更新。 Though this sounds complex, it’s really just a few lines of code. And it’s really explicit how your data is flowing throughout the app. 虽然这听起来复杂，但是实际上只有几行代码。并且这明确显示出了数据在应用中从始至终是如何流动的。 And That’s It (好了，就是这样)Hopefully, this gives you an idea of how to think about building components and applications with React. While it may be a little more typing than you’re used to, remember that code is read far more than it’s written, and it’s extremely easy to read this modular, explicit code. As you start to build large libraries of components, you’ll appreciate this explicitness and modularity, and with code reuse, your lines of code will start to shrink. :) 希望这给了你一个怎样思考用React构建组件和应用的概念。虽然可能比你过往的习惯要多敲一点代码，但记住，读代码的时间远比写代码的时间多，并且阅读这种模块化的、显式的代码是极为容易的。当你开始构建大型组件库时，你会非常感激这种清晰性和模块化，并且随着代码的重用，你的代码行数将会开始缩减。:)]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Composition vs Inheritance(组合与继承)]]></title>
    <url>%2F2017%2F04%2F07%2Frqd-composition-vs-inheritance%2F</url>
    <content type="text"><![CDATA[React has a powerful composition model, and we recommend using composition instead of inheritance to reuse code between components. React具有强大的组合模型，我们建议使用组合而不是继承来重用组件之间的代码。 In this section, we will consider a few problems where developers new to React often reach for inheritance, and show how we can solve them with composition. 在本节中，我们将考虑开发者创建React应用经常会触碰到使用继承的几个问题，并展示我们如何用组合来解决它们。 Containment (遏制)Some components don’t know their children ahead of time. This is especially common for components like Sidebar or Dialog that represent generic “boxes”. 一些组件不能提前知道他们的孩子组件。 这对于表示通用“框”的Sidebar或Dialog的组件尤其常见。 We recommend that such components use the special children prop to pass children elements directly into their output: 我们建议像这样的组件使用特殊的children属性，将孩子元素直接传递到他们的输出中： 1234567function FancyBorder(props) &#123; return ( &lt;div className=&#123;&apos;FancyBorder FancyBorder-&apos; + props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; );&#125; This lets other components pass arbitrary children to them by nesting the JSX: 这允许其他组件通过嵌套JSX传递任意孩子组件给它们： 123456789101112function WelcomeDialog() &#123; return ( &lt;FancyBorder color=&quot;blue&quot;&gt; &lt;h1 className=&quot;Dialog-title&quot;&gt; Welcome &lt;/h1&gt; &lt;p className=&quot;Dialog-message&quot;&gt; Thank you for visiting our spacecraft! &lt;/p&gt; &lt;/FancyBorder&gt; );&#125; Try it on CodePen. Anything inside the &lt;FancyBorder&gt; JSX tag gets passed into the FancyBorder component as a children prop. Since FancyBorder renders {props.children} inside a &lt;div&gt;, the passed elements appear in the final output. &lt;FancyBorder&gt; JSX标签内的任何内容都将作为孩子组件传入FancyBorder组件。 由于FancyBorder组件将{props.children}呈现在&lt;div&gt;内，所以传递的孩子元素将显示在最终输出中。 While this is less common, sometimes you might need multiple “holes” in a component. In such cases you may come up with your own convention instead of using children: 虽然这不太常见，但有时您在组件中可能需要多个“孔”。 在这种情况下，您可以提出自己的惯例取代使用children： 123456789101112131415161718192021222324function SplitPane(props) &#123; return ( &lt;div className=&quot;SplitPane&quot;&gt; &lt;div className=&quot;SplitPane-left&quot;&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className=&quot;SplitPane-right&quot;&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; );&#125;function App() &#123; return ( &lt;SplitPane left=&#123; &lt;Contacts /&gt; &#125; right=&#123; &lt;Chat /&gt; &#125; /&gt; );&#125; Try it on CodePen. React elements like &lt;Contacts /&gt; and &lt;Chat /&gt; are just objects, so you can pass them as props like any other data. React元素（例如&lt;Contacts /&gt;和&lt;Chat /&gt;）只是对象，因此您可以将其作为任何其他组件的属性并传递给它们。 Specialization (专业化)Sometimes we think about components as being “special cases” of other components. For example, we might say that a WelcomeDialog is a special case of Dialog. 有时我们认为组件是其他组件的“特殊情况”。 例如，我们可以说WelcomeDialog是Dialog的一个特例。 In React, this is also achieved by composition, where a more “specific” component renders a more “generic” one and configures it with props: 在React中，这也是通过组合来实现的，其中一个更“特定的”组件呈现出更“通用的”组件，并用属性来配置它： 1234567891011121314151617181920function Dialog(props) &#123; return ( &lt;FancyBorder color=&quot;blue&quot;&gt; &lt;h1 className=&quot;Dialog-title&quot;&gt; &#123;props.title&#125; &lt;/h1&gt; &lt;p className=&quot;Dialog-message&quot;&gt; &#123;props.message&#125; &lt;/p&gt; &lt;/FancyBorder&gt; );&#125;function WelcomeDialog() &#123; return ( &lt;Dialog title=&quot;Welcome&quot; message=&quot;Thank you for visiting our spacecraft!&quot; /&gt; );&#125; Try it on CodePen. Composition works equally well for components defined as classes: 组合对于定义为类的组件同样适用： 12345678910111213141516171819202122232425262728293031323334353637383940414243function Dialog(props) &#123; return ( &lt;FancyBorder color=&quot;blue&quot;&gt; &lt;h1 className=&quot;Dialog-title&quot;&gt; &#123;props.title&#125; &lt;/h1&gt; &lt;p className=&quot;Dialog-message&quot;&gt; &#123;props.message&#125; &lt;/p&gt; &#123;props.children&#125; &lt;/FancyBorder&gt; );&#125;class SignUpDialog extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.handleSignUp = this.handleSignUp.bind(this); this.state = &#123;login: &apos;&apos;&#125;; &#125; render() &#123; return ( &lt;Dialog title=&quot;Mars Exploration Program&quot; message=&quot;How should we refer to you?&quot;&gt; &lt;input value=&#123;this.state.login&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;button onClick=&#123;this.handleSignUp&#125;&gt; Sign Me Up! &lt;/button&gt; &lt;/Dialog&gt; ); &#125; handleChange(e) &#123; this.setState(&#123;login: e.target.value&#125;); &#125; handleSignUp() &#123; alert(`Welcome aboard, $&#123;this.state.login&#125;!`); &#125;&#125; Try it on CodePen. So What About Inheritance? (那么继承如何呢？)At Facebook, we use React in thousands of components, and we haven’t found any use cases where we would recommend creating component inheritance hierarchies. 在Facebook上，我们在数千个组件中使用React，我们还没有发现任何用例，我们建议您创建组件继承层次结构。 Props and composition give you all the flexibility you need to customize a component’s look and behavior in an explicit and safe way. Remember that components may accept arbitrary props, including primitive values, React elements, or functions. 属性和组合为您提供了以明确和安全的方式自定义组件外观和行为所需的所有灵活性。 请记住，组件可以接受任意属性，包括基本类型，React元素或函数。 If you want to reuse non-UI functionality between components, we suggest extracting it into a separate JavaScript module. The components may import it and use that function, object, or a class, without extending it. 如果要在组件之间重用非UI功能，我们建议将其提取到单独的JavaScript模块中。 组件可以导入它并使用该函数，对象或类，而不扩展它。]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Lifting State Up(提升状态)]]></title>
    <url>%2F2017%2F04%2F06%2Frqd-lifting-state-up%2F</url>
    <content type="text"><![CDATA[Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor. Let’s see how this works in action. 通常，一系列的组件需要反映相同的变化的数据。 我们建议将共享状态提升到他们最近的共同的父组件中。 让我们看看这是如何工作的。 In this section, we will create a temperature calculator that calculates whether the water would boil at a given temperature. 在本节中，我们将创建一个温度计算器来计算水在一定温度下是否沸腾。 We will start with a component called BoilingVerdict. It accepts the celsius temperature as a prop, and prints whether it is enough to boil the water: 我们将从一个名为BoilingVerdict的组件开始。 它接受摄氏温度作为支柱，并打印是否足以煮水： 123456function BoilingVerdict(props) &#123; if (props.celsius &gt;= 100) &#123; return &lt;p&gt;The water would boil.&lt;/p&gt;; &#125; return &lt;p&gt;The water would not boil.&lt;/p&gt;;&#125; Next, we will create a component called Calculator. It renders an &lt;input&gt; that lets you enter the temperature, and keeps its value in this.state.temperature. 接下来，我们将创建一个名为Calculator的组件。 它渲染一个允许您输入温度的&lt;input&gt;，并将其值保存在this.state.temperature中。 Additionally, it renders the BoilingVerdict for the current input value. 此外，它为BoilingVerdict提供当前输入值。 123456789101112131415161718192021222324252627class Calculator extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123;temperature: &apos;&apos;&#125;; &#125; handleChange(e) &#123; this.setState(&#123;temperature: e.target.value&#125;); &#125; render() &#123; const temperature = this.state.temperature; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in Celsius:&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(temperature)&#125; /&gt; &lt;/fieldset&gt; ); &#125; &#125; Try it on CodePen. Adding a Second Input(添加第二个输入)Our new requirement is that, in addition to a Celsius input, we provide a Fahrenheit input, and they are kept in sync. 我们的新要求是，除了摄氏度的输入，我们提供华氏度的输入，并保持同步。 We can start by extracting a TemperatureInput component from Calculator. We will add a new scale prop to it that can either be &quot;c&quot; or &quot;f&quot;: 我们可以从Calculator中提取一个TemperatureInput组件。 我们将添加一个可以是“c”或“f”的新scale 属性： 12345678910111213141516171819202122232425262728const scaleNames = &#123; c: &apos;Celsius&apos;, f: &apos;Fahrenheit&apos;&#125;;class TemperatureInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123;temperature: &apos;&apos;&#125;; &#125; handleChange(e) &#123; this.setState(&#123;temperature: e.target.value&#125;); &#125; render() &#123; const temperature = this.state.temperature; const scale = this.props.scale; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/fieldset&gt; ); &#125;&#125; We can now change the Calculator to render two separate temperature inputs: 我们现在可以更改 Calculator ，以提供两个独立的温度输入： 12345678910class Calculator extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;TemperatureInput scale=&quot;c&quot; /&gt; &lt;TemperatureInput scale=&quot;f&quot; /&gt; &lt;/div&gt; ); &#125;&#125; Try it on CodePen. We have two inputs now, but when you enter the temperature in one of them, the other doesn’t update. This contradicts our requirement: we want to keep them in sync. 我们现在有两个输入，但是当您输入其中一个时，另一个不更新。 这与我们的要求相矛盾：我们希望保持同步。 We also can’t display the BoilingVerdict from Calculator. The Calculator doesn’t know the current temperature because it is hidden inside the TemperatureInput. 我们也无法从 Calculator显示BoilingVerdict。 Calculator不知道当前的温度，因为它隐藏在TemperatureInput内。 Writing Conversion Functions(写入转换功能)First, we will write two functions to convert from Celsius to Fahrenheit and back: 首先，我们将写入两个从【摄氏度转换为华氏度】和【华氏度转换为摄氏度】的函数： 1234567function toCelsius(fahrenheit) &#123; return (fahrenheit - 32) * 5 / 9;&#125;function toFahrenheit(celsius) &#123; return (celsius * 9 / 5) + 32;&#125; These two functions convert numbers. We will write another function that takes a string temperature and a converter function as arguments and returns a string. We will use it to calculate the value of one input based on the other input. 这两个函数转换数字。 我们将编写另一个函数，它将字符串温度和转换器函数作为参数，并返回一个字符串。 我们将使用它来根据其他输入来计算一个新的输入的值。 It returns an empty string on an invalid temperature, and it keeps the output rounded to the third decimal place: 它在一个无效的温度上返回一个空字符串，它保持输出四舍五入到小数点后三位： 123456789function tryConvert(temperature, convert) &#123; const input = parseFloat(temperature); if (Number.isNaN(input)) &#123; return ''; &#125; const output = convert(input); const rounded = Math.round(output * 1000) / 1000; return rounded.toString();&#125; For example, tryConvert(&#39;abc&#39;, toCelsius) returns an empty string, and tryConvert(&#39;10.22&#39;, toFahrenheit) returns &#39;50.396&#39;. 例如， tryConvert(&#39;abc&#39;, toCelsius) 返回一个空字符串，而tryConvert(&#39;10.22&#39;, toFahrenheit) 返回’50 .396’。 Lifting State Up(提升状态)Currently, both TemperatureInput components independently keep their values in the local state: 目前，两个TemperatureInput组件都将其值保持在本地状态： 12345678910111213class TemperatureInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); this.state = &#123;temperature: &apos;&apos;&#125;; &#125; handleChange(e) &#123; this.setState(&#123;temperature: e.target.value&#125;); &#125; render() &#123; const temperature = this.state.temperature; However, we want these two inputs to be in sync with each other. When we update the Celsius input, the Fahrenheit input should reflect the converted temperature, and vice versa. 然而，我们希望这两个输入是相互同步的。 当我们更新摄氏温度输入时，华氏输入应反映转换温度，反之亦然。 In React, sharing state is accomplished by moving it up to the closest common ancestor of the components that need it. This is called “lifting state up”. We will remove the local state from the TemperatureInput and move it into the Calculator instead. 在React中，共享状态是通过将其移动到需要它的组件的最近的共同父组件中来实现的。 这被称为&quot;提升状态&quot;。 我们将从TemperatureInput中删除本地状态，并将其移动到Calculator中。 If the Calculator owns the shared state, it becomes the “source of truth” for the current temperature in both inputs. It can instruct them both to have values that are consistent with each other. Since the props of both TemperatureInput components are coming from the same parent Calculator component, the two inputs will always be in sync. 如果 Calculator 拥有共享状态，则它将成为两个当前温度的输入的“真实来源”。 它可以指定他们具有彼此一致的值。 由于两个TemperatureInput组件的属性来自同一个父组件： Calculator，所以两个输入的值将始终保持同步。 Let’s see how this works step by step. 让我们看看这是如何一步一步工作的。 First, we will replace this.state.temperature with this.props.temperature in the TemperatureInput component. For now, let’s pretend this.props.temperature already exists, although we will need to pass it from the Calculator in the future: 首先，我们将在TemperatureInput组件中用this.props.temperature替换this.state.temperature。 虽然我们将来需要从 Calculator 中传递给它，但现在，假设this.props.temperature已经存在： 123render() &#123; // Before: const temperature = this.state.temperature; const temperature = this.props.temperature; We know that props are read-only. When the temperature was in the local state, the TemperatureInput could just call this.setState() to change it. However, now that the temperature is coming from the parent as a prop, the TemperatureInput has no control over it. 我们知道属性是只读的。 当 temperature 处于本地状态时，TemperatureInput可以调用this.setState()来更改它。 然而，现在 temperature 来自父组件并作为作为子组件的属性，温度的输入无法控制。 In React, this is usually solved by making a component “controlled”. Just like the DOM &lt;input&gt; accepts both a value and an onChange prop, so can the custom TemperatureInput accept both temperature and onTemperatureChange props from its parent Calculator. 在React中，通常通过使组件“受控”来解决。 就像DOM &lt;input&gt;一样，同时接受一个 value 和一个 onChange 支持，所以自定义的TemperatureInput也可以接受来自其父组件(Calculator)的temperature和onTemperatureChange函数作为属性。 Now, when the TemperatureInput wants to update its temperature, it calls this.props.onTemperatureChange: 现在，当TemperatureInput想要更新其温度时，它会调用this.props.onTemperatureChange： 123handleChange(e) &#123; // Before: this.setState(&#123;temperature: e.target.value&#125;); this.props.onTemperatureChange(e.target.value); Note that there is no special meaning to either temperature or onTemperatureChange prop names in custom components. We could have called them anything else, like name them value and onChange which is a common convention. 请注意，自定义组件中的 temperature 或 onTemperatureChange 属性名称没有特殊的含义。 我们可以叫他们任何其他的东西，像命名他们的value和onChange这是一个常见的惯例。 The onTemperatureChange prop will be provided together with the temperature prop by the parent Calculator component. It will handle the change by modifying its own local state, thus re-rendering both inputs with the new values. We will look at the new Calculator implementation very soon. onTemperatureChange 属性将与父组件（temperature）的temperature属性一起提供。 它将通过修改自己的本地状态来处理更改，从而将输入的新值重新渲染到两个输入组件。 我们将很快看到新的Calculator实现。 Before diving into the changes in the Calculator, let’s recap our changes to the TemperatureInput component. We have removed the local state from it, and instead of reading this.state.temperature, we now read this.props.temperature. Instead of calling this.setState() when we want to make a change, we now call this.props.onTemperatureChange(), which will be provided by the Calculator: 在进入Calculator组件中更改之前，让我们回顾一下对TemperatureInput组件的更改。 我们已经从中删除了本地状态，而不是读取this.state.temperature，我们现在读取this.props.temperature。 我们现在调用由 Calculator提供的this.props.onTemperatureChange()函数，而不是调用this.setState()： 12345678910111213141516171819202122class TemperatureInput extends React.Component &#123; constructor(props) &#123; super(props); this.handleChange = this.handleChange.bind(this); &#125; handleChange(e) &#123; this.props.onTemperatureChange(e.target.value); &#125; render() &#123; const temperature = this.props.temperature; const scale = this.props.scale; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/fieldset&gt; ); &#125;&#125; Now let’s turn to the Calculator component. 现在我们来看一下Calculator组件。 We will store the current input’s temperature and scale in its local state. This is the state we “lifted up” from the inputs, and it will serve as the “source of truth” for both of them. It is the minimal representation of all the data we need to know in order to render both inputs. 我们将当前输入的temperature和scale存储在本地状态。 这是我们从输入中“提升”的状态，它将作为他们两个输入组件的“数据来源”。 为了渲染两个输入组件，我们需要知道数据对象的精简表示。 For example, if we enter 37 into the Celsius input, the state of the Calculator component will be: 例如，如果我们在摄氏度输入中输入37，则计算器组件的状态将是： 1234&#123; temperature: '37', scale: 'c'&#125; If we later edit the Fahrenheit field to be 212, the state of the Calculator will be: 如果我们稍后将“华氏”字段编辑为212，则Calculator的状态将为： 1234&#123; temperature: '212', scale: 'f'&#125; We could have stored the value of both inputs but it turns out to be unnecessary. It is enough to store the value of the most recently changed input, and the scale that it represents. We can then infer the value of the other input based on the current temperature and scale alone. 我们可以存储两个输入的值，但实际上是不必要的。 存储最近更改的输入的值以及它所代表的比例就足够了。 然后，我们可以基于当前的temperature和scale来推断其他输入的值。 The inputs stay in sync because their values are computed from the same state: 因为它们的值是从相同的状态计算的，所以输入能够保持同步： 123456789101112131415161718192021222324252627282930313233343536373839class Calculator extends React.Component &#123; constructor(props) &#123; super(props); this.handleCelsiusChange = this.handleCelsiusChange.bind(this); this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this); this.state = &#123;temperature: &apos;&apos;, scale: &apos;c&apos;&#125;; &#125; handleCelsiusChange(temperature) &#123; this.setState(&#123;scale: &apos;c&apos;, temperature&#125;); &#125; handleFahrenheitChange(temperature) &#123; this.setState(&#123;scale: &apos;f&apos;, temperature&#125;); &#125; render() &#123; const scale = this.state.scale; const temperature = this.state.temperature; const celsius = scale === &apos;f&apos; ? tryConvert(temperature, toCelsius) : temperature; const fahrenheit = scale === &apos;c&apos; ? tryConvert(temperature, toFahrenheit) : temperature; return ( &lt;div&gt; &lt;TemperatureInput scale=&quot;c&quot; temperature=&#123;celsius&#125; onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt; &lt;TemperatureInput scale=&quot;f&quot; temperature=&#123;fahrenheit&#125; onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(celsius)&#125; /&gt; &lt;/div&gt; ); &#125;&#125; Try it on CodePen. Now, no matter which input you edit, this.state.temperature and this.state.scale in the Calculator get updated. One of the inputs gets the value as is, so any user input is preserved, and the other input value is always recalculated based on it. 现在，无论您编辑哪个输入，Calculator中的this.state.temperature和this.state.scale都会更新。 其中一个输入组件获取值，所以任何用户输入都被保留，另一个输入组件总是基于它重新计算值。 Let’s recap what happens when you edit an input: 让我们回顾一下编辑输入时会发生什么： React calls the function specified as onChange on the DOM &lt;input&gt;. In our case, this is the handleChange method in TemperatureInput component. React调用在DOM &lt;input&gt;上指定为onChange的函数。 在我们的例子中，这是调用TemperatureInput组件中的handleChange方法。 The handleChange method in the TemperatureInput component calls this.props.onTemperatureChange() with the new desired value. Its props, including onTemperatureChange, were provided by its parent component, the Calculator. TemperatureInput组件中的handleChange函数使用新的输入值调用this.props.onTemperatureChange()函数。 其属性包括onTemperatureChange，由其父组件Calculator提供。 When it previously rendered, the Calculator has specified that onTemperatureChange of the Celsius TemperatureInput is the Calculator‘s handleCelsiusChange method, and onTemperatureChange of the Fahrenheit TemperatureInput is the Calculator‘s handleFahrehnheitChange method. So either of these two Calculator methods gets called depending on which input we edited. 当它初次渲染时，Calculator已经指定了摄氏组件TemperatureInput的onTemperatureChange函数作为Calculator的handleCelsiusChange方法的回调，而华氏组件TemperatureInput的onTemperatureChange函数作为Calculator的handleFahrehnheitChange方法的回调。 因此，根据我们编辑的输入，回调这两个Calculator方法。 Inside these methods, the Calculator component asks React to re-render itself by calling this.setState() with the new input value and the current scale of the input we just edited. 在这些方法中，Calculator 组件要求React通过使用新的输入值和刚刚编辑输入的当前比例调用this.setState（）来重新渲染自身。 React calls the Calculator component’s render method to learn what the UI should look like. The values of both inputs are recomputed based on the current temperature and the active scale. The temperature conversion is performed here. React调用Calculator组件的render方法了解UI的外观。 基于当前温度和有效刻度重新计算两个输入的值，并在这里进行温度转换。 React calls the render methods of the individual TemperatureInput components with their new props specified by the Calculator. It learns what their UI should look like. React使用计算器指定的新属性值调用各个·TemperatureInput·组件的render方法。 它会了解UI的外观。 React DOM updates the DOM to match the desired input values. The input we just edited receives its current value, and the other input is updated to the temperature after conversion. React DOM更新DOM以匹配所需的输入值。 我们刚刚编辑的输入接收其当前值，另一个输入更新为转换后的温度。 Every update goes through the same steps so the inputs stay in sync. 每个更新都会执行相同的步骤，以便输入保持同步。 Lessons Learned(学到的经验)There should be a single “source of truth” for any data that changes in a React application. Usually, the state is first added to the component that needs it for rendering. Then, if other components also need it, you can lift it up to their closest common ancestor. Instead of trying to sync the state between different components, you should rely on the top-down data flow. 对于在React应用程序中更改的任何数据，应该有一个“真实来源”。 通常，状态首先被添加到需要渲染的组件中。 然后，如果其他组件也需要它，您可以将其提升到最近的同一父组件。 而不是尝试同步不同组件之间的状态，您应该依靠自上而下的数据流。 Lifting state involves writing more “boilerplate” code than two-way binding approaches, but as a benefit, it takes less work to find and isolate bugs. Since any state “lives” in some component and that component alone can change it, the surface area for bugs is greatly reduced. Additionally, you can implement any custom logic to reject or transform user input. 提升状态涉及编写比“双向绑定”方法更多的“样板”代码，但有一个好处，找到隔离错误的工作要少一些。 由于任何状态“生活“在某些组件中，并且该组件单独可以改变它，所以错误的表面积大大降低。 此外，您可以实现任何自定义逻辑来拒绝或转换用户输入。 If something can be derived from either props or state, it probably shouldn’t be in the state. For example, instead of storing both celsiusValue and fahrenheitValue, we store just the last edited temperature and its scale. The value of the other input can always be calculated from them in the render() method. This lets us clear or apply rounding to the other field without losing any precision in the user input. 如果数据可以从属性或状态得到，那么它可能不应该处于状态。 例如，我们不是存储celsiusValue和fahrenheitValue，而是仅存储最后编辑的temperature 和 scale。 在render（）方法中，其他输入的值始终可以从它们中计算出来。 这使我们可以清除或应用四舍五入到其他字段，而不会在用户输入中丢失任何精度。 When you see something wrong in the UI, you can use React Developer Tools to inspect the props and move up the tree until you find the component responsible for updating the state. This lets you trace the bugs to their source: 当您在UI中看到错误时，您可以使用React Developer Tools来检查道具，并向上移动树，直到找到负责更新状态的组件。 这可以让你跟踪这些错误来源：]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Forms(表单)]]></title>
    <url>%2F2017%2F04%2F05%2Frqd-forms%2F</url>
    <content type="text"><![CDATA[HTML form elements work a little bit differently from other DOM elements in React, because form elements naturally keep some internal state. For example, this form in plain HTML accepts a single name: HTML表单元素与React中的其他DOM元素有所不同，因为表单元素自然地保持一些内部状态。 例如，这个HTML格式的表单接受一个单一的名字： 1234567&lt;form&gt; &lt;label&gt; Name: &lt;input type="text" name="name" /&gt; &lt;/label&gt; &lt;input type="submit" value="Submit" /&gt;&lt;/form&gt; This form has the default HTML form behavior of browsing to a new page when the user submits the form. If you want this behavior in React, it just works. But in most cases, it’s convenient to have a JavaScript function that handles the submission of the form and has access to the data that the user entered into the form. The standard way to achieve this is with a technique called “controlled components”. 当用户提交表单时，此表单具有[默认HTML表单(跳转到)新页面的行为]。 如果你想要这个行为在React中工作。 但是在大多数情况下，拥有处理提交表单（并）可访问用户输入表单的数据的（JavaScript函数）很方便。 实现这一点的标准方式是使用一种称为&quot;受控组件&quot;的技术。 Controlled Components(受控组件)In HTML, form elements such as &lt;input&gt;, &lt;textarea&gt;, and &lt;select&gt; typically maintain their own state and update it based on user input. In React, mutable state is typically kept in the state property of components, and only updated with setState(). 在HTML中，诸如&lt;input&gt;，&lt;textarea&gt;和&lt;select&gt;的表单元素通常保持自己的状态，并根据用户输入进行更新。 在React中，可变状态通常保存在组件的状态属性中，并且只能使用setState()进行更新。 We can combine the two by making the React state be the “single source of truth”. Then the React component that renders a form also controls what happens in that form on subsequent user input. An input form element whose value is controlled by React in this way is called a “controlled component”. 我们可以结合两者，使React的状态成为“真实数据的来源”。 然后，渲染表单的React组件也控制在后续用户输入时该表单中发生的情况。 以这种方式，其值由React控制的输入表单元素称为&quot;受控组件&quot;。 For example, if we want to make the previous example log the name when it is submitted, we can write the form as a controlled component: 例如，如果我们想使上一个示例在提交时记录名称，我们可以将表单写为受控组件： 123456789101112131415161718192021222324252627282930class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;value: &apos;&apos;&#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert(&apos;A name was submitted: &apos; + this.state.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; ); &#125;&#125; Try it on CodePen. Since the value attribute is set on our form element, the displayed value will always be this.state.value, making the React state the source of truth. Since handleChange runs on every keystroke to update the React state, the displayed value will update as the user types. 由于在我们的表单元素上设置了value属性，并且使React的状态成为数据的来源，所以显示的值始终为this.state.value。 由于handleChange在每个按键上触发输入以更新React状态，所以显示的值将随用户的输入更新。 With a controlled component, every state mutation will have an associated handler function. This makes it straightforward to modify or validate user input. For example, if we wanted to enforce that names are written with all uppercase letters, we could write handleChange as: 使用受控组件，每个状态的变化将具有相关联的处理函数。 这使得可以直接修改或验证用户输入。 例如，如果我们要强制这个名字用全部大写字母写，我们可以把handleChange写成： 123handleChange(event) &#123; this.setState(&#123;value: event.target.value.toUpperCase()&#125;);&#125; The textarea Tag(textarea标签)In HTML, a &lt;textarea&gt; element defines its text by its children: 在HTML中，&lt;textarea&gt;元素由其子元素定义其文本： 123&lt;textarea&gt; Hello there, this is some text in a text area&lt;/textarea&gt; In React, a &lt;textarea&gt; uses a value attribute instead. This way, a form using a &lt;textarea&gt; can be written very similarly to a form that uses a single-line input: 在React中，&lt;textarea&gt;使用value属性替代。 这样，使用&lt;textarea&gt;的表单非常类似于使用单行输入的表单： 1234567891011121314151617181920212223242526272829303132class EssayForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: &apos;Please write an essay about your favorite DOM element.&apos; &#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert(&apos;An essay was submitted: &apos; + this.state.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Name: &lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; ); &#125;&#125; Notice that this.state.value is initialized in the constructor, so that the text area starts off with some text in it. 请注意，在构造函数中初始化this.state.value，以便文本区域使用这些文本开始显示。 The select Tag( &lt;select&gt; 标签)In HTML, &lt;select&gt; creates a drop-down list. For example, this HTML creates a drop-down list of flavors: 在HTML中，&lt;select&gt;创建一个下拉列表。 例如，此HTML创建一个下拉列表的风格： 123456&lt;select&gt; &lt;option value="grapefruit"&gt;Grapefruit&lt;/option&gt; &lt;option value="lime"&gt;Lime&lt;/option&gt; &lt;option selected value="coconut"&gt;Coconut&lt;/option&gt; &lt;option value="mango"&gt;Mango&lt;/option&gt;&lt;/select&gt; Note that the Coconut option is initially selected, because of the selected attribute. React, instead of using this selected attribute, uses a value attribute on the root select tag. This is more convenient in a controlled component because you only need to update it in one place. For example: 请注意，由于 selected 的属性初始值设置了Coconut选项。 在React中，使用根select 标签上的value属性，替代selected的属性。这在受控组件中更方便，因为您只需要在一个位置更新它。 例如： 1234567891011121314151617181920212223242526272829303132333435class FlavorForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;value: &apos;coconut&apos;&#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert(&apos;Your favorite flavor is: &apos; + this.state.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; Pick your favorite La Croix flavor: &lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt; &lt;option value=&quot;grapefruit&quot;&gt;Grapefruit&lt;/option&gt; &lt;option value=&quot;lime&quot;&gt;Lime&lt;/option&gt; &lt;option value=&quot;coconut&quot;&gt;Coconut&lt;/option&gt; &lt;option value=&quot;mango&quot;&gt;Mango&lt;/option&gt; &lt;/select&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt; &lt;/form&gt; ); &#125;&#125; Try it on CodePen. Overall, this makes it so that &lt;input type=&quot;text&quot;&gt;, &lt;textarea&gt;, and &lt;select&gt; all work very similarly - they all accept a value attribute that you can use to implement a controlled component. 总的来说，这样做使得&lt;input type =&quot;text&quot;&gt;，&lt;textarea&gt;和&lt;select&gt;运行都非常相似 - 它们都接受一个 value 属性，您可以使用它来实现受控组件。 Handling Multiple Inputs(处理多个输入)When you need to handle multiple controlled input elements, you can add a name attribute to each element and let the handler function choose what to do based on the value of event.target.name. 当您需要处理多个受控 input 元素时，可以向每个元素添加一个 name 属性，让处理函数根据event.target.name的值来选择要执行的操作。 For example: 例如： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Reservation extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isGoing: true, numberOfGuests: 2 &#125;; this.handleInputChange = this.handleInputChange.bind(this); &#125; handleInputChange(event) &#123; const target = event.target; const value = target.type === &apos;checkbox&apos; ? target.checked : target.value; const name = target.name; this.setState(&#123; [name]: value &#125;); &#125; render() &#123; return ( &lt;form&gt; &lt;label&gt; Is going: &lt;input name=&quot;isGoing&quot; type=&quot;checkbox&quot; checked=&#123;this.state.isGoing&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;br /&gt; &lt;label&gt; Number of guests: &lt;input name=&quot;numberOfGuests&quot; type=&quot;number&quot; value=&#123;this.state.numberOfGuests&#125; onChange=&#123;this.handleInputChange&#125; /&gt; &lt;/label&gt; &lt;/form&gt; ); &#125;&#125; Try it on CodePen. Note how we used the ES6 computed property name syntax to update the state key corresponding to the given input name: 注意我们如何使用ES6 计算属性名称 的语法来更新与给定输入名称相对应的状态键： 123this.setState(&#123; [name]: value&#125;); It is equivalent to this ES5 code: 这相当于这个ES5代码： 123var partialState = &#123;&#125;;partialState[name] = value;this.setState(partialState); Also, since setState() automatically merges a partial state into the current state, we only needed to call it with the changed parts. 此外，由于setState()自动将部分状态合并到当前状态，所以我们只需要调用它去改变更改的部分。 Alternatives to Controlled ComponentsIt can sometimes be tedious to use controlled components, because you need to write an event handler for every way your data can change and pipe all of the input state through a React component. This can become particularly annoying when you are converting a preexisting codebase to React, or integrating a React application with a non-React library. In these situations, you might want to check out uncontrolled components, an alternative technique for implementing input forms. 使用受控组件有时可能很繁琐，因为您需要为数据可以更改的每种方式编写一个事件处理程序，并通过一个React组件管理所有的输入状态。 当您将预先存在的代码库转换为React或将React应用程序与非React库集成时，这可能变得特别烦人。 在这些情况下，您可能需要检查不受控制的组件，这是实现输入表单的替代技术。]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Lists and Keys(列表和键)]]></title>
    <url>%2F2017%2F04%2F04%2Frqd-lists-and-keys%2F</url>
    <content type="text"><![CDATA[First, let’s review how you transform lists in JavaScript. 首先，我们来看看如何在JavaScript中转换列表。 Given the code below, we use the map() function to take an array of numbers and double their values. We assign the new array returned by map() to the variable doubled and log it: 给出下面的代码，我们使用map（）函数操作一个 numbers 数组，并将其值加倍。 我们将map（）返回的翻倍的数组分配给一个新数组并输出它： 123const numbers = [1, 2, 3, 4, 5];const doubled = numbers.map((number) =&gt; number * 2);console.log(doubled); This code logs [2, 4, 6, 8, 10] to the console. 此代码将数组 [2, 4, 6, 8, 10] 输出到控制台。 In React, transforming arrays into lists of elements is nearly identical. 在React中，将数组转换为元素列表几乎相同。 Rendering Multiple Components(渲染多个组件)You can build collections of elements and include them in JSX using curly braces {}. 您可以构建元素集合，并使用花括号{}将它们包含在JSX中。 Below, we loop through the numbers array using the Javascript map() function. We return an &lt;li&gt; element for each item. Finally, we assign the resulting array of elements to listItems: 下面，我们使用Javascript map（）函数将 numbers 数组进行循环操作。 我们返回每个项目的&lt;li&gt;元素。 最后，我们将结果的元素数组分配给listItems： 1234const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt; &lt;li&gt;&#123;number&#125;&lt;/li&gt;); We include the entire listItems array inside a &lt;ul&gt; element, and render it to the DOM: 我们将整个listItems数组包含在一个&lt;ul&gt;元素中，并将其渲染到DOM中： 1234ReactDOM.render( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;, document.getElementById(&apos;root&apos;)); Try it on CodePen. This code displays a bullet list of numbers between 1 and 5. 此代码显示1到5之间的数字项目符号列表。 Basic List Component(基本列表组件)Usually you would render lists inside a component. 通常你会在一个组件中渲染列表。 We can refactor the previous example into a component that accepts an array of numbers and outputs an unordered list of elements. 我们可以将前面的例子重构成接受数字数组的一个组件，并输出一个无序的元素列表。 123456789101112131415function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li&gt;&#123;number&#125;&lt;/li&gt; ); return ( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById(&apos;root&apos;)); When you run this code, you’ll be given a warning that a key should be provided for list items. A “key” is a special string attribute you need to include when creating lists of elements. We’ll discuss why it’s important in the next section. 当您运行此代码时，您将被给予一个警告，以便为列表项提供一个密钥。 “key” 是创建元素列表时需要包含的特殊字符串属性。 我们将在下一节讨论为什么它很重要。 Let’s assign a key to our list items inside numbers.map() and fix the missing key issue. 让我们分配一个key到我们的list.map（）列表项中，并修复缺少的关键字问题。 1234567891011121314151617function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key=&#123;number.toString()&#125;&gt; &#123;number&#125; &lt;/li&gt; ); return ( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById(&apos;root&apos;)); Try it on CodePen. Keys(键)Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity: 键帮助React确定哪些项目已更改，添加或删除。 应该给元素数组中的元素赋予一个稳定的身份： 123456const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt; &lt;li key=&#123;number.toString()&#125;&gt; &#123;number&#125; &lt;/li&gt;); The best way to pick a key is to use a string that uniquely identifies a list item among its siblings. Most often you would use IDs from your data as keys: 选择key的最好方法是使用一个字符串来唯一标识其组件之间的列表项。 您通常会使用数据中的ID作为key： 12345const todoItems = todos.map((todo) =&gt; &lt;li key=&#123;todo.id&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;); When you don’t have stable IDs for rendered items, you may use the item index as a key as a last resort: 当您没有用于渲染项目的稳定ID时，您可以使用项目索引作为key的最后手段： 123456const todoItems = todos.map((todo, index) =&gt; // Only do this if items have no stable IDs &lt;li key=&#123;index&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;); We don’t recommend using indexes for keys if the items can reorder, as that would be slow. You may read an in-depth explanation about why keys are necessary if you’re interested. 如果项目可以重新排序，我们不建议使用键的索引，因为这会很慢。 如果您有兴趣，您可以阅读《深入了解为什么需要键》。 Extracting Components with Keys(用键提取组件)Keys only make sense in the context of the surrounding array. 键只有在数组周围的上下文中才有意义。 For example, if you extract a ListItem component, you should keep the key on the &lt;ListItem /&gt; elements in the array rather than on the root &lt;li&gt; element in the ListItem itself. 例如，如果您提取了ListItem组件，则应该将该键保存在数组中的&lt;ListItem /&gt;元素上，而不是ListItem本身中的根&lt;li&gt;元素上。 Example: Incorrect Key Usage 示例：不正确使用密钥 12345678910111213141516171819202122232425262728function ListItem(props) &#123; const value = props.value; return ( // 错误！ 这里没有必要指定键： &lt;li key=&#123;value.toString()&#125;&gt; &#123;value&#125; &lt;/li&gt; );&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 错误！ key应该在这里指定： &lt;ListItem value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById(&apos;root&apos;)); Example: Correct Key Usage 示例：正确使用密钥 1234567891011121314151617181920212223function ListItem(props) &#123; // 正确！ 这里没有必要指定键： return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 正确！ key应在数组内指定。 &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById(&apos;root&apos;)); Try it on CodePen. A good rule of thumb is that elements inside the map() call need keys. 一个很好的经验法则是在map（）函数调用中添加元素需要的key。 Keys Must Only Be Unique Among Siblings(Key在兄弟组件中必须是唯一的)Keys used within arrays should be unique among their siblings. However they don’t need to be globally unique. We can use the same keys when we produce two different arrays: 数组中使用的Key在其兄弟组件之间应该是唯一的。 然而，它们不需要是全局唯一的。 当我们生成两个不同的数组时，我们可以使用相同的键： 123456789101112131415161718192021222324252627282930313233function Blog(props) &#123; const sidebar = ( &lt;ul&gt; &#123;props.posts.map((post) =&gt; &lt;li key=&#123;post.id&#125;&gt; &#123;post.title&#125; &lt;/li&gt; )&#125; &lt;/ul&gt; ); const content = props.posts.map((post) =&gt; &lt;div key=&#123;post.id&#125;&gt; &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt; &lt;p&gt;&#123;post.content&#125;&lt;/p&gt; &lt;/div&gt; ); return ( &lt;div&gt; &#123;sidebar&#125; &lt;hr /&gt; &#123;content&#125; &lt;/div&gt; );&#125;const posts = [ &#123;id: 1, title: &apos;Hello World&apos;, content: &apos;Welcome to learning React!&apos;&#125;, &#123;id: 2, title: &apos;Installation&apos;, content: &apos;You can install React from npm.&apos;&#125;];ReactDOM.render( &lt;Blog posts=&#123;posts&#125; /&gt;, document.getElementById(&apos;root&apos;)); Try it on CodePen. Keys serve as a hint to React but they don’t get passed to your components. If you need the same value in your component, pass it explicitly as a prop with a different name: Key充当React的一个提示，但它不会传递给您的组件。 如果您的组件中需要相同的值，请将其作为具有不同名称的属性进行显式传递： 123456const content = posts.map((post) =&gt; &lt;Post key=&#123;post.id&#125; id=&#123;post.id&#125; title=&#123;post.title&#125; /&gt;); With the example above, the Post component can read props.id, but not props.key. 通过上面的例子，Post组件可以读取props.id，而不是props.key。 Embedding map() in JSX(在JSX中嵌入map() )In the examples above we declared a separate listItems variable and included it in JSX: 在上面的例子中，我们声明了一个单独的listItems变量并将其包含在JSX中： 123456789101112function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125; JSX allows embedding any expressions in curly braces so we could inline the map() result: JSX允许将任何表达式嵌入到花括号中，以便我们可以内联map（）结果： 1234567891011function NumberList(props) &#123; const numbers = props.numbers; return ( &lt;ul&gt; &#123;numbers.map((number) =&gt; &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; )&#125; &lt;/ul&gt; );&#125; Try it on CodePen. Sometimes this results in clearer code, but this style can also be abused. Like in JavaScript, it is up to you to decide whether it is worth extracting a variable for readability. Keep in mind that if the map() body is too nested, it might be a good time to extract a component. 有时这会使代码更清晰的，但这种风格写法也可能被滥用。 像JavaScript一样，由你决定是否值得提取可变性的变量。 请记住，如果map（）内容嵌套太深，这可能是提取组件的好时机。]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Conditional Rendering(条件渲染)]]></title>
    <url>%2F2017%2F04%2F03%2Frqd-conditional-rendering%2F</url>
    <content type="text"><![CDATA[In React, you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application. 在React中，您可以创建不同的组件来封装所需的行为。 然后，您可以只渲染其中的一部分，具体取决于应用程序的状态。 Conditional rendering in React works the same way conditions work in JavaScript. Use JavaScript operators like if or the conditional operator to create elements representing the current state, and let React update the UI to match them. React中的条件渲染与JavaScript中的条件相同。 使用if或条件运算符等JavaScript运算符创建表示当前状态的元素，然后让React更新UI来匹配它们。 Consider these two components: 考虑这两个组件： 1234567function UserGreeting(props) &#123; return &lt;h1&gt;Welcome back!&lt;/h1&gt;;&#125;function GuestGreeting(props) &#123; return &lt;h1&gt;Please sign up.&lt;/h1&gt;;&#125; We’ll create a Greeting component that displays either of these components depending on whether a user is logged in: 我们将创建一个Greeting组件，根据用户是否登录，显示这些组件之一： 12345678910111213function Greeting(props) &#123; const isLoggedIn = props.isLoggedIn; if (isLoggedIn) &#123; return &lt;UserGreeting /&gt;; &#125; return &lt;GuestGreeting /&gt;;&#125;ReactDOM.render( // Try changing to isLoggedIn=&#123;true&#125;: &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;, document.getElementById(&apos;root&apos;)); Try it on CodePen. This example renders a different greeting depending on the value of isLoggedIn prop. 此示例根据isLoggedIn prop的值呈现不同的问候语。 Element Variables(元素变量)You can use variables to store elements. This can help you conditionally render a part of the component while the rest of the output doesn’t change. 您可以使用变量来存储元素。 这可以帮助您有条件地渲染组件的一部分，而输出的其余部分不会更改。 Consider these two new components representing Logout and Login buttons: 考虑这两个代表注销和登录按钮的新组件： 123456789101112131415function LoginButton(props) &#123; return ( &lt;button onClick=&#123;props.onClick&#125;&gt; Login &lt;/button&gt; );&#125;function LogoutButton(props) &#123; return ( &lt;button onClick=&#123;props.onClick&#125;&gt; Logout &lt;/button&gt; );&#125; In the example below, we will create a stateful component called LoginControl. 在下面的例子中，我们将创建一个名为LoginControl的有状态组件。 It will render either &lt;LoginButton /&gt; or &lt;LogoutButton /&gt; depending on its current state. It will also render a &lt;Greeting /&gt; from the previous example: 它将根据当前状态渲染&lt;LoginButton /&gt;或&lt;LogoutButton /&gt;。 它还将从上一个示例中呈现&lt;Greeting /&gt;： 123456789101112131415161718192021222324252627282930313233343536373839class LoginControl extends React.Component &#123; constructor(props) &#123; super(props); this.handleLoginClick = this.handleLoginClick.bind(this); this.handleLogoutClick = this.handleLogoutClick.bind(this); this.state = &#123;isLoggedIn: false&#125;; &#125; handleLoginClick() &#123; this.setState(&#123;isLoggedIn: true&#125;); &#125; handleLogoutClick() &#123; this.setState(&#123;isLoggedIn: false&#125;); &#125; render() &#123; const isLoggedIn = this.state.isLoggedIn; let button = null; if (isLoggedIn) &#123; button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;; &#125; else &#123; button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;; &#125; return ( &lt;div&gt; &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt; &#123;button&#125; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;LoginControl /&gt;, document.getElementById(&apos;root&apos;)); Try it on CodePen. While declaring a variable and using an if statement is a fine way to conditionally render a component, sometimes you might want to use a shorter syntax. There are a few ways to inline conditions in JSX, explained below. 虽然声明变量并使用if语句是有条件地渲染组件的好方法，但有时您可能希望使用较短的语法。 在JSX中有几种内联条件的方法，如下所述。 Inline If with Logical &amp;&amp; Operator(内联[比较运算符或逻辑运算符])You may embed any expressions in JSX by wrapping them in curly braces. This includes the JavaScript logical &amp;&amp; operator. It can be handy for conditionally including an element: 您可以在JSX中嵌入任何表达式，方法是将其包裹在花括号中。 这包括JavaScript逻辑&amp;&amp;运算符。 它有助于有条件地渲染一个元素： 12345678910111213141516171819function Mailbox(props) &#123; const unreadMessages = props.unreadMessages; return ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &#123;unreadMessages.length &gt; 0 &amp;&amp; &lt;h2&gt; You have &#123;unreadMessages.length&#125; unread messages. &lt;/h2&gt; &#125; &lt;/div&gt; );&#125;const messages = [&apos;React&apos;, &apos;Re: React&apos;, &apos;Re:Re: React&apos;];ReactDOM.render( &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;, document.getElementById(&apos;root&apos;)); Try it on CodePen. It works because in JavaScript, true &amp;&amp; expression always evaluates to expression, and false &amp;&amp; expression always evaluates to false. 因为在JavaScript中，它是有效的，true &amp;&amp; expression总是认为表达式，并且 false &amp;&amp; expression 总是认为false。 Therefore, if the condition is true, the element right after &amp;&amp; will appear in the output. If it is false, React will ignore and skip it. 所以，如果条件为true，则&amp;&amp;后面的元素将显示在输出中。 如果是false，React会忽略并跳过它。 Inline If-Else with Conditional Operator(内联[if-Else有条件运算符])Another method for conditionally rendering elements inline is to use the JavaScript conditional operator condition ? true : false. 有条件地渲染元素的另一种方法是使用JavaScript条件运算符条件 ? 真 : 假. In the example below, we use it to conditionally render a small block of text. 12345678render() &#123; const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; The user is &lt;b&gt;&#123;isLoggedIn ? &apos;currently&apos; : &apos;not&apos;&#125;&lt;/b&gt; logged in. &lt;/div&gt; );&#125; It can also be used for larger expressions although it is less obvious what’s going on: 虽然不太明显改变了什么，但它也可以用于更复杂的表达式： 123456789101112render() &#123; const isLoggedIn = this.state.isLoggedIn; return ( &lt;div&gt; &#123;isLoggedIn ? ( &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt; ) : ( &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt; )&#125; &lt;/div&gt; );&#125; Just like in JavaScript, it is up to you to choose an appropriate style based on what you and your team consider more readable. Also remember that whenever conditions become too complex, it might be a good time to extract a component. 就像在JavaScript中一样，您可以根据您和您的团队认为更易读的方式选择合适的样式。 还要记住，只要条件变得太复杂，可能是提取组件的好时机。 Preventing Component from Rendering(防止组件渲染)In rare cases you might want a component to hide itself even though it was rendered by another component. To do this return null instead of its render output. 在极少数情况下，您可能希望组件隐藏自身，即使它由另一个组件呈现。 为此，返回null而不是其渲染输出。 In the example below, the &lt;WarningBanner /&gt; is rendered depending on the value of the prop called warn. If the value of the prop is false, then the component does not render: 在下面的示例中，根据名为warn的属性值渲染&lt;WarningBanner /&gt;。 如果属性值为false，则该组件不呈现： 1234567891011121314151617181920212223242526272829303132333435363738394041function WarningBanner(props) &#123; if (!props.warn) &#123; return null; &#125; return ( &lt;div className=&quot;warning&quot;&gt; Warning! &lt;/div&gt; );&#125;class Page extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;showWarning: true&#125; this.handleToggleClick = this.handleToggleClick.bind(this); &#125; handleToggleClick() &#123; this.setState(prevState =&gt; (&#123; showWarning: !prevState.showWarning &#125;)); &#125; render() &#123; return ( &lt;div&gt; &lt;WarningBanner warn=&#123;this.state.showWarning&#125; /&gt; &lt;button onClick=&#123;this.handleToggleClick&#125;&gt; &#123;this.state.showWarning ? &apos;Hide&apos; : &apos;Show&apos;&#125; &lt;/button&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Page /&gt;, document.getElementById(&apos;root&apos;)); Try it on CodePen. Returning null from a component’s render method does not affect the firing of the component’s lifecycle methods. For instance, componentWillUpdate and componentDidUpdate will still be called. 从组件的render方法返回null不会影响组件生命周期方法的触发。 例如，componentWillUpdate和componentDidUpdate仍将被调用。]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Handling Events(处理事件)]]></title>
    <url>%2F2017%2F04%2F02%2Frqd-handling-events%2F</url>
    <content type="text"><![CDATA[Handling events with React elements is very similar to handling events on DOM elements. There are some syntactic differences: 使用React元素处理事件与处理DOM元素上的事件非常相似。 只不过有一些语法上的差异： React events are named using camelCase, rather than lowercase. React事件使用驼峰规则命名，而不是小写。 With JSX you pass a function as the event handler, rather than a string. 使用JSX，您可以传递一个函数作为事件处理程序，而不是一个字符串。 For example, the HTML: 例如，HTML： 123&lt;button onclick="activateLasers()"&gt; Activate Lasers&lt;/button&gt; is slightly different in React: 在React中略有不同： 123&lt;button onClick=&#123;activateLasers&#125;&gt; Activate Lasers&lt;/button&gt; Another difference is that you cannot return false to prevent default behavior in React. You must call preventDefault explicitly. For example, with plain HTML, to prevent the default link behavior of opening a new page, you can write: 另一个区别是您不能返回false以防止在React中的默认行为。 您必须显式调用preventDefault。 例如，使用纯HTML，为了防止打开新页面的默认链接行为，您可以写： 123&lt;a href="#" onclick="console.log('The link was clicked.'); return false"&gt; Click me&lt;/a&gt; In React, this could instead be: 在React中，这应该按如下方式代替： 123456789101112function ActionLink() &#123; function handleClick(e) &#123; e.preventDefault(); console.log(&apos;The link was clicked.&apos;); &#125; return ( &lt;a href=&quot;#&quot; onClick=&#123;handleClick&#125;&gt; Click me &lt;/a&gt; );&#125; Here, e is a synthetic event. React defines these synthetic events according to the W3C spec, so you don’t need to worry about cross-browser compatibility. See the SyntheticEvent reference guide to learn more. 在这里，e是一个合成事件。 React根据W3C规范定义了这些合成事件，因此您不必担心跨浏览器的兼容性。 请参阅SyntheticEvent参考指南了解更多信息。 When using React you should generally not need to call addEventListener to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered. 当使用React时，您通常不需要调用addEventListener来在创建DOM元素之后添加监听器。 而是在元素最初呈现时提供一个监听器。 When you define a component using an ES6 class, a common pattern is for an event handler to be a method on the class. For example, this Toggle component renders a button that lets the user toggle between “ON” and “OFF” states: 当您使用ES6类定义组件时，常见的模式是将事件处理程序作为类上的方法。 例如，Toggle组件呈现一个按钮，让用户在“ON”和“OFF”状态之间切换： 12345678910111213141516171819202122232425262728class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isToggleOn: true&#125;; // This binding is necessary to make `this` work in the callback this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125; &lt;/button&gt; ); &#125;&#125;ReactDOM.render( &lt;Toggle /&gt;, document.getElementById(&apos;root&apos;)); Try it on CodePen. You have to be careful about the meaning of this in JSX callbacks. In JavaScript, class methods are not bound by default. If you forget to bind this.handleClick and pass it to onClick, this will be undefined when the function is actually called. 在JSX回调中你必须要注意this的含义。 在JavaScript中，类方法默认不受约束。 如果您忘记绑定this.handleClick并将其传递给onClick，那么当该函数实际被调用时，这将是未定义的。 This is not React-specific behavior; it is a part of how functions work in JavaScript. Generally, if you refer to a method without () after it, such as onClick={this.handleClick}, you should bind that method. 这不是React具体的行为; 它是JavaScript中功能如何工作的一部分。 一般来说，如果你引用一个没有（）的方法，比如onClick = {this.handleClick}，你应该绑定该方法。 If calling bind annoys you, there are two ways you can get around this. If you are using the experimental property initializer syntax, you can use property initializers to correctly bind callbacks: 如果调用绑定令你烦恼，有两种方法可以解决这个问题。 如果您使用实验属性初始化程序语法，则可以使用属性初始值设置来正确绑定回调： 123456789101112131415class LoggingButton extends React.Component &#123; // This syntax ensures `this` is bound within handleClick. // Warning: this is *experimental* syntax. handleClick = () =&gt; &#123; console.log(&apos;this is:&apos;, this); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/button&gt; ); &#125;&#125; This syntax is enabled by default in Create React App. 默认情况下，此语法在创建React应用程序中启用。 If you aren’t using property initializer syntax, you can use an arrow function in the callback: 如果您不使用属性初始化程序语法，则可以在回调中使用箭头函数： 1234567891011121314class LoggingButton extends React.Component &#123; handleClick() &#123; console.log(&apos;this is:&apos;, this); &#125; render() &#123; // This syntax ensures `this` is bound within handleClick return ( &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt; Click me &lt;/button&gt; ); &#125;&#125; The problem with this syntax is that a different callback is created each time the LoggingButton renders. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. We generally recommend binding in the constructor or using the property initializer syntax, to avoid this sort of performance problem. 这种语法的问题是：每次LoggingButton渲染时都会创建一个不同的回调函数。 在大多数情况下，这很好。 但是，如果这个回调作为支持传递给子组件，这些组件可能会进行额外的重新渲染。 我们通常建议在构造函数中使用绑定或使用属性初始化器语法来避免这种性能问题。]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[State and Lifecycle(状态和生命周期)]]></title>
    <url>%2F2017%2F04%2F01%2Frqd-state-and-lifecycle%2F</url>
    <content type="text"><![CDATA[Consider the ticking clock example from one of the previous sections. 考虑上一节的秒表时钟示例。 So far we have only learned one way to update the UI. 到目前为止，我们只学到了一种更新UI的方法。 We call ReactDOM.render() to change the rendered output: 我们调用 ReactDOM.render()来更改渲染的输出： 1234567891011121314function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) );&#125;setInterval(tick, 1000); Try it on CodePen. In this section, we will learn how to make the Clock component truly reusable and encapsulated. It will set up its own timer and update itself every second. 在本节中，我们将学习如何使Clock组件真正可重用和并对其封装。 它将设置自己的计时器并每秒更新一次。 We can start by encapsulating how the clock looks: 我们可以从封装时钟开始： 1234567891011121314151617function Clock(props) &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; );&#125;function tick() &#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125; /&gt;, document.getElementById(&apos;root&apos;) );&#125;setInterval(tick, 1000); Try it on CodePen. However, it misses a crucial requirement: the fact that the Clock sets up a timer and updates the UI every second should be an implementation detail of the Clock. 然而，它错过了一个关键的要求：Clock设置定时器并每秒更新UI的事实应该是Clock的实现细节。 Ideally we want to write this once and have the Clock update itself: 理想情况下，我们要写一下这个时钟更新本身： 1234ReactDOM.render( &lt;Clock /&gt;, document.getElementById(&apos;root&apos;)); To implement this, we need to add “state” to the Clock component. 为了实现这一点，我们需要在Clock组件中添加”state”。 State is similar to props, but it is private and fully controlled by the component. 状态(State)类似于属性，但它是私有的，完全由组件控制。 We mentioned before that components defined as classes have some additional features. Local state is exactly that: a feature available only to classes. 我们之前提到，定义为类的组件具有一些附加功能。 本地状态就是这样：一个功能只适用于类。 Converting a Function to a Class(将函数转换为类)You can convert a functional component like Clock to a class in five steps: Create an ES6 class with the same name that extends React.Component. Add a single empty method to it called render(). Move the body of the function into the render() method. Replace props with this.props in the render() body. Delete the remaining empty function declaration. 您可以通过五个步骤将时钟功能组件转换为类： 创建一个名称继承为React.Component的ES6类。 在类中添加一个名为render()的空方法。 将函数体移动到render()方法中。 在render()函数中使用this.props替换props。 删除剩余的空函数声明。 12345678910class Clock extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; Try it on CodePen. Clock is now defined as a class rather than a function. Clock现在被定义为一个类而不是一个函数。 This lets us use additional features such as local state and lifecycle hooks. 这使我们可以使用其他功能，如本地状态和生命周期的钩子函数。 Adding Local State to a Class(将本地状态添加到类)We will move the date from props to state in three steps: 我们将分三个步骤，将date的属性映射到状态。 1) Replace this.props.date with this.state.date in the render() method: 1）在render()方法中将this.props.date替换为this.state.date： 12345678910class Clock extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; 2) Add a class constructor that assigns the initial this.state: 2）添加分配初始this.state到类的构造函数中： 123456789101112131415class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; Note how we pass props to the base constructor: 注意我们如何将 props 传递给基础构造函数： 1234constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;;&#125; Class components should always call the base constructor with props. 类组件应始终使用 props调用基础构造函数。 3) Remove the date prop from the &lt;Clock /&gt; element: 3）从&lt;Clock /&gt;元素中删除日期： 1234ReactDOM.render( &lt;Clock /&gt;, document.getElementById(&apos;root&apos;)); We will later add the timer code back to the component itself. 稍后将定时器代码添加回组件本身。 The result looks like this: 结果如下： 1234567891011121314151617181920class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock /&gt;, document.getElementById(&apos;root&apos;)); Try it on CodePen. Next, we’ll make the Clock set up its own timer and update itself every second. 接下来，我们将使Clock设置自己的定时器并每秒更新一次。 Adding Lifecycle Methods to a Class(将生命周期方法添加到类中)In applications with many components, it’s very important to free up resources taken by the components when they are destroyed. 在具有许多组件的应用程序中，在销毁时释放组件所占用的资源非常重要。 We want to set up a timer whenever the Clock is rendered to the DOM for the first time. This is called “mounting” in React. 当Clock第一次渲染到DOM时，我们要设置一个定时器。 这在React中称为“挂载”。 We also want to clear that timer whenever the DOM produced by the Clock is removed. This is called “unmounting” in React. 当Clock产生的DOM被删除时，我们也想清除该计时器。 这在React中称为“卸载”。 We can declare special methods on the component class to run some code when a component mounts and unmounts: 当组件挂载和卸载时，我们可以在组件类上声明特殊的方法来运行一些代码： 1234567891011121314151617181920212223class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; componentDidMount() &#123; &#125; componentWillUnmount() &#123; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; These methods are called “lifecycle hooks”. 这些方法称为“生命周期钩子函数”。 The componentDidMount() hook runs after the component output has been rendered to the DOM. This is a good place to set up a timer: 在组件输出已经渲染给DOM之后， componentDidMount() 钩子函数运行。 这是一个建立定时器的好地方： 123456componentDidMount() &#123; this.timerID = setInterval( () =&gt; this.tick(), 1000 );&#125; Note how we save the timer ID right on this. 注意我们如何在this上保存正确的计时器ID。 While this.props is set up by React itself and this.state has a special meaning, you are free to add additional fields to the class manually if you need to store something that is not used for the visual output. 虽this.props由React本身设置，而this.state具有特殊的含义，但如果需要存储未用于可视输出的内容，则可以手动向类中添加其他字段。 If you don’t use something in render(), it shouldn’t be in the state. 如果您不在 render(),中使用某些东西，则不应该处于该状态。 We will tear down the timer in the componentWillUnmount() lifecycle hook: 我们将在componentWillUnmount()生命周期钩子函数中终止计时器： 123componentWillUnmount() &#123; clearInterval(this.timerID);&#125; Finally, we will implement the tick() method that runs every second. 最后，我们将实现每秒运行的tick() 方法。 It will use this.setState() to schedule updates to the component local state: 它将使用this.setState() 来计划更新组件的本地状态： 12345678910111213141516171819202122232425262728293031323334353637class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; componentDidMount() &#123; this.timerID = setInterval( () =&gt; this.tick(), 1000 ); &#125; componentWillUnmount() &#123; clearInterval(this.timerID); &#125; tick() &#123; this.setState(&#123; date: new Date() &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock /&gt;, document.getElementById(&apos;root&apos;)); Try it on CodePen. Now the clock ticks every second. 现在时钟每秒钟滴答滴答的跑个不停。 Let’s quickly recap what’s going on and the order in which the methods are called: 让我们快速回顾一下发生了什么以及调用方法的顺序： 1) When &lt;Clock /&gt; is passed to ReactDOM.render(), React calls the constructor of the Clock component. Since Clock needs to display the current time, it initializes this.state with an object including the current time. We will later update this state. 1）当&lt;Clock /&gt;传递给ReactDOM.render（）时，React调用Clock组件的构造函数。 由于Clock需要显示当前时间，所以它将使用包含当前时间的对象来初始化this.state。 我们稍后会更新此状态。 2) React then calls the Clock component’s render() method. This is how React learns what should be displayed on the screen. React then updates the DOM to match the Clock‘s render output. 2）React然后调用Clock组件的render（）方法。 这时React知道如何在屏幕上显示内容。 然后，React更新DOM以匹配Clock的渲染输出。 3) When the Clock output is inserted in the DOM, React calls the componentDidMount() lifecycle hook. Inside it, the Clock component asks the browser to set up a timer to call tick() once a second. 3）当时钟输出插入到DOM中时，React调用componentDidMount（）生命周期钩子函数。 在其中，Clock组件要求浏览器设置一个定时器来每秒调用tick（）一次。 4) Every second the browser calls the tick() method. Inside it, the Clock component schedules a UI update by calling setState() with an object containing the current time. Thanks to the setState() call, React knows the state has changed, and calls render() method again to learn what should be on the screen. This time, this.state.date in the render() method will be different, and so the render output will include the updated time. React updates the DOM accordingly. 4）浏览器每秒钟调用tick（）方法。 在其中，Clock组件通过使用包含当前时间的对象调用setState（）来调动UI更新。 感谢setState（）调用，React知道状态已经改变，并再次调用render（）方法来了解屏幕上应该更新或渲染什么。 这一次，render（）方法中的this.state.date将不同，因此渲染输出将包含更新的时间。 React会相应地更新DOM。 5) If the Clock component is ever removed from the DOM, React calls the componentWillUnmount() lifecycle hook so the timer is stopped. 5）如果时钟组件从DOM中删除，则React会调用componentWillUnmount（）生命周期钩子函数，以使定时器停止。 Using State Correctly（正确使用状态）There are three things you should know about setState(). 你应该知道有关setState（）的三件事情。 Do Not Modify State Directly(不要直接修改状态)For example, this will not re-render a component: 例如，这不会重新渲染组件： 12// Wrongthis.state.comment = 'Hello'; Instead, use setState(): 而是使用setState（）代替： 12// Correctthis.setState(&#123;comment: 'Hello'&#125;); The only place where you can assign this.state is the constructor. 唯一可以分配this.state的地方是构造函数。 State Updates May Be Asynchronous(状态更新可能是异步的)React may batch multiple setState() calls into a single update for performance. React可以将多个setState（）批量调用转化为单个更新以实现性能优化。 Because this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state. 因为this.props和this.state可能会异步更新，所以您不应该依靠它们的值来计算下一个状态。 For example, this code may fail to update the counter: 例如，此代码可能无法更新计数器： 1234// Wrongthis.setState(&#123; counter: this.state.counter + this.props.increment,&#125;); To fix it, use a second form of setState() that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument: 要修复它，请使用第二个形式的接受函数而不是对象的setState（）。 该函数将接收先前的状态作为第一个参数，并且更新应用时的属性作为第二个参数： 1234// Correctthis.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;)); We used an arrow function above, but it also works with regular functions: 我们使用了上面的箭头函数，但它也适用于常规函数： 123456// Correctthis.setState(function(prevState, props) &#123; return &#123; counter: prevState.counter + props.increment &#125;;&#125;); State Updates are Merged（状态更新即合并）When you call setState(), React merges the object you provide into the current state. 当您调用setState()时，React将您提供的对象合并到当前状态。 For example, your state may contain several independent variables: 例如，您的状态可能包含几个独立变量： 1234567constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;;&#125; Then you can update them independently with separate setState() calls: 然后可以使用单独的setState（）调用独立更新它们： 12345678910111213componentDidMount() &#123; fetchPosts().then(response =&gt; &#123; this.setState(&#123; posts: response.posts &#125;); &#125;); fetchComments().then(response =&gt; &#123; this.setState(&#123; comments: response.comments &#125;); &#125;);&#125; The merging is shallow, so this.setState({comments}) leaves this.state.posts intact, but completely replaces this.state.comments. 合并很浅，所以this.setState（{comments}）与this.state.posts各自完整，但完全替代了this.state.comments。 The Data Flows Down（数据流）Neither parent nor child components can know if a certain component is stateful or stateless, and they shouldn’t care whether it is defined as a function or a class. 父组件和子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心它是否被定义为函数或类。 This is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it. 这就是为什么状态通常被称为局部调用或封装。 除了设置它自身之外，它不可访问其它的任何组件。 A component may choose to pass its state down as props to its child components: 组件可以选择将其状态作为属性传递给其子组件： 1&lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; This also works for user-defined components: 这也适用于用户自定义的组件： 1&lt;FormattedDate date=&#123;this.state.date&#125; /&gt; The FormattedDate component would receive the date in its props and wouldn’t know whether it came from the Clock‘s state, from the Clock‘s props, or was typed by hand: FormattedDate组件将在其属性中收到日期，并且不知道它是来自时钟的状态，还是来自时钟的属性，还是手动输入： 123function FormattedDate(props) &#123; return &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;;&#125; Try it on CodePen. This is commonly called a “top-down” or “unidirectional” data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components “below” them in the tree. 这通常被称为“自顶向下”或“单向”数据流。 任何状态始终由某个特定组件所有，并且从该状态导出的任何数据或UI只能影响树中“下方”的组件。 If you imagine a component tree as a waterfall of props, each component’s state is like an additional water source that joins it at an arbitrary point but also flows down. 如果你想象一个组件树作为属性的瀑布，每个组件的状态就像一个额外的水源，它连接在一个任意点，但也流下来。 To show that all components are truly isolated, we can create an App component that renders three &lt;Clock&gt;s: 为了表明所有组件都是真正隔离的，我们可以创建一个应用程序组件，呈现三个&lt;Clock&gt;： 1234567891011121314function App() &#123; return ( &lt;div&gt; &lt;Clock /&gt; &lt;Clock /&gt; &lt;Clock /&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById(&apos;root&apos;)); Try it on CodePen. Each Clock sets up its own timer and updates independently. 每个时钟设置自己的定时器并独自更新。 In React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa. 在React应用程序中，组件是有状态还是无状态被认为是可能随时间而变化的组件的实现细节。 可以在有状态组件中使用无状态组件，反之亦然。]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Components and Props(组件和属性)]]></title>
    <url>%2F2017%2F03%2F31%2Frqd-components-and-props%2F</url>
    <content type="text"><![CDATA[Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. 组件让您将UI拆分成独立的可重复使用的部分，并单独考虑重复每个部分。 Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen. 在概念上，组件就像JavaScript函数。 他们接受任意输入（称为“属性”），并返回描述应该在屏幕上显示的React元素。 Functional and Class Components(功能函数和类组件)The simplest way to define a component is to write a JavaScript function: 定义组件的最简单的方法是编写一个JavaScript函数： 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; This function is a valid React component because it accepts a single “props” object argument with data and returns a React element. We call such components “functional” because they are literally JavaScript functions. 该函数是一个有效的React组件，因为它接受一个单一的“props”对象参数数据并返回一个React元素。 我们将这些组件称为“功能函数”，因为它们是字面上的JavaScript函数。 You can also use an ES6 class to define a component: 你也可以用一个ES6的类定义一个组件： 12345class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; The above two components are equivalent from React’s point of view. 从React的角度来看，上面这两个组件实现的功能都是一样的。 Classes have some additional features that we will discuss in the next sections. Until then, we will use functional components for their conciseness. 课程有一些额外的功能，我们将在下一节讨论。 在此之前，我们将使用功能组件来简化。 Rendering a Component(渲染组件)Previously, we only encountered React elements that represent DOM tags: 以前，我们只遇到代表DOM标签的React元素： 1const element = &lt;div /&gt;; However, elements can also represent user-defined components: 然而，元素也可以表示用户自定义的组件： 1const element = &lt;Welcome name="Sara" /&gt;; When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object “props”. 当React遇到一个表示用户自定义的组件作为元素时，它将JSX属性作为单个对象传递给该组件。 我们称这个对象为”props(属性)”。 For example, this code renders “Hello, Sara” on the page: 例如，该代码在页面上显示“Hello，Sara”： 123456789function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;ReactDOM.render( element, document.getElementById(&apos;root&apos;)); Try it on CodePen. Let’s recap what happens in this example: We call ReactDOM.render() with the &lt;Welcome name=&quot;Sara&quot; /&gt; element. React calls the Welcome component with {name: &#39;Sara&#39;} as the props. Our Welcome component returns a &lt;h1&gt;Hello, Sara&lt;/h1&gt; element as the result. React DOM efficiently updates the DOM to match &lt;h1&gt;Hello, Sara&lt;/h1&gt;. 我们来回顾一下在这个例子中会发生什么： 1.我们使用&lt;Welcome name =“Sara”/&gt;元素作为ReactDOM.render()函数的参数。2.React调用使用{name：&#39;Sara&#39;}作为Welcome组件的属性。3.我们的 Welcome 组件返回一个&lt;h1&gt; Hello，Sara &lt;/ h1&gt;元素作为结果。4.React DOM有效地更新DOM以匹配&lt;h1&gt; Hello，Sara &lt;/ h1&gt;元素的变化。 Caveat: Always start component names with a capital letter. For example, &lt;div /&gt; represents a DOM tag, but &lt;Welcome /&gt; represents a component and requires Welcome to be in scope. 警告： 始终使用大写字母组件开始的名称。 例如，&lt;div /&gt;表示一个DOM标签，但&lt;Welcome /&gt;表示一个组件，并且要求Welcome在要求范围内。 Composing Components(组成部分)Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components. 组件可以在其输出中引用其他组件。 这使我们可以对任何级别的部分使用相同的组件抽象。 按钮，表单，对话框，屏幕：在React应用程序中，所有这些通常都表示为组件。 For example, we can create an App component that renders Welcome many times: 例如，我们可以创建一个可以多次呈现Welcome 的App组件： 123456789101112131415161718function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;function App() &#123; return ( &lt;div&gt; &lt;Welcome name=&quot;Sara&quot; /&gt; &lt;Welcome name=&quot;Cahal&quot; /&gt; &lt;Welcome name=&quot;Edite&quot; /&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById(&apos;root&apos;)); Try it on CodePen. Typically, new React apps have a single App component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like Button and gradually work your way to the top of the view hierarchy. 通常，新的React应用程序的顶部有一个App组件。 但是，如果将React集成到现有应用程序中，则可以使用像Button这样的小组件从自下而上开始，并逐渐替换到视图层次结构的顶部。 Caveat: Components must return a single root element. This is why we added a &lt;div&gt; to contain all the &lt;Welcome /&gt; elements. 警告： 组件必须返回单个根元素。 这就是为什么我们添加了一个&lt;div&gt;标签来包含所有的&lt;Welcome /&gt;元素。 Extracting Components(提取组件)Don’t be afraid to split components into smaller components. 不要担心将组件拆分成更小的组件。 For example, consider this Comment component: 例如，考虑这个 Comment 组件： 123456789101112131415161718192021function Comment(props) &#123; return ( &lt;div className="Comment"&gt; &lt;div className="UserInfo"&gt; &lt;img className="Avatar" src=&#123;props.author.avatarUrl&#125; alt=&#123;props.author.name&#125; /&gt; &lt;div className="UserInfo-name"&gt; &#123;props.author.name&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className="Comment-text"&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className="Comment-date"&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; Try it on CodePen. It accepts author (an object), text (a string), and date (a date) as props, and describes a comment on a social media website. 它接受作者（对象），文本（字符串）和日期（日期）作为属性，并在社交媒体网站上描述评论。 This component can be tricky to change because of all the nesting, and it is also hard to reuse individual parts of it. Let’s extract a few components from it. 由于所有的嵌套，这个组件可能很难改变，并且很难重用它的各个部分。 我们从中提取几个组件。 First, we will extract Avatar: 首先，我们将提取Avatar： 12345678function Avatar(props) &#123; return ( &lt;img className=&quot;Avatar&quot; src=&#123;props.user.avatarUrl&#125; alt=&#123;props.user.name&#125; /&gt; );&#125; The Avatar doesn’t need to know that it is being rendered inside a Comment. This is why we have given its prop a more generic name: user rather than author. Avatar不需要知道它在Comment中被渲染。 这就是为什么我们给它的属性一个更通用的名称： user 而不是 author。 We recommend naming props from the component’s own point of view rather than the context in which it is being used. 我们建议从组件自己的角度来命名道具，而不是使用组件所处的环境。 We can now simplify Comment a tiny bit: 我们现在可以简化 Comment ： 123456789101112131415161718function Comment(props) &#123; return ( &lt;div className=&quot;Comment&quot;&gt; &lt;div className=&quot;UserInfo&quot;&gt; &lt;Avatar user=&#123;props.author&#125; /&gt; &lt;div className=&quot;UserInfo-name&quot;&gt; &#123;props.author.name&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className=&quot;Comment-text&quot;&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className=&quot;Comment-date&quot;&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; Next, we will extract a UserInfo component that renders an Avatar next to user’s name: 接下来，我们将提取一个UserInfo组件，用于将Avatar显示在用户名旁边： 12345678910function UserInfo(props) &#123; return ( &lt;div className=&quot;UserInfo&quot;&gt; &lt;Avatar user=&#123;props.user&#125; /&gt; &lt;div className=&quot;UserInfo-name&quot;&gt; &#123;props.user.name&#125; &lt;/div&gt; &lt;/div&gt; );&#125; This lets us simplify Comment even further: 这让我们进一步简化 Comment ： 12345678910111213function Comment(props) &#123; return ( &lt;div className=&quot;Comment&quot;&gt; &lt;UserInfo user=&#123;props.author&#125; /&gt; &lt;div className=&quot;Comment-text&quot;&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className=&quot;Comment-date&quot;&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; Try it on CodePen. Extracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times (Button, Panel, Avatar), or is complex enough on its own (App, FeedStory, Comment), it is a good candidate to be a reusable component. 首先，提取组件可能看起来像繁琐的工作，但是在较大的应用程序中可以使用可重用组件的调色板。 一个很好的经验法则是，如果您的UI的一部分被使用了几次 (Button, Panel, Avatar)，或者页面足够复杂 (App, FeedStory, Comment)，那么这作为可重用组件的候选方案 。 Props are Read-Only(属性只能被读取)Whether you declare a component as a function or a class, it must never modify its own props. Consider this sum function: 无论您将组件声明为函数还是类，都不能修改自己的属性。 考虑这个”求和”函数： 123function sum(a, b) &#123; return a + b;&#125; Such functions are called “pure” because they do not attempt to change their inputs, and always return the same result for the same inputs. 这些功能被称为“纯函数”，因为它们不会尝试更改其输入的内容，并且总是为相同的输入返回相同的结果。 In contrast, this function is impure because it changes its own input: 相比之下，这个功能不是纯函数，因为它改变了自己的输入： 123function withdraw(account, amount) &#123; account.total -= amount;&#125; React is pretty flexible but it has a single strict rule: React非常灵活，但它有一个严格的规则： All React components must act like pure functions with respect to their props. 所有React组件必须像纯函数的功能一样对属性进行使用。 Of course, application UIs are dynamic and change over time. In the next section, we will introduce a new concept of “state”. State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule. 当然，应用程序UI是动态的，随着时间的推移而改变。 在下一节中，我们将介绍一个state(状态)的新概念。 状态允许React组件根据用户操作，网络响应以及其他任何内容随时间更改其输出，而不会违反此规则。]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Rendering Elements(渲染组件)]]></title>
    <url>%2F2017%2F03%2F30%2Frqd-rendering-elements%2F</url>
    <content type="text"><![CDATA[Elements are the smallest building blocks of React apps. 元素是React应用程序中最小的构建块。 An element describes what you want to see on the screen: 一个元素描述您想要在屏幕上看到的内容： 1const element = &lt;h1&gt;Hello, world&lt;/h1&gt;; Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements. 与浏览器DOM元素不同，React元素是简单的对象，而且便于创建。 React DOM负责更新浏览器DOM，从而匹配React元素。 Note: One might confuse elements with a more widely known concept of “components”. We will introduce components in the next section. Elements are what components are “made of”, and we encourage you to read this section before jumping ahead. 注意： 人们可能会将元素与更广为人知的“组件”概念相混淆。 我们将在下一节介绍组件。 元素是“由…组成”的组件，我们建议您在跳到下一节之前阅读本节。 Rendering an Element into the DOM(将元素渲染到DOM中)Let’s say there is a &lt;div&gt; somewhere in your HTML file: 假设你的HTML文件中有一个标签： 1&lt;div id="root"&gt;&lt;/div&gt; We call this a “root” DOM node because everything inside it will be managed by React DOM. 我们称之为“根”DOM节点，因为其中的所有内容都将由React DOM管理。 Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like. 使用React构建的应用程序通常具有单个根DOM节点。 如果您将React集成到现有应用程序中，则可能需要像您所需的一样多的孤立根DOM节点。 To render a React element into a root DOM node, pass both to ReactDOM.render(): 要将React元素渲染到根DOM节点中，请将它们都传递给ReactDOM.render()函数： 12345const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;ReactDOM.render( element, document.getElementById('root')); Try it on CodePen. It displays “Hello, world” on the page. 它在页面上显示“Hello，world”。 Updating the Rendered Element(更新渲染元素)React elements are immutable. Once you create an element, you can’t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time. React元素是不可变的。 创建元素后，您无法更改其子项或属性。 一个元素就像一个电影中的一帧：它代表了某个时间点的画面。 With our knowledge so far, the only way to update the UI is to create a new element, and pass it to ReactDOM.render(). 根据我们目前所学的知识，更新UI的唯一方法是创建一个新元素，并将其传递给ReactDOM.render()。 Consider this ticking clock example: 考虑这个滴答作响的时钟示例： 1234567891011121314function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById(&apos;root&apos;) );&#125;setInterval(tick, 1000); Try it on CodePen. It calls ReactDOM.render() every second from a setInterval() callback. 它每秒从一个setInterval()回调函数中调用ReactDOM.render()。 Note: In practice, most React apps only call ReactDOM.render() once. In the next sections we will learn how such code gets encapsulated into stateful components. We recommend that you don’t skip topics because they build on each other. 注意： 实际上，大多数React应用只会调用ReactDOM.render()一次。 在接下来的章节中，我们将学习如何将这些代码封装到有状态的组件中。 我们建议您不要跳过主题，因为它们建立在彼此之间。 React Only Updates What’s Necessary(React仅更新必要更新的元素)React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state. React DOM将元素及其子元素与上一个元素进行比较，并将所需更新的DOM更新到所需的状态。 You can verify by inspecting the last example with the browser tools: 您可以使用浏览器工具检查最后一个示例来验证： Even though we create an element describing the whole UI tree on every tick, only the text node whose contents has changed gets updated by React DOM. 即使我们创建了一个描述整个UI树的元素，只有内容已经改变的文本节点才被React DOM更新。 In our experience, thinking about how the UI should look at any given moment rather than how to change it over time eliminates a whole class of bugs. 根据我们的经验，思考一下在特定时刻UI应该是什么样，而不是随着时间的推移去改变它以排除一系列漏洞。]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Introducing JSX(JSX介绍)]]></title>
    <url>%2F2017%2F03%2F29%2Frqd-introducing-jsx%2F</url>
    <content type="text"><![CDATA[Consider this variable declaration: 考虑这个变量声明： 1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; This funny tag syntax is neither a string nor HTML. 这个有趣的标签语法既不是字符串也不是HTML。 It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript. 它被称为JSX，它是JavaScript的语法扩展。 我们建议您使用React来描述UI的外观。 JSX可以说是提示您的一种模板语言，但它和JavaScript的一样强大。 JSX produces React “elements”. We will explore rendering them to the DOM in the next section. Below, you can find the basics of JSX necessary to get you started. JSX创建React元素。 我们将在下一节中讲解如何将它们渲染到DOM。 下面你可以开始学习JSX的基础语法知识。 Embedding Expressions in JSX(在JSX中嵌入表达式)You can embed any JavaScript expression in JSX by wrapping it in curly braces. 您可以在JSX中嵌入任何JavaScript表达式，方法是将其包装在花括号{}中。 For example, 2 + 2, user.firstName, and formatName(user) are all valid expressions: 例如，2 + 2，user.firstName和formatName（user）都是有效的表达式： 12345678910111213141516171819function formatName(user) &#123; return user.firstName + &apos; &apos; + user.lastName;&#125;const user = &#123; firstName: &apos;Harper&apos;, lastName: &apos;Perez&apos;&#125;;const element = ( &lt;h1&gt; Hello, &#123;formatName(user)&#125;! &lt;/h1&gt;);ReactDOM.render( element, document.getElementById(&apos;root&apos;)); Try it on CodePen. We split JSX over multiple lines for readability. While it isn’t required, when doing this, we also recommend wrapping it in parentheses to avoid the pitfalls of automatic semicolon insertion. 我们将JSX分成多行，以增强可读性。 虽然这不是必需的，但在这样做的时候，我们也建议把它放在括号中，以避免分号自动插入的错误。 JSX is an Expression Too(JSX是一个表达式)After compilation, JSX expressions become regular JavaScript objects. 编译后，JSX表达式成为常规的JavaScript对象。 This means that you can use JSX inside of if statements and for loops, assign it to variables, accept it as arguments, and return it from functions: 这意味着您可以在if语句和for循环中使用JSX语法，将其分配给变量，或者接受它作为参数，也可以从函数返回它： 123456function getGreeting(user) &#123; if (user) &#123; return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;; &#125; return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;&#125; Specifying Attributes with JSX(JSX指定属性)You may use quotes to specify string literals as attributes: 您可以使用引号将字符串文字指定为属性： 1const element = &lt;div tabIndex="0"&gt;&lt;/div&gt;; You may also use curly braces to embed a JavaScript expression in an attribute: 您还可以使用花括号将JavaScript表达式嵌入到属性中： 1const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;; Don’t put quotes around curly braces when embedding a JavaScript expression in an attribute. Otherwise JSX will treat the attribute as a string literal rather than an expression. You should either use quotes (for string values) or curly braces (for expressions), but not both in the same attribute. 在属性中嵌入JavaScript表达式时，不要在大括号上放置引号。 否则，JSX将该属性视为字符串文字而不是表达式。 您应该使用引号（对于字符串值）或花括号（用于表达式），但不能同时使用。 Specifying Children with JSX(JSX指定子项)If a tag is empty, you may close it immediately with /&gt;, like XML: 如果是一个空标签，则可以使用/&gt;立即关闭它，如XML： 1const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;; JSX tags may contain children: JSX标签可能包含子项： 123456const element = ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;h2&gt;Good to see you here.&lt;/h2&gt; &lt;/div&gt;); Caveat: Since JSX is closer to JavaScript than HTML, React DOM uses camelCase property naming convention instead of HTML attribute names. For example, class becomes className in JSX, and tabindex becomes tabIndex. 警告： 由于JSX比HTML更接近JavaScript，所以React DOM使用camelCase(驼峰)属性命名约定而不是HTML属性名称。 例如，class在JSX中变为className，tabindex变为tabIndex。 JSX Prevents Injection Attacks(JSX防止注入攻击)It is safe to embed user input in JSX: 在JSX中嵌入用户输入是安全的： 123const title = response.potentiallyMaliciousInput;// This is safe:const element = &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;; By default, React DOM escapes any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent XSS (cross-site-scripting) attacks. 默认情况下，React DOM会在渲染之前转义嵌入在JSX中的任何值。 因此，它确保永远不会注入任何未明确的内容到您的应用程序。 在渲染之前，所有内容都将转换为字符串。 这有助于防止XSS跨站点脚本攻击。 JSX Represents Objects(JSX表示对象)Babel compiles JSX down to React.createElement() calls. Babel将JSX对象编译为传入React.createElement()函数的参数，并进行函数。 These two examples are identical: 这两个例子是一样的： 12345const element = ( &lt;h1 className="greeting"&gt; Hello, world! &lt;/h1&gt;); 12345const element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, world!'); React.createElement() performs a few checks to help you write bug-free code but essentially it creates an object like this: React.createElement()执行一些检查以帮助您编写无错误代码，但基本上它会创建一个如下所示的对象： 12345678// Note: this structure is simplifiedconst element = &#123; type: 'h1', props: &#123; className: 'greeting', children: 'Hello, world' &#125;&#125;; These objects are called “React elements”. You can think of them as descriptions of what you want to see on the screen. React reads these objects and uses them to construct the DOM and keep it up to date. 这些对象被称为&quot;React元素&quot;。 您可以将它们视为您想要在屏幕上看到的内容。 React读取这些对象，并使用它们构造DOM并更新到屏幕上。 We will explore rendering React elements to the DOM in the next section. 我们将在下一节中研究如何将React元素渲染到DOM中。 Tip: We recommend searching for a “Babel” syntax scheme for your editor of choice so that both ES6 and JSX code is properly highlighted. 提示： 我们建议您为选择的编辑器搜索“Babel”语法方案，以便ES6和JSX代码都被正确突出显示。]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World(你好世界)]]></title>
    <url>%2F2017%2F03%2F28%2Frqd-hello-world%2F</url>
    <content type="text"><![CDATA[The easiest way to get started with React is to use this Hello World example code on CodePen. You don’t need to install anything; you can just open it in another tab and follow along as we go through examples. If you’d rather use a local development environment, check out the Installation page. 使用React开始的最简单的方法是在CodePen上使用这个Hello World示例代码。 你不需要安装任何东西; 您可以在另一个选项卡中打开它，并按照我们通过实例进行跟踪。 如果您希望使用本地开发环境，请查看安装页面。 The smallest React example looks like this: 最简洁的React示例如下所示： 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root')); It renders a header saying “Hello, world!” on the page. 它在页面上渲染了一个标题 “Hello World!” The next few sections will gradually introduce you to using React. We will examine the building blocks of React apps: elements and components. Once you master them, you can create complex apps from small reusable pieces. 接下来的几节将逐步地为您介绍使用React。 我们将解释React应用程序的构建块：【元素和组件】。 掌握它们后，您可以利用精简的元素和可复用的组件去创建复杂的应用程序。 A Note on JavaScript（JS注意事项）React is a JavaScript library, and so it assumes you have a basic understanding of the JavaScript language. If you don’t feel very confident, we recommend refreshing your JavaScript knowledge so you can follow along more easily. React是一个JavaScript库，因此我们假设你对JavaScript语言有基本的了解。 如果您不太自信，我们建议您重新学习JavaScript知识，以便更轻松地学习React。 We also use some of the ES6 syntax in the examples. We try to use it sparingly because it’s still relatively new, but we encourage you to get familiar with arrow functions, classes, template literals, let, and const statements. You can use Babel REPL to check what ES6 code compiles to. 我们还在示例中使用了一些ES6语法。 因为它还比较新，所以我们会谨慎地尝试使用它，但是我们鼓励你熟悉箭头函数，类，模板文字，let和const语句。 您可以使用Babel REPL来检查ES6代码编译的内容。]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Installation（安装）]]></title>
    <url>%2F2017%2F03%2F27%2Frqd-installation%2F</url>
    <content type="text"><![CDATA[React is flexible and can be used in a variety of projects. You can create new apps with it, but you can also gradually introduce it into an existing codebase without doing a rewrite. React能够灵活的适用于各种项目。 您可以使用它创建新的应用程序，同时您也可以逐渐将其引入到现有的代码库中，而无需重写。 Trying Out React（尝试使用React）If you’re just interested in playing around with React, you can use CodePen. Try starting from this Hello World example code. You don’t need to install anything; you can just modify the code and see if it works. If you prefer to use your own text editor, you can also download this HTML file, edit it, and open it from the local filesystem in your browser. It does a slow runtime code transformation, so don’t use it in production. 如果您对React感兴趣，想尝试一下，您可以使用CodePen。 尝试从这个Hello World示例代码开始。 你不需要安装任何东西; 你只需要修改一下代码，看看它是否正常运行。 如果您喜欢使用自己已有的文本编辑器，您还可以下载此HTML文件，进行编辑，并从浏览器中的本地文件系统中打开它。 它在运行时执行代码转换比较缓慢，所以不要在生产环境中使用它。 Creating a Single Page Application(创建单页面应用程序)Create React App is the best way to start building a new React single page application. It sets up your development environment so that you can use the latest JavaScript features, provides a nice developer experience, and optimizes your app for production. 创建React应用程序是开始构建一个新的React单页面应用程序的最佳方式。 它设置您的开发环境，以便您可以使用最新的JavaScript功能，提供不错的开发人员体验，并优化您的应用程序。 1234npm install -g create-react-appcreate-react-app hello-worldcd hello-worldnpm start Create React App doesn’t handle backend logic or databases; it just creates a frontend build pipeline, so you can use it with any backend you want. It uses webpack, Babel and ESLint under the hood, but configures them for you. Create React App不处理后端逻辑或数据库; 它只是创建一个前端构建管道，所以你可以使用任何你想使用的后台。 你可以在React中使用webpack，Babel和ESLint进行配置。 Adding React to an Existing Application(将React添加到已有的应用程序中)You don’t need to rewrite your app to start using React. 您不需要重写您的应用程序,就可以开始使用React。 We recommend adding React to a small part of your application, such as an individual widget, so you can see if it works well for your use case. 我们建议您将React添加到应用程序的一小部分，例如单个窗口小部件，以便您可以看到它在您的用例中，是否能更好地运行。 While React can be used without a build pipeline, we recommend setting it up so you can be more productive. A modern build pipeline typically consists of: 虽然React可以在没有构建管道的情况下使用，但我们建议你对其进行设置，以便你的开发工作更为高效。 流行的构建管道通常包括： A package manager, such as Yarn or npm. It lets you take advantage of a vast ecosystem of third-party packages, and easily install or update them. 一个包管理器，如Yarn 或 npm。 它可以让您利用庞大的第三方软件包的生态系统，从而更轻松安装和更新它们。 A bundler, such as webpack or Browserify. It lets you write modular code and bundle it together into small packages to optimize load time. 一个打包器，如webpack或Browserify。 它允许您编写模块化代码并将其打包在一起，成为压缩包，以优化加载时间。 A compiler such as Babel. It lets you write modern JavaScript code that still works in older browsers. 一个编译器，如Babel。 它可以让您编写最新的JavaScript代码，但仍旧能运行在旧版浏览器上。 Installing React(安装React)We recommend using Yarn or npm for managing front-end dependencies. If you’re new to package managers, the Yarn documentation is a good place to get started. 我们建议使用Yarn 或 npm来管理前端依赖关系。 如果您是新来的软件包管理员，则该Yarn文档是开始使用Yarn的好地方。 To install React with Yarn, run:（使用Yarn安装React，请运行） 12yarn inityarn add react react-dom To install React with npm, run:（使用npm安装React，请运行） 12npm initnpm install --save react react-dom Both Yarn and npm download packages from the npm registry. 从npm注册表中下载Yarn和npm的软件包。 Enabling ES6 and JSX(启用ES6和JSX)We recommend using React with Babel to let you use ES6 and JSX in your JavaScript code. ES6 is a set of modern JavaScript features that make development easier, and JSX is an extension to the JavaScript language that works nicely with React. 我们建议您使用Babel来将React代码进行转换，以便于您可以在JavaScript代码中使用ES6语法和JSX语法。 ES6是JavaScript的一组最新的特性，可以使开发变得更简单，JSX是对JavaScript语言的一种扩展，它能使React的很好地运行。 The Babel setup instructions explain how to configure Babel in many different build environments. Make sure you install babel-preset-react and babel-preset-es2015 and enable them in your .babelrc configuration, and you’re good to go. Babel设置说明：声明了如何在许多不同的构建环境中配置Babel。 确保您安装了babel-preset-react 和babel-preset-es2015，并在.babelrc配置中启用它们。 Hello World with ES6 and JSX(使用ES6和JSX构建Hello World程序)We recommend using a bundler like webpack or Browserify so you can write modular code and bundle it together into small packages to optimize load time. 我们建议你使用像webpack或Browserify这样的打包器。 这样您可以编写模块化代码并将其打包在一起，成为压缩包，以优化加载时间。 The smallest React example looks like this: 最见得的React示例如下所示： 1234567import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root')); This code renders into a DOM element with the id of root so you need &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; somewhere in your HTML file. 这块代码将其它元素渲染进一个ID为root的DOM元素，因此您需要在HTML文件中的某个位置使用 &lt;/ div&gt;。 Similarly, you can render a React component inside a DOM element somewhere inside your existing app written with any other JavaScript UI library. 类似地，您可以在现有应用程序中的任何其他地方，将DOM元素中渲染为（使用任何其他的JavaScript UI库编写的任何）React组件。 Development and Production Versions(开发和生产版本)By default, React includes many helpful warnings. These warnings are very useful in development. However, they make React larger and slower so you should make sure to use the production version when you deploy the app. 默认情况下，React包含许多有用的警告。 这些警告在开发中非常有用。 但是，它们使React应用包更大，运行更加缓慢，所以您应该确保在部署应用程序时，使用生产版本。 BrunchTo create an optimized production build with Brunch, just add the -p flag to the build command. See the Brunch docs for more details. 要使用Brunch创建优化的生产构建，只需将-p标志添加到build命令中即可。 有关详细信息，请参阅Brunch文档。 BrowserifyRun Browserify with NODE_ENV environment variable set to production and use UglifyJS as the last build step so that development-only code gets stripped out. 运行Browserify时，将NODE_ENV环境变量设置为production，并使用UglifyJS作为最后一个构建步骤，以便将开发代码进行分离。 Create React AppIf you use Create React App, npm run build will create an optimized build of your app in the build folder. 如果您使用Create React App命令行工具，npm run build将在build文件夹中创建一个已经优化过的应用程序。 RollupUse rollup-plugin-replace plugin together with rollup-plugin-commonjs (in that order) to remove development-only code. See this gist for a complete setup example. 使用rollup-plugin-replace插件和rollup-plugin-commonjs（按顺序）来分离开发代码。 参考这个一个完整的设置示例。 WebpackInclude both DefinePlugin and UglifyJsPlugin into your production Webpack configuration as described in this guide. 将DefinePlugin和UglifyJsPlugin包含在本指南中描述的生产Webpack配置中，在这个指导中进行详细的描述。 Using a CDN(使用CDN)If you don’t want to use npm to manage client packages, the react and react-dom npm packages also provide single-file distributions in dist folders, which are hosted on a CDN: 如果您不想使用npm来管理客户端软件依赖包，那么React和React-dom npm软件包也会在dist文件夹中提供单文件分发,它们托管在CDN上： 12&lt;script src="https://unpkg.com/react@15/dist/react.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/react-dom@15/dist/react-dom.js"&gt;&lt;/script&gt; The versions above are only meant for development, and are not suitable for production. Minified and optimized production versions of React are available at: 以上版本仅用于开发，不适合生产。 React优化生产版本可在以下网址获得： 12&lt;script src="https://unpkg.com/react@15/dist/react.min.js"&gt;&lt;/script&gt;&lt;script src="https://unpkg.com/react-dom@15/dist/react-dom.min.js"&gt;&lt;/script&gt; To load a specific version of react and react-dom, replace 15 with the version number. 要加载react 和 react-dom的特定版本，请使用其它的版本号替换15。 If you use Bower, React is available via the react package. 如果您使用Bower，React可通过 react 包获得。]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu Development Tools]]></title>
    <url>%2F2017%2F01%2F11%2Flinux-dev-tool%2F</url>
    <content type="text"><![CDATA[一、翻墙修改Hosts文件 —&gt; 翻墙 12sudo gedit /etc/hostssudo /etc/init.d/networking restart 自由上网方法 谷歌浏览器Chrome+ShadowSocks+Proxy SwitchyOmega自动翻墻教程 1https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt 解决Github访问超慢问题 二、小工具安装Ubuntu 16.04后要做的事自定义 Ubuntu 16.04 Unity 所处位置123gsettings set com.canonical.Unity.Launcher launcher-position Bottomgsettings set com.canonical.Unity.Launcher launcher-position Leftsudo apt-get install dconf-editor Ubuntu 16.04 无法安装软件解决办法1234567试图双击deb文件进行安装，点击install按钮提示“This software comes from a 3rd party and may contain non-free components”sudo apt install gdebi安装完成后，将deb文件默认打开方式设为gdebi：右键点击deb文件，打开properties，选择open with，选中GDebi Package Installer. 并Set as default 三、应用工具1-安装Sogou输入法 解决搜狗输入法切换无效的方法 rm -Rf ~/.config/SogouPYrm -Rf ~/.config/SogouPY.usersrm -Rf ~/.config/sogou-qimpanel 2-安装shadowsocks 3-安装Chrome浏览器 4-安装Evernote 5-安装NetEase Cloud Music 6-安装Nutstore 7-安装WPS Office 8-安装FCC 9-安装Typora) 四、开发工具SdkMan Groovy Gradle C语言 C++ 0-安装KDK 1-安装Android Studio 2-安装IntelliJ IDEA 3-安装Xmind 4-安装JD-JUI 5-安装Dex2Jar 6-安装Vim 7-安装Git 123$ git config --global user.name &quot;william&quot;$ git config --global user.email &quot;william.lee@gtedx.com&quot;$ ssh-keygen -t rsa -C “william.lee@gtedx.com” 五、配置环境所有的环境变量都配置到~/.bashrc文件中 sudo gedit ~/.bashrc source ~/.bashrc # set oracle jdk environment export JAVA_HOME=/home/william/Develop/Kit/jdk ## 这里要注意目录要换成自己解压的jdk 目录 export JRE_HOME=${JAVA_HOME}/jre export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib:$CLASSPATH export PATH=${JAVA_HOME}/bin:$PATH # set android sdk enviroment export ANDROID_HOME=/home/william/Develop/Kit/sdk export PATH=${ANDROID_HOME}/tools:${ANDROID_HOME}/platform-tools:$PATH #set git environment #set gradle environment #set groovy environment]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[我的睡眠与睡眠]]></title>
    <url>%2F2016%2F09%2F05%2Fsleep-and-work%2F</url>
    <content type="text"><![CDATA[这篇日志就当流水吧，因为对于我的睡眠，我感到很无奈。毕竟是由多个方面造成的，比如出生环境、成长环境、母亲的影响、自身的悟性、以及性格的形成、生活习惯的造就等等。 昨天，就是昨天（2016年09月04日），我的领导说他的师父（故知堂-景瑞林）是民间高手，我就慕名前来求医。 大师说，我血中带风，需要除痹、清肝。此人号脉干脆利落，切中要害。 之后，我便让其帮我开了一个疗程的药浴。前三天，每天泡一次，之后便是每隔一天泡一次药浴。 中间忌口，忌腥、忌辣、忌凉、忌膻、 忌烟、忌酒，反正就是各种忌，就差忌女人了。 晚上睡觉的时候，还必须穿棉质的袜子，必须过脚踝。 泡完药浴之后，顺便洗澡。冲干之后，头发必须吹干。然后在室内等全身的汗消去即可，中间最好避风。 时间是：饭后4个小时之内，将药浴完成。不能空腹。话说是因为药效太强。 话说：武医不分家，我觉得我有必要配合练习八段锦以增其效。 目前，我不得不处于移动办公的状态，一边泡药浴一边办公。]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux常用指令索引]]></title>
    <url>%2F2016%2F08%2F18%2Flinux-command%2F</url>
    <content type="text"><![CDATA[Linux 平台上的软件包管理 Linux Command Index 针对鸟哥的私房菜《Linux基础学习篇》 权限相关 chgrp - 144 - 改变文件所属用户组 chown - 145 - 改变文件所有者 chmod - 146 - 改变文件权限 目录相关的操作 cd - 163 - 切换目录 pwd - 164 - 显示目前所在的目录 mkdir - 164 - 新建新目录 rmdir - 165 - 删除“空“的目录 文件与目录管理 ls - 167 - 查看文件与目录 cp - 169 - 复制文件或目录 rm - 171 - 移除文件或目录 mv - 172 - 移动文件与目录、或更名 basename - 173 文件内容查阅 cat - 173 - 直接查看文件内容 tac - 174 - 反向显示 nl - 174 - 添加行号打印 more - 175 - 一页一页翻动 less - 176 - 一页一页翻动 head - 176 - 取出前面几行 tail - 177 - 取出后面几行 od - 178 - 非纯文本文件 touch - 179 - 修改文件时间或创建新文件 ​]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[爸妈，爹娘，爸爸妈妈，父亲母亲]]></title>
    <url>%2F2016%2F08%2F17%2Ffather-and-mother%2F</url>
    <content type="text"><![CDATA[今天在公园跑步，突然想起我的妈妈了。上周没有给我妈打电话，我发现我自己定原则都在慢慢的改变。 自从我15年3月初来北京之后，我便作了一个决定：每年必须回家四次，每周必须往家里打一个电话。 过年回家一趟，顺便给老爸过完生日 五一回家一趟，就是回家让爸妈看看 我妈生日一趟，孩儿的生日娘的苦日 十一回家一趟，也是回家让爸妈看看 目前，我发现我当初的那个决定有了微妙的变化。本来每周打一次电话回家，现在却是两个周通话一次了。可能是因为母亲的逼婚吧，现在跟母亲的能聊得话，越来越少了。 有一首叫《父子》，写到我的内心当中去了。母亲啊，父亲啊，我该何去何从了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051如果你是一棵参天大树我就是一粒种子你宽大的树荫把我守护我每天眺望你的高度等到有一天你慢慢长大也许我的枝干早已干枯无论你的繁华蔓延何处不要忘记脚下那片泥土我知道你的辛苦 明白你的付出却忘了如何跟你相处我们都不善表露可心里全都清楚这就是血脉相传的定数我心里有满满的爱可是说不出只能望着你远去的脚步给你我的祝福我心里有满满的爱 可是说不出你是世间唯一的男人让我牵肠挂肚我知道你一直默默关注无论我光荣或屈辱无论成功失败都别太在乎要懂得忍让学会知足我心里有满满的爱 可是说不出只能望着你远去的脚步给你我的祝福我心里有满满的爱可是说不出你是世间唯一的男人让我牵肠挂肚我害怕有一天自己苍老成为你的包袱我会在你身旁把你搀扶就像当初你带着我走出人生第一步]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习本质,顺藤摸瓜]]></title>
    <url>%2F2016%2F08%2F16%2Fgot-it-through-the-grapevine%2F</url>
    <content type="text"><![CDATA[学习的本质是顺藤摸瓜，把所有能关联的知识组合一起，打造一个生态环境。 最近内心的情怀难以抒发，于是又想写点散文指点江山。 但前提是，我得注册域名，购买空间，学习建设网站，选择写作工具，进行版本控制。 将这一系列的工作完成后，我也是一块小砖家了，呵呵。 注册域名 域名相关的知识 购买空间 使用GitHub静态空间 建设网站 HTML5 CSS JavaScript Jekyll http://jekyll.bootcss.com/ 写作工具 Typora http://www.typora.io/ Markdown 文本标记语言 版本控制 Git版本控制 https://git-scm.com/ https://git-scm.com/downloads/ https://git-scm.com/documentation https://git-scm.com/book/zh/v2 http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 此文章将 持续更新]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[无论如何,我要坚持下去]]></title>
    <url>%2F2016%2F08%2F15%2FI-am-going-to-persis%2F</url>
    <content type="text"><![CDATA[既然选择了远方，便只顾风雨兼程。 这句话，在我们的中学时代，是多么励志的一句话。今天再次想起这句话的时候，内心还是有一丝丝的触动。当时的你，是不是想过要为了自己心爱的姑娘，决定好好学习，考上大学，作为一番。可是，始终架不住年少时骚动的内心，从而上课频频走神(或许也在走肾,O(∩_∩)O~。 今天，我想对自己说说睡眠的事情，我得自己跟自己多多对话。 之前，我的私人医生不建议我通过跑步锻炼身体，于是我按照他的建议，开始每天练八段锦。但是，我觉得始终不能消耗我太多的体力，我是想通过身体的劳累让自己尽快进入睡眠的状态。但是，跑步一直是我向往一项运动，我喜欢在路上的感觉，能给我带来一丝的欣喜。喜欢超越那个女孩的背影，喜欢被人超越，看着人家远去的背影，也喜欢望向蓝天，大步向前迈的感觉。总之，跑步能让我在少思考，少焦虑。 那我决定：早晨练八段锦，傍晚跑步。平时吃饭，细嚼慢咽。坚持，坚持，还是坚持。 此景于 北京奥林匹克公园北园 拍摄]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[无论好坏,这就是我的开始]]></title>
    <url>%2F2016%2F08%2F14%2Fwhether-good-or-bad-this-is-my-beginning%2F</url>
    <content type="text"><![CDATA[记得那年姚明去了火箭，开始了他的NBA职业生涯，在他的首秀过后，面对记者的采访，他说了一句：无论好坏，这就是我的开始！ 多么真诚的话语，多么豁达的心态，坦然的面对自己，面对已经成为事实的首秀，虽然不堪，但这就是他的开始。我觉得他的内心是强大而不可战胜的，面对这一群狼，却要装作一只羊，而且要跟狼一样的强大。 此处，我应该省略千言万语，以行动来面对自己的内心，面对自己的外在。 由此，我也应该多出去游览一下祖国的大好河山，享用一下绝味的美食。 那就，两周一游山，两周一美食吧！ 此景于 北京蟒山国家森林公园 拍摄]]></content>
      <categories>
        <category>diary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[软件相关的知识]]></title>
    <url>%2F1986%2F08%2F07%2Fsoftware_knowledge%2F</url>
    <content type="text"><![CDATA[语义化版本 2.0.0 ​]]></content>
      <categories>
        <category>mys</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[区块链相关的知识]]></title>
    <url>%2F1986%2F08%2F07%2Fblock_chain_more%2F</url>
    <content type="text"><![CDATA[###阮一峰 区块链入门教程 比特币入门教程 加密货币的本质]]></content>
      <categories>
        <category>mys</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[算法]]></title>
    <url>%2F1986%2F08%2F06%2Fmy_algorithms%2F</url>
    <content type="text"><![CDATA[​]]></content>
      <categories>
        <category>mys</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F1986%2F08%2F06%2Fmy_data_structure%2F</url>
    <content type="text"><![CDATA[HashMap 图解HashMap(一) 图解HashMap(二) 常见数据结构与算法整理总结(上) 常见数据结构与算法整理总结(下)]]></content>
      <categories>
        <category>mys</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[技术栈]]></title>
    <url>%2F1986%2F08%2F05%2Fmy_technology_stack%2F</url>
    <content type="text"><![CDATA[Groovy Groovy脚本基础全攻略 Gradle Gradle User Guide 英文 Gradle User Guide 中文 Gradle脚本基础全攻略 Gradle从入门到实战(付费) Java JavaScript ECMAScript 6 入门 NodeJs 英文 NodeJs 中文 NodeJs 中文 2 HTML CSS JWT JSON Web Token - 在Web应用间安全地传递信息 八幅漫画理解使用JSON Web Token设计单点登录系统 HTTP HTTP 协议入门 HTTPS 升级指南 REST RESTful API 设计指南 OAuth 理解OAuth 2.0 WebSocket WebSocket 教程 Browser 当你打开网页的时候，世界都发生了什么 AOP AspectJ Java Method Logging with AOP and Annotations AOP 之 AspectJ 全面剖析 in Android 从AspectJ看Android AOP Hugo Dexposed]]></content>
      <categories>
        <category>mys</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[工具栈]]></title>
    <url>%2F1986%2F08%2F05%2Fmy_tool_stack%2F</url>
    <content type="text"><![CDATA[Markdown Markdown 编辑器 Typora Markdown 在线编辑器 PandaoEditor Markdown 在线编辑器 StackEdit Markdown 语法手册(完整整理版) Markdown 语法说明 (简体中文版) PlantUML 官方中文文档 在线生成UML图 AndroidStudio 中使用 PlantUML 时序图 用例图 类图 活动图 组件图 状态图 对象图 Mermaid Pandoc ​ Graphviz sudo apt-get install graphviz Vim Vim 中文) Git Git中文 Git小册 Git廖雪峰 Git小技巧 使用git log命令自动生成周报 Jenkins 使用Jenkins进行持续集成 Docker Docker 中文 Docker 中文社区 CURL curl网站开发指南 SDKMAN]]></content>
      <categories>
        <category>mys</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React Index]]></title>
    <url>%2F1986%2F08%2F04%2Freact-base%2F</url>
    <content type="text"><![CDATA[React 技术栈Web基础 Web文档 Web实践 FreeCodeCamp 英文网 FreeCodeCamp 中文网 培训 JavaScript 全栈工程师培训教程 React 技术栈系列教程 官网 React 官网 React 中文 ※ 示例 ReactCoolStarter 基于 react, redux 最佳实践构建的 2048 App 网络应用清单 工具 包管理器 npm en | npm cn npm cn2 npm 模块安装机制简介 ※ yarn en | yarn en 构建器 webpack en | webpack cn ※ 打包实战 | 轻松入门React和Webpack browserify en | browserify cn 编译器 babel en | babel cn ※ Babel 入门教程 React 开发者工具 静态类型检查器 Flow en Flow cn # Flow 的使用入门 Flow - JS静态类型检查工具 为什么在JavaScript中使用静态类型？ (Flow中的静态类型) 强类型 JavaScript 的解决方案 Prettier # 编码风格 ESLint en | ESLint cn | ESLint 实战 # 检查警告 Storybook # 组件预览 SW Precache Webpack Plugin 离线指南 ServiceWorker 技术 react router en | react router cn ※ React Router 4 简易入门 初探 React Router 4.0 React Router v4 版本 完全指北 React Router 使用教程 不依赖服务端实现 react-router 的 browserHistory react bootstrap en | react bootstrap cn ※ redux en | redux cn ※ Redux 入门教程（一）：基本用法 Redux 入门教程（二）：中间件与异步操作 Redux 入门教程（三）：React-Redux 的用法 react-router-redux中文文档 Redux DevTools Middleware(中间件) Redux Logger redux-thunk redux-promise Sass en | Sass cn | Sassmeister SASS用法指南 ※ Immutable.js en | Immutable.js cn ※ Moment.js en | Moment.js cn ※ Underscore.js en | Underscore.js cn | Lodash en | Lodash cn ※ Ramda.js 函数式编程入门教程 Ramda 函数库参考教程 Pointfree 编程风格指南 Thunk 函数的含义和用法 Reduce 和 Transduce 的含义 Jest en | Jest cn | Jsdom | Enzyme | Chai | Sinon.js | EnzymeMatchers React 测试入门教程 React 应用下的单元测试 Travis CI 持续集成服务 Travis CI 教程 6 simple steps to automatically test and deploy your JavaScript app to GitHub Pages ​ 相关 CDN CDN基础 CDN详解 也许是史上最全的一次CDN详解 XSS(跨站脚本攻击) Npm Scripts 使用指南 搞清楚React项目中支持的Polyfills. Prettier 统一团队的代码风格 React 如何国际化 ? FAQ 什么是声明式编程? 以声明式编写UI，可以让你的代码更加可靠，且方便调试 JavaScript Bind 问题 https://www.ibm.com/developerworks/cn/web/1207_wangqf_jsthis/index.html https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/ 如果您需要根据内容动态更新页面标题，可以使用浏览器的document.title API。对于要从React组件更改标题的更复杂的场景，可以使用React Helmet(一个第三方库)。 熟悉使用Visual Studio Code Visual Studio Code 集成 Chrome 插件. Flow是一种静态类型的检查器，可以帮助您编写更少错误的代码。如果您是这个概念的新手，请参阅JavaScript中使用静态类型的介绍 。 .env 文件的特定设置 分别代表含义 ? 在开发中使用HTTPS ​ 如何确保 ? 请记住，代理仅在开发中有效 (使用 npm start)，并且由您来确保像 /api/todos 这样的URL指向生产中的正确的东西。您不必使用 /api 前缀。任何无法识别的没有 text/html 接收标头的请求，将被重定向到指定的 proxy. 什么是服务器渲染? React如何支持服务器渲染? 什么是预渲染成静态HTML文件? HTML5 history API (pushState, replaceState, popState) &lt;Switch&gt; 对于转场动画也非常适用 ​ 12Access-Control-Allow-OriginFetch API cannot load http://localhost:4000/api/todos. No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://localhost:3000&apos; is therefore not allowed access. If an opaque response serves your needs, set the request&apos;s mode to &apos;no-cors&apos; to fetch the resource with CORS disabled.]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React Native Index]]></title>
    <url>%2F1986%2F08%2F04%2Freact-native%2F</url>
    <content type="text"><![CDATA[React Native 3rd Lib react-native-photo-view Pinch-to-zoom view for React Native (both iOS and Android) react-native-image-crop-picker iOS/Android image picker with support for camera, configurable compression, multiple images and cropping. react-native-snap-carousel Swiper component for React Native featuring previews, snapping effect, parallax images, performant handling of huge numbers of items, and RTL support. Compatible with Android &amp; iOS. React-Native-ViewPager ViewPager and Indicator component for react-native on both android and ios. react-native-popup-dialog A React Native Popup Dialog Easy Use &amp; Support Custom Animation. For IOS &amp; Android.. react-native-smart-pull-to-refresh-listview A smart pull-down-refresh and pull-up-loadmore react-native listview, for ios, written in pure JS, for android, written in JS and Java. react-native-gifted-listview A ListView with pull-to-refresh, infinite scrolling and more for Android and iOS React-Native apps. react-native-camera The comprehensive camera module for React Native. Including photographs, videos, and barcode scanning! react-native-smart-barcode A smart barcode scanner component for React Native app. The library uses https://github.com/zxing/zxing to decode the barcodes for android, and also supports ios. react-native-camera A Camera component for React Native. Also supports barcode scanning!]]></content>
      <categories>
        <category>react native</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[React Architecture]]></title>
    <url>%2F1986%2F08%2F04%2Freact-arch%2F</url>
    <content type="text"><![CDATA[说明:本博文的目的只有一个:记录React项目架构搭建过程. 创建React应用12345npm install -g create-react-appcreate-react-app my-appcd my-appnpm start 添加库添加CSS预处理器(Sass)123456789npm install node-sass-chokidar --save-devnpm install --save-dev npm-run-all&quot;build-css&quot;: &quot;node-sass-chokidar src/ -o src/&quot;,&quot;watch-css&quot;: &quot;npm run build-css &amp;&amp; node-sass-chokidar src/ -o src/ --watch --recursive&quot;,&quot;start-js&quot;: &quot;react-scripts start&quot;,&quot;start&quot;: &quot;npm-run-all -p watch-css start-js&quot;,&quot;build&quot;: &quot;npm run build-css &amp;&amp; react-scripts build&quot;, ####添加Bootstrap库 12npm install react-bootstrap --savenpm install bootstrap@3 --save 在 src/index.js 文件的开头导入Bootstrap CSS和可选的Bootstrap主题CSS： 123import &apos;bootstrap/dist/css/bootstrap.css&apos;;import &apos;bootstrap/dist/css/bootstrap-theme.css&apos;;// 在下面放置任何其他导入，以使您的组件中的CSS优先于默认样式。 Import required React Bootstrap components within src/App.js file or your custom component files: 在 src/App.js 文件或您的自定义组件文件中导入所需的React Bootstrap组件： 1import &#123; Navbar, Jumbotron, Button &#125; from &apos;react-bootstrap&apos;; 添加Flow(静态类型检查器)123451. 运行 npm install --save-dev flow-bin (或 yarn add --dev flow-bin)2. 将 &quot;flow&quot;: &quot;flow&quot; 添加到您的package.json的 scripts 部分3. 运行 npm run flow -- init (或 yarn flow -- init)以在根目录中创建一个.flowconfig文件4. 将 // @flow 添加到要进行类型检查的任何文件中（例如，到src/App.js）5. 现在，您可以运行 npm run flow (或 yarn flow) 来检查文件的类型错误 添加React Router 安装 React Router 12npm install --save react-router-domnpm install --save react-router-redux 添加 Root Router 123&lt;BrowserRouter&gt; &lt;App /&gt;&lt;/BrowserRouter&gt; 添加 Route 1234567&lt;Switch&gt; &lt;Route path=&quot;/&quot; exact component=&#123;HomeMgmt&#125;/&gt; &lt;Route path=&quot;/courses&quot; component=&#123;CoursesMgmt&#125;/&gt; &lt;Route path=&quot;/students&quot; component=&#123;StudentsMgmt&#125;/&gt; &lt;Route path=&quot;/teachers&quot; component=&#123;TeachersMgmt&#125;/&gt; &lt;Route path=&quot;/parents&quot; component=&#123;ParentsMgmt&#125;/&gt;&lt;/Switch&gt; 添加 Link 1234&lt;Link to=&quot;/courses&quot;&gt;课程管理&lt;/Link&gt;&lt;Link to=&quot;/students&quot;&gt;学生管理&lt;/Link&gt;&lt;Link to=&quot;/teachers&quot;&gt;老师管理&lt;/Link&gt;&lt;Link to=&quot;/parents&quot;&gt;家长管理&lt;/Link&gt; 添加 Redux 以及相关的中间件1234npm install --save reduxnpm install --save react-reduxnpm install --save redux-thunknpm install --save redux-logger ###测试React应用 React 应用内默认集成了 Jest 和 Jsdom 12npm testnpm test -- --coverage // 测试并生成覆盖率报告 构建React应用1npm run build 持续集成(CI) &amp;&amp; 部署(Deploy)]]></content>
      <categories>
        <category>react</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android基础总结]]></title>
    <url>%2F1986%2F08%2F03%2Fandroid-base%2F</url>
    <content type="text"><![CDATA[Android官方培训课程中文版-胡凯 Android官方培训课程中文版-官方 Google Samples 四大组件 Activity 生命周期 启动模式 Service Broadcast Receiver Content Provider View Custom View HenCoder Android 开发进阶：自定义 View 1-1 绘制基础 HenCoder Android 开发进阶：自定义 View 1-2 Paint 详解 HenCoder Android 开发进阶：自定义 View 1-3 drawText() 文字的绘制 HenCoder Android 开发进阶：自定义 View 1-4 Canvas 对绘制的辅助 clipXXX() 和 Matrix HenCoder Android 开发进阶：自定义 View 1-5 绘制顺序 HenCoder Android 开发进阶：自定义 View 1-6：属性动画 Property Animation（上手篇） HenCoder Android 开发进阶：自定义 View 1-7：属性动画 Property Animation（进阶篇） HenCoder Android 开发进阶：自定义 View 1-8 硬件加速 Widget ListView RecycleView WebView Carson_Ho 你需要了解的HTTP知识都在这里了！ Carson_Ho Android开发：最全面、最易懂的Webview使用详解 Carson_Ho 最全面总结 Android WebView与 JS 的交互方式 Carson_Ho 你不知道的 Android WebView 使用漏洞 Carson_Ho Android：手把手教你构建 WebView 的缓存机制 &amp; 资源预加载方案 ​ 如何设计一个优雅健壮的Android WebView？（上） 坑 关于返回键和历史栈的坑 Screen Component Notification Android通知栏介绍与适配总结 Dialog Toast Android 3rd UI/UX Libraries ListView &amp; RecycleView TwoWayView Sectioned RecyclerView SectionedRecyclerViewAdapter 安全 日志收集 如何安全地打印日志 Timber Logger 异常上报 Bugly 性能 Android性能优化典范 - 第1季 Android性能优化典范 - 第2季 Android性能优化典范 - 第3季 Android性能优化典范 - 第4季 Android性能优化典范 - 第5季 Android性能优化典范 - 第6季 Android性能优化典范之渲染篇 Android性能优化典范之运算篇 Android性能优化典范之内存篇 Android性能优化典范之电量篇 Android内存优化典范之内存篇 Android性能优化典范之线程篇 Android开发最佳实践 工具 Android Studio 调试 Android Studio你不知道的调试技巧 Android Studio 小技巧/快捷键 合集 快捷键 Android Studio你不知道的快捷键(一) Android Studio你不知道的快捷键(二) Android Studio你不知道的快捷键(三) Android Studio Plugin Android Method Count 统计方法数的插件 ADB WIFI 通过Wifi调试App ADB Idea 通过该插件：卸载应用、杀掉应用进程、启动应用、重启应用、清除应用数据、清除应用数据并且启动 Android ButterKnife Zelezny 与ButterKnife配套的注解插件 Android Studio FindViewById (不使用注解) Android Parcelable code generator 序列化插件 GsonFormat json实体类生成插件 Markdown Navigator 文档编辑 SelectorChapek for Android 通过资源名自动生成Selector Drawable File Grouping 根据文件名进行文件分组 Codota 搜索最好的Android代码 Configuration Android Studio Configuring Android Studio 英文版 Configuring Android Studio 中文版 架构 组件化 &amp; 模块化 Android组件化方案 考拉Android客户端路由总线设计 Android架构思考(模块化、多进程) MVP Android MVP 架构必要知识 Android MVP 架构必要知识：第一部分 Android MVP 架构必要知识：第二部分 Android MVP 架构必要知识：第三部分（Dialog，ViewPager，RecyclerView 以及 Adapters) MVVM 测试 关于安卓单元测试，你需要知道的一切 Android单元测试（一）从是什么开始 Android单元测试（二）：再来谈谈为什么 Android单元测试（三）：JUnit单元测试框架的使用 Android单元测试（四）：Mock以及Mockito的使用 Android单元测试（五）：依赖注入，将mock方便的用起来 Android单元测试（六）：使用dagger2来做依赖注入，以及在单元测试中的应用 Android单元测试（七）：Robolectric，在JVM上调用安卓的类 Android单元测试（八）：Junit Rule的使用 Android单元测试（九）：使用Mockito Annotation快速创建Mock Android单元测试（十）：DaggerMock：The Power of Dagger2, The Ease of Mockito Android单元测试(十一)：异步代码怎么测试 Android单元测试在蘑菇街支付金融部门的实践 Android 3rd library 30多个Android开发者超赞的工具 安卓开发常用工具和第三方库汇总 Hugo Annotation-triggered method call logging for your debug builds. 系统 博客 Bugly Bugly-CSDN Git Git 版本控制与工作流 Other ​]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android Application 必备的基本功能]]></title>
    <url>%2F1986%2F08%2F03%2Fandroid_app_system_share%2F</url>
    <content type="text"><![CDATA[本文所秉承“知其原理，实践证明”的宗旨。来讲述一个 Android Application 所必备的一些基本功能。 Android 开发规范 日志管理系统 logcat 命令行工具 logcat日志输出颜色 如何安全地打印日志 如何优雅地输出日志 loger timber Android Studio Live Templates 日志 Tag 的定义：哪些地方应该打Tag (toto) 异常管理系统(todo) 应用全局异常捕获 Thread.UncaughtExceptionHandler 获取设备相关信息 获取系统信息 唯一标识符最佳做法 第三方异常捕获SDK库以及Bug后台管理系统 Bugly 客户端集成 后台查看Bug BugTags 有 Bugly 和 BugClose 的功能,特点在于全民测试 ( 摇一摇,随时随地提交Bug ). BugClose 主要给测试人员使用的后台Bug管理系统. 通知管理系统(todo) 官网资料 Notification RemoteViews NotificationManager NotificationCompat.Builder 网络资料 Notification通知栏开发详解 Notification及RemoteViews整理 通知栏介绍与适配总结 通知栏Notification的整合 页面管理系统 Activity管理. 文件管理系统 网络管理系统 Android：检测网络状态&amp;监听网络变化 屏幕适配系统 动画管理系统 打包发布系统 内测分发 FIR 蒲公英 工具类和基类 AndroidUtilCode 1 AndroidUtilCode 2 闪屏 引导页 用户管理系统[登录登出Token]]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[高仿[凯叔讲故事]App]]></title>
    <url>%2F1986%2F08%2F03%2Fandroid-ks-app%2F</url>
    <content type="text"><![CDATA[闪屏页面 引导页面 用户管理 ​ 设计模式 数据结构 计算机网络 操作系统 自定义控件 音视频播放 网络通信 数据库 JSON解析 多线程 异步通讯 性能优化]]></content>
      <categories>
        <category>android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript]]></title>
    <url>%2F1986%2F08%2F02%2Fjava-script%2F</url>
    <content type="text"><![CDATA[Promise Promise 使用 Fetch Fetch使用]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java基础总结]]></title>
    <url>%2F1986%2F08%2F02%2Fjava-base%2F</url>
    <content type="text"><![CDATA[最近发现自己的Java基础很烂，所以针对各个地方的不足，上网进行恶补。 进制以及进制之间的转换 http://jingyan.baidu.com/article/495ba84109665338b30ede98.html http://jingyan.baidu.com/article/47a29f24292608c0142399cb.html http://www.cnblogs.com/icerainsoft/archive/2012/08/06/2624790.html 打印ASCII表与进制对照表 8种基本类型 http://www.runoob.com/java/java-basic-datatypes.html 日期和时间 IO流 Java8Java 8 教程汇总 Java 8的新特性—终极版 Java 知道您的类型 Java 8 中的 Streams API 详解 Java8 Lambda使用与原理 JAVA 8 函数式接口 - Functional Interface 在Android项目中使用Java8 RxJava2 探索专为 Android 而设计的 RxJava 2 ​ 图解RxJava2 图解RxJava2(一)/) 图解RxJava2(二)/) 图解RxJava2(三)/) ​ 关于RxJava最友好的文章 关于RxJava最友好的文章（初级篇） 关于RxJava最友好的文章（进阶篇） 关于RxJava最友好的文章——背压（Backpressure） 关于 RxJava 最友好的文章—— RxJava 2.0 全新来袭 ​ RxJava 2.x 使用详解 RxJava 2.x 使用详解(一) 快速入门 RxJava 2.x 使用详解(二) 创建操作符 RxJava 2.x 使用详解(三) 过滤操作符 RxJava 2.x 使用详解(四) 合并聚合操作符 RxJava 2.x 使用详解(五) 条件操作符 RxJava 2.x 使用详解(六) 变换操作符]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
</search>
