<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />




<script data-ad-client="ca-pub-7376123380604387" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>











  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="静水流深" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="为了梦-追梦,我的英文名由此而来">
<meta property="og:type" content="website">
<meta property="og:title" content="静水流深">
<meta property="og:url" content="http://blog.lijunbo.com/page/6/index.html">
<meta property="og:site_name" content="静水流深">
<meta property="og:description" content="为了梦-追梦,我的英文名由此而来">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="静水流深">
<meta name="twitter:description" content="为了梦-追梦,我的英文名由此而来">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.lijunbo.com/page/6/"/>





  <title> 静水流深 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4a874f383236eb548cfc14b4365008b8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">静水流深</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">非淡泊无以明志，非宁静无以致远</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/04/07/rqd-composition-vs-inheritance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/07/rqd-composition-vs-inheritance/" itemprop="url">
                  Composition vs Inheritance(组合与继承)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-07T11:11:11+08:00">
                2017-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/07/rqd-composition-vs-inheritance/" class="leancloud_visitors" data-flag-title="Composition vs Inheritance(组合与继承)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>React has a powerful composition model, and we recommend using composition instead of inheritance to reuse code between components.</p>
<p>React具有强大的组合模型，我们建议使用组合而不是继承来重用组件之间的代码。</p>
<p>In this section, we will consider a few problems where developers new to React often reach for inheritance, and show how we can solve them with composition.</p>
<p>在本节中，我们将考虑开发者创建React应用经常会触碰到使用继承的几个问题，并展示我们如何用组合来解决它们。</p>
<h2 id="Containment-遏制"><a href="#Containment-遏制" class="headerlink" title="Containment (遏制)"></a>Containment (遏制)</h2><p>Some components don’t know their children ahead of time. This is especially common for components like <code>Sidebar</code> or <code>Dialog</code> that represent generic “boxes”.</p>
<p>一些组件不能提前知道他们的孩子组件。 这对于表示通用“框”的<code>Sidebar</code>或<code>Dialog</code>的组件尤其常见。</p>
<p>We recommend that such components use the special <code>children</code> prop to pass children elements directly into their output:</p>
<p>我们建议像这样的组件使用特殊的<code>children</code>属性，将孩子元素直接传递到他们的输出中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function FancyBorder(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&#123;&apos;FancyBorder FancyBorder-&apos; + props.color&#125;&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This lets other components pass arbitrary children to them by nesting the JSX:</p>
<p>这允许其他组件通过嵌套JSX传递任意孩子组件给它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function WelcomeDialog() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color=&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className=&quot;Dialog-title&quot;&gt;</span><br><span class="line">        Welcome</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p className=&quot;Dialog-message&quot;&gt;</span><br><span class="line">        Thank you for visiting our spacecraft!</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/ozqNOV?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Anything inside the <code>&lt;FancyBorder&gt;</code> JSX tag gets passed into the <code>FancyBorder</code> component as a <code>children</code> prop. Since <code>FancyBorder</code> renders <code>{props.children}</code> inside a <code>&lt;div&gt;</code>, the passed elements appear in the final output.</p>
<p><code>&lt;FancyBorder&gt;</code> JSX标签内的任何内容都将作为孩子组件传入<code>FancyBorder</code>组件。 由于<code>FancyBorder</code>组件将<code>{props.children}</code>呈现在<code>&lt;div&gt;</code>内，所以传递的孩子元素将显示在最终输出中。</p>
<p>While this is less common, sometimes you might need multiple “holes” in a component. In such cases you may come up with your own convention instead of using <code>children</code>:</p>
<p>虽然这不太常见，但有时您在组件中可能需要多个“孔”。 在这种情况下，您可以提出自己的惯例取代使用<code>children</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function SplitPane(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;SplitPane&quot;&gt;</span><br><span class="line">      &lt;div className=&quot;SplitPane-left&quot;&gt;</span><br><span class="line">        &#123;props.left&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=&quot;SplitPane-right&quot;&gt;</span><br><span class="line">        &#123;props.right&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;SplitPane</span><br><span class="line">      left=&#123;</span><br><span class="line">        &lt;Contacts /&gt;</span><br><span class="line">      &#125;</span><br><span class="line">      right=&#123;</span><br><span class="line">        &lt;Chat /&gt;</span><br><span class="line">      &#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/gwZOJp?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>React elements like <code>&lt;Contacts /&gt;</code> and <code>&lt;Chat /&gt;</code> are just objects, so you can pass them as props like any other data.</p>
<p>React元素（例如<code>&lt;Contacts /&gt;</code>和<code>&lt;Chat /&gt;</code>）只是对象，因此您可以将其作为任何其他组件的属性并传递给它们。</p>
<h2 id="Specialization-专业化"><a href="#Specialization-专业化" class="headerlink" title="Specialization (专业化)"></a>Specialization (专业化)</h2><p>Sometimes we think about components as being “special cases” of other components. For example, we might say that a <code>WelcomeDialog</code> is a special case of <code>Dialog</code>.</p>
<p>有时我们认为组件是其他组件的“特殊情况”。 例如，我们可以说<code>WelcomeDialog</code>是<code>Dialog</code>的一个特例。</p>
<p>In React, this is also achieved by composition, where a more “specific” component renders a more “generic” one and configures it with props:</p>
<p>在React中，这也是通过组合来实现的，其中一个更“特定的”组件呈现出更“通用的”组件，并用属性来配置它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Dialog(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color=&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className=&quot;Dialog-title&quot;&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p className=&quot;Dialog-message&quot;&gt;</span><br><span class="line">        &#123;props.message&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">    &lt;/FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function WelcomeDialog() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Dialog</span><br><span class="line">      title=&quot;Welcome&quot;</span><br><span class="line">      message=&quot;Thank you for visiting our spacecraft!&quot; /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/kkEaOZ?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Composition works equally well for components defined as classes:</p>
<p>组合对于定义为类的组件同样适用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function Dialog(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;FancyBorder color=&quot;blue&quot;&gt;</span><br><span class="line">      &lt;h1 className=&quot;Dialog-title&quot;&gt;</span><br><span class="line">        &#123;props.title&#125;</span><br><span class="line">      &lt;/h1&gt;</span><br><span class="line">      &lt;p className=&quot;Dialog-message&quot;&gt;</span><br><span class="line">        &#123;props.message&#125;</span><br><span class="line">      &lt;/p&gt;</span><br><span class="line">      &#123;props.children&#125;</span><br><span class="line">    &lt;/FancyBorder&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SignUpDialog extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSignUp = this.handleSignUp.bind(this);</span><br><span class="line">    this.state = &#123;login: &apos;&apos;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;Dialog title=&quot;Mars Exploration Program&quot;</span><br><span class="line">              message=&quot;How should we refer to you?&quot;&gt;</span><br><span class="line">        &lt;input value=&#123;this.state.login&#125;</span><br><span class="line">               onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleSignUp&#125;&gt;</span><br><span class="line">          Sign Me Up!</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/Dialog&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.setState(&#123;login: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSignUp() &#123;</span><br><span class="line">    alert(`Welcome aboard, $&#123;this.state.login&#125;!`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/gwZbYa?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<h2 id="So-What-About-Inheritance-那么继承如何呢？"><a href="#So-What-About-Inheritance-那么继承如何呢？" class="headerlink" title="So What About Inheritance? (那么继承如何呢？)"></a>So What About Inheritance? (那么继承如何呢？)</h2><p>At Facebook, we use React in thousands of components, and we haven’t found any use cases where we would recommend creating component inheritance hierarchies.</p>
<p>在Facebook上，我们在数千个组件中使用React，我们还没有发现任何用例，我们建议您创建组件继承层次结构。</p>
<p>Props and composition give you all the flexibility you need to customize a component’s look and behavior in an explicit and safe way. Remember that components may accept arbitrary props, including primitive values, React elements, or functions.</p>
<p>属性和组合为您提供了以明确和安全的方式自定义组件外观和行为所需的所有灵活性。 请记住，组件可以接受任意属性，包括基本类型，React元素或函数。</p>
<p>If you want to reuse non-UI functionality between components, we suggest extracting it into a separate JavaScript module. The components may import it and use that function, object, or a class, without extending it.</p>
<p>如果要在组件之间重用非UI功能，我们建议将其提取到单独的JavaScript模块中。 组件可以导入它并使用该函数，对象或类，而不扩展它。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/04/06/rqd-lifting-state-up/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/06/rqd-lifting-state-up/" itemprop="url">
                  Lifting State Up(提升状态)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-06T11:11:11+08:00">
                2017-04-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/06/rqd-lifting-state-up/" class="leancloud_visitors" data-flag-title="Lifting State Up(提升状态)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor. Let’s see how this works in action.</p>
<p>通常，一系列的组件需要反映相同的变化的数据。 我们建议将共享状态提升到他们最近的共同的父组件中。 让我们看看这是如何工作的。</p>
<p>In this section, we will create a temperature calculator that calculates whether the water would boil at a given temperature.</p>
<p>在本节中，我们将创建一个温度计算器来计算水在一定温度下是否沸腾。</p>
<p>We will start with a component called <code>BoilingVerdict</code>. It accepts the <code>celsius</code> temperature as a prop, and prints whether it is enough to boil the water:</p>
<p>我们将从一个名为<code>BoilingVerdic</code>t的组件开始。 它接受<code>摄氏</code>温度作为支柱，并打印是否足以煮水：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function BoilingVerdict(props) &#123;</span><br><span class="line">  if (props.celsius &gt;= 100) &#123;</span><br><span class="line">    return &lt;p&gt;The water would boil.&lt;/p&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;p&gt;The water would not boil.&lt;/p&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Next, we will create a component called <code>Calculator</code>. It renders an <code>&lt;input&gt;</code> that lets you enter the temperature, and keeps its value in <code>this.state.temperature</code>.</p>
<p>接下来，我们将创建一个名为<code>Calculator</code>的组件。 它渲染一个允许您输入温度的<code>&lt;input&gt;</code>，并将其值保存在<code>this.state.temperature</code>中。</p>
<p>Additionally, it renders the <code>BoilingVerdict</code> for the current input value.</p>
<p>此外，它为<code>BoilingVerdict</code>提供当前输入值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Calculator extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.state = &#123;temperature: &apos;&apos;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const temperature = this.state.temperature;</span><br><span class="line">    return (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature in Celsius:&lt;/legend&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          value=&#123;temperature&#125;</span><br><span class="line">          onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;BoilingVerdict</span><br><span class="line">          celsius=&#123;parseFloat(temperature)&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/valscion/pen/VpZJRZ?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<h2 id="Adding-a-Second-Input-添加第二个输入"><a href="#Adding-a-Second-Input-添加第二个输入" class="headerlink" title="Adding a Second Input(添加第二个输入)"></a>Adding a Second Input(添加第二个输入)</h2><p>Our new requirement is that, in addition to a Celsius input, we provide a Fahrenheit input, and they are kept in sync.</p>
<p>我们的新要求是，除了摄氏度的输入，我们提供华氏度的输入，并保持同步。</p>
<p>We can start by extracting a <code>TemperatureInput</code> component from <code>Calculator</code>. We will add a new <code>scale</code> prop to it that can either be <code>&quot;c&quot;</code> or <code>&quot;f&quot;</code>:</p>
<p>我们可以从<code>Calculator</code>中提取一个<code>TemperatureInput</code>组件。 我们将添加一个可以是<code>“c”</code>或<code>“f”</code>的新<code>scale</code> 属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">const scaleNames = &#123;</span><br><span class="line">  c: &apos;Celsius&apos;,</span><br><span class="line">  f: &apos;Fahrenheit&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class TemperatureInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.state = &#123;temperature: &apos;&apos;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const temperature = this.state.temperature;</span><br><span class="line">    const scale = this.props.scale;</span><br><span class="line">    return (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt;</span><br><span class="line">        &lt;input value=&#123;temperature&#125;</span><br><span class="line">               onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We can now change the <code>Calculator</code> to render two separate temperature inputs:</p>
<p>我们现在可以更改 <code>Calculator</code> ，以提供两个独立的温度输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Calculator extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;TemperatureInput scale=&quot;c&quot; /&gt;</span><br><span class="line">        &lt;TemperatureInput scale=&quot;f&quot; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/valscion/pen/GWKbao?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>We have two inputs now, but when you enter the temperature in one of them, the other doesn’t update. This contradicts our requirement: we want to keep them in sync.</p>
<p>我们现在有两个输入，但是当您输入其中一个时，另一个不更新。 这与我们的要求相矛盾：我们希望保持同步。</p>
<p>We also can’t display the <code>BoilingVerdict</code> from <code>Calculator</code>. The <code>Calculator</code> doesn’t know the current temperature because it is hidden inside the <code>TemperatureInput</code>.</p>
<p>我们也无法从 <code>Calculator</code>显示<code>BoilingVerdict</code>。  <code>Calculator</code>不知道当前的温度，因为它隐藏在TemperatureInput内。</p>
<h2 id="Writing-Conversion-Functions-写入转换功能"><a href="#Writing-Conversion-Functions-写入转换功能" class="headerlink" title="Writing Conversion Functions(写入转换功能)"></a>Writing Conversion Functions(写入转换功能)</h2><p>First, we will write two functions to convert from Celsius to Fahrenheit and back:</p>
<p>首先，我们将写入两个从【摄氏度转换为华氏度】和【华氏度转换为摄氏度】的函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toCelsius</span>(<span class="params">fahrenheit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (fahrenheit - <span class="number">32</span>) * <span class="number">5</span> / <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toFahrenheit</span>(<span class="params">celsius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (celsius * <span class="number">9</span> / <span class="number">5</span>) + <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>These two functions convert numbers. We will write another function that takes a string <code>temperature</code> and a converter function as arguments and returns a string. We will use it to calculate the value of one input based on the other input.</p>
<p>这两个函数转换数字。 我们将编写另一个函数，它将字符串温度和转换器函数作为参数，并返回一个字符串。 我们将使用它来根据其他输入来计算一个新的输入的值。</p>
<p>It returns an empty string on an invalid <code>temperature</code>, and it keeps the output rounded to the third decimal place:</p>
<p>它在一个无效的<code>温度</code>上返回一个空字符串，它保持输出四舍五入到小数点后三位：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tryConvert</span>(<span class="params">temperature, convert</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> input = <span class="built_in">parseFloat</span>(temperature);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Number</span>.isNaN(input)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> output = convert(input);</span><br><span class="line">  <span class="keyword">const</span> rounded = <span class="built_in">Math</span>.round(output * <span class="number">1000</span>) / <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> rounded.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For example, <code>tryConvert(&#39;abc&#39;, toCelsius)</code> returns an empty string, and <code>tryConvert(&#39;10.22&#39;, toFahrenheit)</code> returns <code>&#39;50.396&#39;</code>.</p>
<p>例如， <code>tryConvert(&#39;abc&#39;, toCelsius)</code> 返回一个空字符串，而<code>tryConvert(&#39;10.22&#39;, toFahrenheit)</code> 返回’50 .396’。</p>
<h2 id="Lifting-State-Up-提升状态"><a href="#Lifting-State-Up-提升状态" class="headerlink" title="Lifting State Up(提升状态)"></a>Lifting State Up(提升状态)</h2><p>Currently, both <code>TemperatureInput</code> components independently keep their values in the local state:</p>
<p>目前，两个<code>TemperatureInput</code>组件都将其值保持在本地状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class TemperatureInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.state = &#123;temperature: &apos;&apos;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const temperature = this.state.temperature;</span><br></pre></td></tr></table></figure>
<p>However, we want these two inputs to be in sync with each other. When we update the Celsius input, the Fahrenheit input should reflect the converted temperature, and vice versa.</p>
<p>然而，我们希望这两个输入是相互同步的。 当我们更新摄氏温度输入时，华氏输入应反映转换温度，反之亦然。</p>
<p>In React, sharing state is accomplished by moving it up to the closest common ancestor of the components that need it. This is called “lifting state up”. We will remove the local state from the <code>TemperatureInput</code> and move it into the <code>Calculator</code> instead.</p>
<p>在React中，共享状态是通过将其移动到需要它的组件的最近的共同父组件中来实现的。 这被称为<code>&quot;提升状态&quot;</code>。 我们将从<code>TemperatureInput</code>中删除本地状态，并将其移动到<code>Calculator</code>中。</p>
<p>If the <code>Calculator</code> owns the shared state, it becomes the “source of truth” for the current temperature in both inputs. It can instruct them both to have values that are consistent with each other. Since the props of both <code>TemperatureInput</code> components are coming from the same parent <code>Calculator</code> component, the two inputs will always be in sync.</p>
<p>如果 <code>Calculator</code> 拥有共享状态，则它将成为两个当前温度的输入的“真实来源”。 它可以指定他们具有彼此一致的值。 由于两个<code>TemperatureInput</code>组件的属性来自同一个父组件： <code>Calculator</code>，所以两个输入的值将始终保持同步。</p>
<p>Let’s see how this works step by step.</p>
<p>让我们看看这是如何一步一步工作的。</p>
<p>First, we will replace <code>this.state.temperature</code> with <code>this.props.temperature</code> in the <code>TemperatureInput</code> component. For now, let’s pretend <code>this.props.temperature</code> already exists, although we will need to pass it from the <code>Calculator</code> in the future:</p>
<p>首先，我们将在<code>TemperatureInput</code>组件中用<code>this.props.temperature</code>替换<code>this.state.temperature</code>。 虽然我们将来需要从 <code>Calculator</code> 中传递给它，但现在，假设<code>this.props.temperature</code>已经存在：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  // Before: const temperature = this.state.temperature;</span><br><span class="line">  const temperature = this.props.temperature;</span><br></pre></td></tr></table></figure>
<p>We know that <a href="/react/docs/components-and-props.html#props-are-read-only">props are read-only</a>. When the <code>temperature</code> was in the local state, the <code>TemperatureInput</code> could just call <code>this.setState()</code> to change it. However, now that the <code>temperature</code> is coming from the parent as a prop, the <code>TemperatureInput</code> has no control over it.</p>
<p>我们知道属性是只读的。 当 <code>temperature</code> 处于本地状态时，<code>TemperatureInput</code>可以调用<code>this.setState()</code>来更改它。 然而，现在 <code>temperature</code> 来自父组件并作为作为子组件的属性，温度的输入无法控制。</p>
<p>In React, this is usually solved by making a component “controlled”. Just like the DOM <code>&lt;input&gt;</code> accepts both a <code>value</code> and an <code>onChange</code> prop, so can the custom <code>TemperatureInput</code> accept both <code>temperature</code> and <code>onTemperatureChange</code> props from its parent <code>Calculator</code>.</p>
<p>在React中，通常通过使组件“受控”来解决。 就像DOM <code>&lt;input&gt;</code>一样，同时接受一个 <code>value</code> 和一个 <code>onChange</code> 支持，所以自定义的<code>TemperatureInput</code>也可以接受来自其父组件(<code>Calculator</code>)的<code>temperature</code>和<code>onTemperatureChange</code>函数作为属性。</p>
<p>Now, when the <code>TemperatureInput</code> wants to update its temperature, it calls <code>this.props.onTemperatureChange</code>:</p>
<p>现在，当<code>TemperatureInput</code>想要更新其温度时，它会调用<code>this.props.onTemperatureChange</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleChange(e) &#123;</span><br><span class="line">  // Before: this.setState(&#123;temperature: e.target.value&#125;);</span><br><span class="line">  this.props.onTemperatureChange(e.target.value);</span><br></pre></td></tr></table></figure>
<p>Note that there is no special meaning to either <code>temperature</code> or <code>onTemperatureChange</code> prop names in custom components. We could have called them anything else, like name them <code>value</code> and <code>onChange</code> which is a common convention.</p>
<p>请注意，自定义组件中的 <code>temperature</code> 或 <code>onTemperatureChange</code> 属性名称没有特殊的含义。 我们可以叫他们任何其他的东西，像命名他们的<code>value</code>和<code>onChange</code>这是一个常见的惯例。</p>
<p>The <code>onTemperatureChange</code> prop will be provided together with the <code>temperature</code> prop by the parent <code>Calculator</code> component. It will handle the change by modifying its own local state, thus re-rendering both inputs with the new values. We will look at the new <code>Calculator</code> implementation very soon.</p>
<p><code>onTemperatureChange</code> 属性将与父组件（<code>temperature</code>）的<code>temperature</code>属性一起提供。 它将通过修改自己的本地状态来处理更改，从而将输入的新值重新渲染到两个输入组件。 我们将很快看到新的<code>Calculator</code>实现。</p>
<p>Before diving into the changes in the <code>Calculator</code>, let’s recap our changes to the <code>TemperatureInput</code> component. We have removed the local state from it, and instead of reading <code>this.state.temperature</code>, we now read <code>this.props.temperature</code>. Instead of calling <code>this.setState()</code> when we want to make a change, we now call <code>this.props.onTemperatureChange()</code>, which will be provided by the <code>Calculator</code>:</p>
<p>在进入<code>Calculator</code>组件中更改之前，让我们回顾一下对<code>TemperatureInput</code>组件的更改。 我们已经从中删除了本地状态，而不是读取<code>this.state.temperature</code>，我们现在读取<code>this.props.temperature</code>。 我们现在调用由 <code>Calculator</code>提供的<code>this.props.onTemperatureChange()</code>函数，而不是调用<code>this.setState()</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class TemperatureInput extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(e) &#123;</span><br><span class="line">    this.props.onTemperatureChange(e.target.value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const temperature = this.props.temperature;</span><br><span class="line">    const scale = this.props.scale;</span><br><span class="line">    return (</span><br><span class="line">      &lt;fieldset&gt;</span><br><span class="line">        &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt;</span><br><span class="line">        &lt;input value=&#123;temperature&#125;</span><br><span class="line">               onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">      &lt;/fieldset&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Now let’s turn to the <code>Calculator</code> component.</p>
<p>现在我们来看一下<code>Calculator</code>组件。</p>
<p>We will store the current input’s <code>temperature</code> and <code>scale</code> in its local state. This is the state we “lifted up” from the inputs, and it will serve as the “source of truth” for both of them. It is the minimal representation of all the data we need to know in order to render both inputs.</p>
<p>我们将当前输入的<code>temperature</code>和<code>scale</code>存储在本地状态。 这是我们从输入中“提升”的状态，它将作为他们两个输入组件的“数据来源”。 为了渲染两个输入组件，我们需要知道数据对象的精简表示。</p>
<p>For example, if we enter 37 into the Celsius input, the state of the <code>Calculator</code> component will be:</p>
<p>例如，如果我们在摄氏度输入中输入37，则计算器组件的状态将是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  temperature: <span class="string">'37'</span>,</span><br><span class="line">  scale: <span class="string">'c'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If we later edit the Fahrenheit field to be 212, the state of the <code>Calculator</code> will be:</p>
<p>如果我们稍后将“华氏”字段编辑为212，则<code>Calculator</code>的状态将为：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  temperature: <span class="string">'212'</span>,</span><br><span class="line">  scale: <span class="string">'f'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We could have stored the value of both inputs but it turns out to be unnecessary. It is enough to store the value of the most recently changed input, and the scale that it represents. We can then infer the value of the other input based on the current <code>temperature</code> and <code>scale</code> alone.</p>
<p>我们可以存储两个输入的值，但实际上是不必要的。 存储最近更改的输入的值以及它所代表的比例就足够了。 然后，我们可以基于当前的<code>temperature</code>和<code>scale</code>来推断其他输入的值。</p>
<p>The inputs stay in sync because their values are computed from the same state:</p>
<p>因为它们的值是从相同的状态计算的，所以输入能够保持同步：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Calculator extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);</span><br><span class="line">    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);</span><br><span class="line">    this.state = &#123;temperature: &apos;&apos;, scale: &apos;c&apos;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleCelsiusChange(temperature) &#123;</span><br><span class="line">    this.setState(&#123;scale: &apos;c&apos;, temperature&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleFahrenheitChange(temperature) &#123;</span><br><span class="line">    this.setState(&#123;scale: &apos;f&apos;, temperature&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const scale = this.state.scale;</span><br><span class="line">    const temperature = this.state.temperature;</span><br><span class="line">    const celsius = scale === &apos;f&apos; ? tryConvert(temperature, toCelsius) : temperature;</span><br><span class="line">    const fahrenheit = scale === &apos;c&apos; ? tryConvert(temperature, toFahrenheit) : temperature;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;TemperatureInput</span><br><span class="line">          scale=&quot;c&quot;</span><br><span class="line">          temperature=&#123;celsius&#125;</span><br><span class="line">          onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt;</span><br><span class="line">        &lt;TemperatureInput</span><br><span class="line">          scale=&quot;f&quot;</span><br><span class="line">          temperature=&#123;fahrenheit&#125;</span><br><span class="line">          onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt;</span><br><span class="line">        &lt;BoilingVerdict</span><br><span class="line">          celsius=&#123;parseFloat(celsius)&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/valscion/pen/jBNjja?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Now, no matter which input you edit, <code>this.state.temperature</code> and <code>this.state.scale</code> in the <code>Calculator</code> get updated. One of the inputs gets the value as is, so any user input is preserved, and the other input value is always recalculated based on it.</p>
<p>现在，无论您编辑哪个输入，<code>Calculator</code>中的<code>this.state.temperature</code>和<code>this.state.scale</code>都会更新。 其中一个输入组件获取值，所以任何用户输入都被保留，另一个输入组件总是基于它重新计算值。</p>
<p>Let’s recap what happens when you edit an input:</p>
<p>让我们回顾一下编辑输入时会发生什么：</p>
<ul>
<li>React calls the function specified as <code>onChange</code> on the DOM <code>&lt;input&gt;</code>. In our case, this is the <code>handleChange</code> method in <code>TemperatureInput</code> component.</li>
<li>React调用在DOM <code>&lt;input&gt;</code>上指定为<code>onChange</code>的函数。 在我们的例子中，这是调用<code>TemperatureInput</code>组件中的<code>handleChange</code>方法。</li>
<li>The <code>handleChange</code> method in the <code>TemperatureInput</code> component calls <code>this.props.onTemperatureChange()</code> with the new desired value. Its props, including <code>onTemperatureChange</code>, were provided by its parent component, the <code>Calculator</code>.</li>
<li><code>TemperatureInput</code>组件中的<code>handleChange</code>函数使用新的输入值调用<code>this.props.onTemperatureChange()</code>函数。 其属性包括<code>onTemperatureChange</code>，由其父组件<code>Calculator</code>提供。</li>
<li>When it previously rendered, the <code>Calculator</code> has specified that <code>onTemperatureChange</code> of the Celsius <code>TemperatureInput</code> is the <code>Calculator</code>‘s <code>handleCelsiusChange</code> method, and <code>onTemperatureChange</code> of the Fahrenheit <code>TemperatureInput</code> is the <code>Calculator</code>‘s <code>handleFahrehnheitChange</code> method. So either of these two <code>Calculator</code> methods gets called depending on which input we edited.</li>
<li>当它初次渲染时，<code>Calculator</code>已经指定了摄氏组件<code>TemperatureInput</code>的<code>onTemperatureChange</code>函数作为<code>Calculator</code>的<code>handleCelsiusChange</code>方法的回调，而华氏组件<code>TemperatureInput</code>的<code>onTemperatureChange</code>函数作为<code>Calculator</code>的<code>handleFahrehnheitChange</code>方法的回调。 因此，根据我们编辑的输入，回调这两个<code>Calculator</code>方法。</li>
<li>Inside these methods, the <code>Calculator</code> component asks React to re-render itself by calling <code>this.setState()</code> with the new input value and the current scale of the input we just edited.</li>
<li>在这些方法中，<code>Calculator</code> 组件要求React通过使用新的输入值和刚刚编辑输入的当前比例调用<code>this.setState（）</code>来重新渲染自身。</li>
<li>React calls the <code>Calculator</code> component’s <code>render</code> method to learn what the UI should look like. The values of both inputs are recomputed based on the current temperature and the active scale. The temperature conversion is performed here.</li>
<li>React调用<code>Calculator</code>组件的<code>render</code>方法了解UI的外观。 基于当前温度和有效刻度重新计算两个输入的值，并在这里进行温度转换。</li>
<li>React calls the <code>render</code> methods of the individual <code>TemperatureInput</code> components with their new props specified by the <code>Calculator</code>. It learns what their UI should look like.</li>
<li>React使用计算器指定的新属性值调用各个·TemperatureInput·组件的<code>render</code>方法。 它会了解UI的外观。</li>
<li>React DOM updates the DOM to match the desired input values. The input we just edited receives its current value, and the other input is updated to the temperature after conversion.</li>
<li>React DOM更新DOM以匹配所需的输入值。 我们刚刚编辑的输入接收其当前值，另一个输入更新为转换后的温度。</li>
</ul>
<p>Every update goes through the same steps so the inputs stay in sync.</p>
<p>每个更新都会执行相同的步骤，以便输入保持同步。</p>
<h2 id="Lessons-Learned-学到的经验"><a href="#Lessons-Learned-学到的经验" class="headerlink" title="Lessons Learned(学到的经验)"></a>Lessons Learned(学到的经验)</h2><p>There should be a single “source of truth” for any data that changes in a React application. Usually, the state is first added to the component that needs it for rendering. Then, if other components also need it, you can lift it up to their closest common ancestor. Instead of trying to sync the state between different components, you should rely on the <a href="/react/docs/state-and-lifecycle.html#the-data-flows-down">top-down data flow</a>.</p>
<p>对于在React应用程序中更改的任何数据，应该有一个“真实来源”。 通常，状态首先被添加到需要渲染的组件中。 然后，如果其他组件也需要它，您可以将其提升到最近的同一父组件。 而不是尝试同步不同组件之间的状态，您应该依靠自上而下的数据流。</p>
<p>Lifting state involves writing more “boilerplate” code than two-way binding approaches, but as a benefit, it takes less work to find and isolate bugs. Since any state “lives” in some component and that component alone can change it, the surface area for bugs is greatly reduced. Additionally, you can implement any custom logic to reject or transform user input.</p>
<p>提升状态涉及编写比“双向绑定”方法更多的“样板”代码，但有一个好处，找到隔离错误的工作要少一些。 由于任何状态“生活“在某些组件中，并且该组件单独可以改变它，所以错误的表面积大大降低。 此外，您可以实现任何自定义逻辑来拒绝或转换用户输入。</p>
<p>If something can be derived from either props or state, it probably shouldn’t be in the state. For example, instead of storing both <code>celsiusValue</code> and <code>fahrenheitValue</code>, we store just the last edited <code>temperature</code> and its <code>scale</code>. The value of the other input can always be calculated from them in the <code>render()</code> method. This lets us clear or apply rounding to the other field without losing any precision in the user input.</p>
<p>如果数据可以从属性或状态得到，那么它可能不应该处于状态。 例如，我们不是存储<code>celsiusValue</code>和<code>fahrenheitValue</code>，而是仅存储最后编辑的<code>temperature</code> 和 <code>scale</code>。 在<code>render（）</code>方法中，其他输入的值始终可以从它们中计算出来。 这使我们可以清除或应用四舍五入到其他字段，而不会在用户输入中丢失任何精度。</p>
<p>When you see something wrong in the UI, you can use <a href="https://github.com/facebook/react-devtools" target="_blank" rel="noopener">React Developer Tools</a> to inspect the props and move up the tree until you find the component responsible for updating the state. This lets you trace the bugs to their source:</p>
<p>当您在UI中看到错误时，您可以使用React Developer Tools来检查道具，并向上移动树，直到找到负责更新状态的组件。 这可以让你跟踪这些错误来源：</p>
<p><img src="https://facebook.github.io/react/img/docs/react-devtools-state.gif" alt="Monitoring State in React DevTools" width="100%"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/04/05/rqd-forms/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/05/rqd-forms/" itemprop="url">
                  Forms(表单)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-05T11:11:11+08:00">
                2017-04-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/05/rqd-forms/" class="leancloud_visitors" data-flag-title="Forms(表单)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>HTML form elements work a little bit differently from other DOM elements in React, because form elements naturally keep some internal state. For example, this form in plain HTML accepts a single name:</p>
<p>HTML表单元素与React中的其他DOM元素有所不同，因为表单元素自然地保持一些内部状态。 例如，这个HTML格式的表单接受一个单一的名字：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">    Name:</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>This form has the default HTML form behavior of browsing to a new page when the user submits the form. If you want this behavior in React, it just works. But in most cases, it’s convenient to have a JavaScript function that handles the submission of the form and has access to the data that the user entered into the form. The standard way to achieve this is with a technique called “controlled components”.</p>
<p>当用户提交表单时，此表单具有[默认HTML表单(跳转到)新页面的行为]。 如果你想要这个行为在React中工作。 但是在大多数情况下，拥有处理提交表单（并）可访问用户输入表单的数据的（JavaScript函数）很方便。 实现这一点的标准方式是使用一种称为<code>&quot;受控组件&quot;</code>的技术。</p>
<h2 id="Controlled-Components-受控组件"><a href="#Controlled-Components-受控组件" class="headerlink" title="Controlled Components(受控组件)"></a>Controlled Components(受控组件)</h2><p>In HTML, form elements such as <code>&lt;input&gt;</code>, <code>&lt;textarea&gt;</code>, and <code>&lt;select&gt;</code> typically maintain their own state and update it based on user input. In React, mutable state is typically kept in the state property of components, and only updated with <a href="/react/docs/react-component.html#setstate"><code>setState()</code></a>.</p>
<p>在HTML中，诸如<code>&lt;input&gt;</code>，<code>&lt;textarea&gt;</code>和<code>&lt;select&gt;</code>的表单元素通常保持自己的状态，并根据用户输入进行更新。 在React中，可变状态通常保存在组件的<code>状态</code>属性中，并且只能使用<code>setState()</code>进行更新。</p>
<p>We can combine the two by making the React state be the “single source of truth”. Then the React component that renders a form also controls what happens in that form on subsequent user input. An input form element whose value is controlled by React in this way is called a “controlled component”.</p>
<p>我们可以结合两者，使React的<code>状态</code>成为“真实数据的来源”。 然后，渲染表单的React组件也控制在后续用户输入时该表单中发生的情况。 以这种方式，其值由React控制的输入表单元素称为<code>&quot;受控组件&quot;</code>。</p>
<p>For example, if we want to make the previous example log the name when it is submitted, we can write the form as a controlled component:</p>
<p>例如，如果我们想使上一个示例在提交时记录名称，我们可以将表单写为受控组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class NameForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;value: &apos;&apos;&#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&apos;A name was submitted: &apos; + this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codepen.io/gaearon/pen/VmmPgp?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Since the <code>value</code> attribute is set on our form element, the displayed value will always be <code>this.state.value</code>, making the React state the source of truth. Since <code>handleChange</code> runs on every keystroke to update the React state, the displayed value will update as the user types.</p>
<p>由于在我们的表单元素上设置了<code>value</code>属性，并且使React的状态成为数据的来源，所以显示的值始终为<code>this.state.value</code>。 由于<code>handleChange</code>在每个按键上触发输入以更新React状态，所以显示的值将随用户的输入更新。</p>
<p>With a controlled component, every state mutation will have an associated handler function. This makes it straightforward to modify or validate user input. For example, if we wanted to enforce that names are written with all uppercase letters, we could write <code>handleChange</code> as:</p>
<p>使用受控组件，每个状态的变化将具有相关联的处理函数。 这使得可以直接修改或验证用户输入。 例如，如果我们要强制这个名字用全部大写字母写，我们可以把<code>handleChange</code>写成：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleChange(event) &#123;</span><br><span class="line">  this.setState(&#123;value: event.target.value.toUpperCase()&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-textarea-Tag-textarea标签"><a href="#The-textarea-Tag-textarea标签" class="headerlink" title="The textarea Tag(textarea标签)"></a>The textarea Tag(textarea标签)</h2><p>In HTML, a <code>&lt;textarea&gt;</code> element defines its text by its children:</p>
<p>在HTML中，<code>&lt;textarea&gt;</code>元素由其子元素定义其文本：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span></span><br><span class="line">  Hello there, this is some text in a text area</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>In React, a <code>&lt;textarea&gt;</code> uses a <code>value</code> attribute instead. This way, a form using a <code>&lt;textarea&gt;</code> can be written very similarly to a form that uses a single-line input:</p>
<p>在React中，<code>&lt;textarea&gt;</code>使用<code>value</code>属性替代。 这样，使用<code>&lt;textarea&gt;</code>的表单非常类似于使用单行输入的表单：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class EssayForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      value: &apos;Please write an essay about your favorite DOM element.&apos;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&apos;An essay was submitted: &apos; + this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;textarea value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Notice that <code>this.state.value</code> is initialized in the constructor, so that the text area starts off with some text in it.</p>
<p>请注意，在构造函数中初始化<code>this.state.value</code>，以便文本区域使用这些文本开始显示。</p>
<h2 id="The-select-Tag-lt-select-gt-标签"><a href="#The-select-Tag-lt-select-gt-标签" class="headerlink" title="The select Tag( &lt;select&gt; 标签)"></a>The select Tag( <code>&lt;select&gt;</code> 标签)</h2><p>In HTML, <code>&lt;select&gt;</code> creates a drop-down list. For example, this HTML creates a drop-down list of flavors:</p>
<p>在HTML中，<code>&lt;select&gt;</code>创建一个下拉列表。 例如，此HTML创建一个下拉列表的风格：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"grapefruit"</span>&gt;</span>Grapefruit<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"lime"</span>&gt;</span>Lime<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span> <span class="attr">value</span>=<span class="string">"coconut"</span>&gt;</span>Coconut<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"mango"</span>&gt;</span>Mango<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Note that the Coconut option is initially selected, because of the <code>selected</code> attribute. React, instead of using this <code>selected</code> attribute, uses a <code>value</code> attribute on the root <code>select</code> tag. This is more convenient in a controlled component because you only need to update it in one place. For example:</p>
<p>请注意，由于 <code>selected</code> 的属性初始值设置了Coconut选项。 在React中，使用根<code>select</code> 标签上的<code>value</code>属性，替代<code>selected</code>的属性。这在受控组件中更方便，因为您只需要在一个位置更新它。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class FlavorForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;value: &apos;coconut&apos;&#125;;</span><br><span class="line"></span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;</span><br><span class="line">    this.setState(&#123;value: event.target.value&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&apos;Your favorite flavor is: &apos; + this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Pick your favorite La Croix flavor:</span><br><span class="line">          &lt;select value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125;&gt;</span><br><span class="line">            &lt;option value=&quot;grapefruit&quot;&gt;Grapefruit&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;lime&quot;&gt;Lime&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;coconut&quot;&gt;Coconut&lt;/option&gt;</span><br><span class="line">            &lt;option value=&quot;mango&quot;&gt;Mango&lt;/option&gt;</span><br><span class="line">          &lt;/select&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codepen.io/gaearon/pen/JbbEzX?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Overall, this makes it so that <code>&lt;input type=&quot;text&quot;&gt;</code>, <code>&lt;textarea&gt;</code>, and <code>&lt;select&gt;</code> all work very similarly - they all accept a <code>value</code> attribute that you can use to implement a controlled component.</p>
<p>总的来说，这样做使得<code>&lt;input type =&quot;text&quot;&gt;</code>，<code>&lt;textarea&gt;</code>和<code>&lt;select&gt;</code>运行都非常相似 - 它们都接受一个 <code>value</code> 属性，您可以使用它来实现受控组件。</p>
<h2 id="Handling-Multiple-Inputs-处理多个输入"><a href="#Handling-Multiple-Inputs-处理多个输入" class="headerlink" title="Handling Multiple Inputs(处理多个输入)"></a>Handling Multiple Inputs(处理多个输入)</h2><p>When you need to handle multiple controlled <code>input</code> elements, you can add a <code>name</code> attribute to each element and let the handler function choose what to do based on the value of <code>event.target.name</code>.</p>
<p>当您需要处理多个受控 <code>input</code> 元素时，可以向每个元素添加一个 <code>name</code> 属性，让处理函数根据<code>event.target.name</code>的值来选择要执行的操作。</p>
<p>For example:</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Reservation extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      isGoing: true,</span><br><span class="line">      numberOfGuests: 2</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    this.handleInputChange = this.handleInputChange.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputChange(event) &#123;</span><br><span class="line">    const target = event.target;</span><br><span class="line">    const value = target.type === &apos;checkbox&apos; ? target.checked : target.value;</span><br><span class="line">    const name = target.name;</span><br><span class="line"></span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      [name]: value</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Is going:</span><br><span class="line">          &lt;input</span><br><span class="line">            name=&quot;isGoing&quot;</span><br><span class="line">            type=&quot;checkbox&quot;</span><br><span class="line">            checked=&#123;this.state.isGoing&#125;</span><br><span class="line">            onChange=&#123;this.handleInputChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;br /&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Number of guests:</span><br><span class="line">          &lt;input</span><br><span class="line">            name=&quot;numberOfGuests&quot;</span><br><span class="line">            type=&quot;number&quot;</span><br><span class="line">            value=&#123;this.state.numberOfGuests&#125;</span><br><span class="line">            onChange=&#123;this.handleInputChange&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codepen.io/gaearon/pen/wgedvV?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Note how we used the ES6 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names" target="_blank" rel="noopener">computed property name</a> syntax to update the state key corresponding to the given input name:</p>
<p>注意我们如何使用ES6 <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names" target="_blank" rel="noopener">计算属性名称</a> 的语法来更新与给定输入名称相对应的状态键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this.setState(&#123;</span><br><span class="line">  [name]: value</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>It is equivalent to this ES5 code:</p>
<p>这相当于这个ES5代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var partialState = &#123;&#125;;</span><br><span class="line">partialState[name] = value;</span><br><span class="line">this.setState(partialState);</span><br></pre></td></tr></table></figure>
<p>Also, since <code>setState()</code> automatically <a href="/react/docs/state-and-lifecycle.html#state-updates-are-merged">merges a partial state into the current state</a>, we only needed to call it with the changed parts.</p>
<p>此外，由于<code>setState()</code>自动将部分状态合并到当前状态，所以我们只需要调用它去改变更改的部分。</p>
<h2 id="Alternatives-to-Controlled-Components"><a href="#Alternatives-to-Controlled-Components" class="headerlink" title="Alternatives to Controlled Components"></a>Alternatives to Controlled Components</h2><p>It can sometimes be tedious to use controlled components, because you need to write an event handler for every way your data can change and pipe all of the input state through a React component. This can become particularly annoying when you are converting a preexisting codebase to React, or integrating a React application with a non-React library. In these situations, you might want to check out <a href="/react/docs/uncontrolled-components.html">uncontrolled components</a>, an alternative technique for implementing input forms.</p>
<p>使用受控组件有时可能很繁琐，因为您需要为数据可以更改的每种方式编写一个事件处理程序，并通过一个React组件管理所有的输入状态。 当您将预先存在的代码库转换为React或将React应用程序与非React库集成时，这可能变得特别烦人。 在这些情况下，您可能需要检查不受控制的组件，这是实现输入表单的替代技术。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/04/04/rqd-lists-and-keys/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/04/rqd-lists-and-keys/" itemprop="url">
                  Lists and Keys(列表和键)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-04T11:11:11+08:00">
                2017-04-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/04/rqd-lists-and-keys/" class="leancloud_visitors" data-flag-title="Lists and Keys(列表和键)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>First, let’s review how you transform lists in JavaScript.</p>
<p>首先，我们来看看如何在JavaScript中转换列表。</p>
<p>Given the code below, we use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener"><code>map()</code></a> function to take an array of <code>numbers</code> and double their values. We assign the new array returned by <code>map()</code> to the variable <code>doubled</code> and log it:</p>
<p>给出下面的代码，我们使用<code>map（）</code>函数操作一个 <code>numbers</code> 数组，并将其值加倍。 我们将<code>map（）</code>返回的翻倍的数组分配给一个新数组并输出它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">const doubled = numbers.map((number) =&gt; number * 2);</span><br><span class="line">console.log(doubled);</span><br></pre></td></tr></table></figure>
<p>This code logs <code>[2, 4, 6, 8, 10]</code> to the console.</p>
<p>此代码将数组 <code>[2, 4, 6, 8, 10]</code> 输出到控制台。</p>
<p>In React, transforming arrays into lists of <a href="/react/docs/rendering-elements.html">elements</a> is nearly identical.</p>
<p>在React中，将数组转换为元素列表几乎相同。</p>
<h3 id="Rendering-Multiple-Components-渲染多个组件"><a href="#Rendering-Multiple-Components-渲染多个组件" class="headerlink" title="Rendering Multiple Components(渲染多个组件)"></a>Rendering Multiple Components(渲染多个组件)</h3><p>You can build collections of elements and <a href="/react/docs/introducing-jsx.html#embedding-expressions-in-jsx">include them in JSX</a> using curly braces <code>{}</code>.</p>
<p>您可以构建元素集合，并使用<code>花括号{}</code>将它们包含在JSX中。</p>
<p>Below, we loop through the <code>numbers</code> array using the Javascript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener"><code>map()</code></a> function. We return an <code>&lt;li&gt;</code> element for each item. Finally, we assign the resulting array of elements to <code>listItems</code>:</p>
<p>下面，我们使用Javascript <code>map（）</code>函数将 <code>numbers</code> 数组进行循环操作。 我们返回每个项目的<code>&lt;li&gt;</code>元素。 最后，我们将结果的元素数组分配给listItems：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">const listItems = numbers.map((number) =&gt;</span><br><span class="line">  &lt;li&gt;&#123;number&#125;&lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>We include the entire <code>listItems</code> array inside a <code>&lt;ul&gt;</code> element, and <a href="/react/docs/rendering-elements.html#rendering-an-element-into-the-dom">render it to the DOM</a>:</p>
<p>我们将整个<code>listItems</code>数组包含在一个<code>&lt;ul&gt;</code>元素中，并将其渲染到DOM中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="https://codepen.io/gaearon/pen/GjPyQr?editors=0011" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>This code displays a bullet list of numbers between 1 and 5.</p>
<p>此代码显示1到5之间的数字项目符号列表。</p>
<h3 id="Basic-List-Component-基本列表组件"><a href="#Basic-List-Component-基本列表组件" class="headerlink" title="Basic List Component(基本列表组件)"></a>Basic List Component(基本列表组件)</h3><p>Usually you would render lists inside a <a href="/react/docs/components-and-props.html">component</a>.</p>
<p>通常你会在一个组件中渲染列表。</p>
<p>We can refactor the previous example into a component that accepts an array of <code>numbers</code> and outputs an unordered list of elements.</p>
<p>我们可以将前面的例子重构成接受数字数组的一个组件，并输出一个无序的元素列表。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.map((number) =&gt;</span><br><span class="line">    &lt;li&gt;&#123;number&#125;&lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>When you run this code, you’ll be given a warning that a key should be provided for list items. A “key” is a special string attribute you need to include when creating lists of elements. We’ll discuss why it’s important in the next section.</p>
<p>当您运行此代码时，您将被给予一个警告，以便为列表项提供一个密钥。  “key” 是创建元素列表时需要包含的特殊字符串属性。 我们将在下一节讨论为什么它很重要。</p>
<p>Let’s assign a <code>key</code> to our list items inside <code>numbers.map()</code> and fix the missing key issue.</p>
<p>让我们分配一个<code>key</code>到我们的<code>list.map（）</code>列表项中，并修复缺少的关键字问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.map((number) =&gt;</span><br><span class="line">    &lt;li key=&#123;number.toString()&#125;&gt;</span><br><span class="line">      &#123;number&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="https://codepen.io/gaearon/pen/jrXYRR?editors=0011" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<h2 id="Keys-键"><a href="#Keys-键" class="headerlink" title="Keys(键)"></a>Keys(键)</h2><p>Keys help React identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity:</p>
<p>键帮助React确定哪些项目已更改，添加或删除。 应该给元素数组中的元素赋予一个稳定的身份：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">const listItems = numbers.map((number) =&gt;</span><br><span class="line">  &lt;li key=&#123;number.toString()&#125;&gt;</span><br><span class="line">    &#123;number&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>The best way to pick a key is to use a string that uniquely identifies a list item among its siblings. Most often you would use IDs from your data as keys:</p>
<p>选择<code>key</code>的最好方法是使用一个字符串来唯一标识其组件之间的列表项。 您通常会使用数据中的ID作为<code>key</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const todoItems = todos.map((todo) =&gt;</span><br><span class="line">  &lt;li key=&#123;todo.id&#125;&gt;</span><br><span class="line">    &#123;todo.text&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>When you don’t have stable IDs for rendered items, you may use the item index as a key as a last resort:</p>
<p>当您没有用于渲染项目的稳定ID时，您可以使用项目索引作为<code>key</code>的最后手段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const todoItems = todos.map((todo, index) =&gt;</span><br><span class="line">  // Only do this if items have no stable IDs</span><br><span class="line">  &lt;li key=&#123;index&#125;&gt;</span><br><span class="line">    &#123;todo.text&#125;</span><br><span class="line">  &lt;/li&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>We don’t recommend using indexes for keys if the items can reorder, as that would be slow. You may read an <a href="/react/docs/reconciliation.html#recursing-on-children">in-depth explanation about why keys are necessary</a> if you’re interested.</p>
<p>如果项目可以重新排序，我们不建议使用键的索引，因为这会很慢。 如果您有兴趣，您可以阅读《深入了解为什么需要键》。</p>
<h3 id="Extracting-Components-with-Keys-用键提取组件"><a href="#Extracting-Components-with-Keys-用键提取组件" class="headerlink" title="Extracting Components with Keys(用键提取组件)"></a>Extracting Components with Keys(用键提取组件)</h3><p>Keys only make sense in the context of the surrounding array.</p>
<p>键只有在数组周围的上下文中才有意义。</p>
<p>For example, if you <a href="/react/docs/components-and-props.html#extracting-components">extract</a> a <code>ListItem</code> component, you should keep the key on the <code>&lt;ListItem /&gt;</code> elements in the array rather than on the root <code>&lt;li&gt;</code> element in the <code>ListItem</code> itself.</p>
<p>例如，如果您提取了<code>ListItem</code>组件，则应该将该键保存在数组中的<code>&lt;ListItem /&gt;</code>元素上，而不是<code>ListItem</code>本身中的根<code>&lt;li&gt;</code>元素上。</p>
<p><strong>Example: Incorrect Key Usage</strong></p>
<p><strong>示例：不正确使用密钥</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">function ListItem(props) &#123;</span><br><span class="line">  const value = props.value;</span><br><span class="line">  return (</span><br><span class="line">    // 错误！ 这里没有必要指定键：</span><br><span class="line">    &lt;li key=&#123;value.toString()&#125;&gt;</span><br><span class="line">      &#123;value&#125;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.map((number) =&gt;</span><br><span class="line">    // 错误！ key应该在这里指定：</span><br><span class="line">    &lt;ListItem value=&#123;number&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>Example: Correct Key Usage</strong></p>
<p><strong>示例：正确使用密钥</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function ListItem(props) &#123;</span><br><span class="line">  // 正确！ 这里没有必要指定键：</span><br><span class="line">  return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.map((number) =&gt;</span><br><span class="line">    // 正确！ key应在数组内指定。</span><br><span class="line">    &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const numbers = [1, 2, 3, 4, 5];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;NumberList numbers=&#123;numbers&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="https://codepen.io/rthor/pen/QKzJKG?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>A good rule of thumb is that elements inside the <code>map()</code> call need keys.</p>
<p>一个很好的经验法则是在<code>map（）</code>函数调用中添加元素需要的<code>key</code>。</p>
<h3 id="Keys-Must-Only-Be-Unique-Among-Siblings-Key在兄弟组件中必须是唯一的"><a href="#Keys-Must-Only-Be-Unique-Among-Siblings-Key在兄弟组件中必须是唯一的" class="headerlink" title="Keys Must Only Be Unique Among Siblings(Key在兄弟组件中必须是唯一的)"></a>Keys Must Only Be Unique Among Siblings(Key在兄弟组件中必须是唯一的)</h3><p>Keys used within arrays should be unique among their siblings. However they don’t need to be globally unique. We can use the same keys when we produce two different arrays:</p>
<p>数组中使用的Key在其兄弟组件之间应该是唯一的。 然而，它们不需要是全局唯一的。 当我们生成两个不同的数组时，我们可以使用相同的键：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">function Blog(props) &#123;</span><br><span class="line">  const sidebar = (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;props.posts.map((post) =&gt;</span><br><span class="line">        &lt;li key=&#123;post.id&#125;&gt;</span><br><span class="line">          &#123;post.title&#125;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">  const content = props.posts.map((post) =&gt;</span><br><span class="line">    &lt;div key=&#123;post.id&#125;&gt;</span><br><span class="line">      &lt;h3&gt;&#123;post.title&#125;&lt;/h3&gt;</span><br><span class="line">      &lt;p&gt;&#123;post.content&#125;&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;sidebar&#125;</span><br><span class="line">      &lt;hr /&gt;</span><br><span class="line">      &#123;content&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const posts = [</span><br><span class="line">  &#123;id: 1, title: &apos;Hello World&apos;, content: &apos;Welcome to learning React!&apos;&#125;,</span><br><span class="line">  &#123;id: 2, title: &apos;Installation&apos;, content: &apos;You can install React from npm.&apos;&#125;</span><br><span class="line">];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Blog posts=&#123;posts&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="https://codepen.io/gaearon/pen/NRZYGN?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Keys serve as a hint to React but they don’t get passed to your components. If you need the same value in your component, pass it explicitly as a prop with a different name:</p>
<p>Key充当React的一个提示，但它不会传递给您的组件。 如果您的组件中需要相同的值，请将其作为具有不同名称的属性进行显式传递：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const content = posts.map((post) =&gt;</span><br><span class="line">  &lt;Post</span><br><span class="line">    key=&#123;post.id&#125;</span><br><span class="line">    id=&#123;post.id&#125;</span><br><span class="line">    title=&#123;post.title&#125; /&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>With the example above, the <code>Post</code> component can read <code>props.id</code>, but not <code>props.key</code>.</p>
<p>通过上面的例子，<code>Post</code>组件可以读取<code>props.id</code>，而不是<code>props.key</code>。</p>
<h3 id="Embedding-map-in-JSX-在JSX中嵌入map"><a href="#Embedding-map-in-JSX-在JSX中嵌入map" class="headerlink" title="Embedding map() in JSX(在JSX中嵌入map() )"></a>Embedding map() in JSX(在JSX中嵌入map() )</h3><p>In the examples above we declared a separate <code>listItems</code> variable and included it in JSX:</p>
<p>在上面的例子中，我们声明了一个单独的<code>listItems</code>变量并将其包含在JSX中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  const listItems = numbers.map((number) =&gt;</span><br><span class="line">    &lt;ListItem key=&#123;number.toString()&#125;</span><br><span class="line">              value=&#123;number&#125; /&gt;</span><br><span class="line">  );</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;listItems&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JSX allows <a href="/react/docs/introducing-jsx.html#embedding-expressions-in-jsx">embedding any expressions</a> in curly braces so we could inline the <code>map()</code> result:</p>
<p>JSX允许将任何表达式嵌入到花括号中，以便我们可以内联<code>map（）</code>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function NumberList(props) &#123;</span><br><span class="line">  const numbers = props.numbers;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;numbers.map((number) =&gt;</span><br><span class="line">        &lt;ListItem key=&#123;number.toString()&#125;</span><br><span class="line">                  value=&#123;number&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codepen.io/gaearon/pen/BLvYrB?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Sometimes this results in clearer code, but this style can also be abused. Like in JavaScript, it is up to you to decide whether it is worth extracting a variable for readability. Keep in mind that if the <code>map()</code> body is too nested, it might be a good time to <a href="/react/docs/components-and-props.html#extracting-components">extract a component</a>.</p>
<p>有时这会使代码更清晰的，但这种风格写法也可能被滥用。 像JavaScript一样，由你决定是否值得提取可变性的变量。 请记住，如果<code>map（）</code>内容嵌套太深，这可能是提取组件的好时机。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/04/03/rqd-conditional-rendering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/03/rqd-conditional-rendering/" itemprop="url">
                  Conditional Rendering(条件渲染)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-03T11:11:11+08:00">
                2017-04-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/03/rqd-conditional-rendering/" class="leancloud_visitors" data-flag-title="Conditional Rendering(条件渲染)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>In React, you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application.</p>
<p>在React中，您可以创建不同的组件来封装所需的行为。 然后，您可以只渲染其中的一部分，具体取决于应用程序的状态。</p>
<p>Conditional rendering in React works the same way conditions work in JavaScript. Use JavaScript operators like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else" target="_blank" rel="noopener"><code>if</code></a> or the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" target="_blank" rel="noopener">conditional operator</a> to create elements representing the current state, and let React update the UI to match them.</p>
<p>React中的条件渲染与JavaScript中的条件相同。 使用if或条件运算符等JavaScript运算符创建表示当前状态的元素，然后让React更新UI来匹配它们。</p>
<p>Consider these two components:</p>
<p>考虑这两个组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Welcome back!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GuestGreeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Please sign up.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We’ll create a <code>Greeting</code> component that displays either of these components depending on whether a user is logged in:</p>
<p>我们将创建一个<code>Greeting</code>组件，根据用户是否登录，显示这些组件之一：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Greeting(props) &#123;</span><br><span class="line">  const isLoggedIn = props.isLoggedIn;</span><br><span class="line">  if (isLoggedIn) &#123;</span><br><span class="line">    return &lt;UserGreeting /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;GuestGreeting /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  // Try changing to isLoggedIn=&#123;true&#125;:</span><br><span class="line">  &lt;Greeting isLoggedIn=&#123;false&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="https://codepen.io/gaearon/pen/ZpVxNq?editors=0011" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>This example renders a different greeting depending on the value of <code>isLoggedIn</code> prop.</p>
<p>此示例根据<code>isLoggedIn</code> prop的值呈现不同的问候语。</p>
<h3 id="Element-Variables-元素变量"><a href="#Element-Variables-元素变量" class="headerlink" title="Element Variables(元素变量)"></a>Element Variables(元素变量)</h3><p>You can use variables to store elements. This can help you conditionally render a part of the component while the rest of the output doesn’t change.</p>
<p>您可以使用变量来存储元素。 这可以帮助您有条件地渲染组件的一部分，而输出的其余部分不会更改。</p>
<p>Consider these two new components representing Logout and Login buttons:</p>
<p>考虑这两个代表注销和登录按钮的新组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LoginButton</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;button onClick=&#123;props.onClick&#125;&gt;</span><br><span class="line">      Login</span><br><span class="line">    &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function LogoutButton(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;props.onClick&#125;&gt;</span></span><br><span class="line"><span class="regexp">      Logout</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In the example below, we will create a <a href="/react/docs/state-and-lifecycle.html#adding-local-state-to-a-class">stateful component</a> called <code>LoginControl</code>.</p>
<p>在下面的例子中，我们将创建一个名为<code>LoginControl</code>的有状态组件。</p>
<p>It will render either <code>&lt;LoginButton /&gt;</code> or <code>&lt;LogoutButton /&gt;</code> depending on its current state. It will also render a <code>&lt;Greeting /&gt;</code> from the previous example:</p>
<p>它将根据当前状态渲染<code>&lt;LoginButton /&gt;</code>或<code>&lt;LogoutButton /&gt;</code>。 它还将从上一个示例中呈现<code>&lt;Greeting /&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class LoginControl extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleLoginClick = this.handleLoginClick.bind(this);</span><br><span class="line">    this.handleLogoutClick = this.handleLogoutClick.bind(this);</span><br><span class="line">    this.state = &#123;isLoggedIn: false&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleLoginClick() &#123;</span><br><span class="line">    this.setState(&#123;isLoggedIn: true&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleLogoutClick() &#123;</span><br><span class="line">    this.setState(&#123;isLoggedIn: false&#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const isLoggedIn = this.state.isLoggedIn;</span><br><span class="line"></span><br><span class="line">    let button = null;</span><br><span class="line">    if (isLoggedIn) &#123;</span><br><span class="line">      button = &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      button = &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Greeting isLoggedIn=&#123;isLoggedIn&#125; /&gt;</span><br><span class="line">        &#123;button&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;LoginControl /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="https://codepen.io/gaearon/pen/QKzAgB?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>While declaring a variable and using an <code>if</code> statement is a fine way to conditionally render a component, sometimes you might want to use a shorter syntax. There are a few ways to inline conditions in JSX, explained below.</p>
<p>虽然声明变量并使用if语句是有条件地渲染组件的好方法，但有时您可能希望使用较短的语法。 在JSX中有几种内联条件的方法，如下所述。</p>
<h3 id="Inline-If-with-Logical-amp-amp-Operator-内联-比较运算符或逻辑运算符"><a href="#Inline-If-with-Logical-amp-amp-Operator-内联-比较运算符或逻辑运算符" class="headerlink" title="Inline If with Logical &amp;&amp; Operator(内联[比较运算符或逻辑运算符])"></a>Inline If with Logical &amp;&amp; Operator(内联[比较运算符或逻辑运算符])</h3><p>You may <a href="/react/docs/introducing-jsx.html#embedding-expressions-in-jsx">embed any expressions in JSX</a> by wrapping them in curly braces. This includes the JavaScript logical <code>&amp;&amp;</code> operator. It can be handy for conditionally including an element:</p>
<p>您可以在JSX中嵌入任何表达式，方法是将其包裹在花括号中。 这包括JavaScript逻辑<code>&amp;&amp;</code>运算符。 它有助于有条件地渲染一个元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Mailbox(props) &#123;</span><br><span class="line">  const unreadMessages = props.unreadMessages;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello!&lt;/h1&gt;</span><br><span class="line">      &#123;unreadMessages.length &gt; 0 &amp;&amp;</span><br><span class="line">        &lt;h2&gt;</span><br><span class="line">          You have &#123;unreadMessages.length&#125; unread messages.</span><br><span class="line">        &lt;/h2&gt;</span><br><span class="line">      &#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const messages = [&apos;React&apos;, &apos;Re: React&apos;, &apos;Re:Re: React&apos;];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Mailbox unreadMessages=&#123;messages&#125; /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="https://codepen.io/gaearon/pen/ozJddz?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>It works because in JavaScript, <code>true &amp;&amp; expression</code> always evaluates to <code>expression</code>, and <code>false &amp;&amp; expression</code> always evaluates to <code>false</code>.</p>
<p>因为在JavaScript中，它是有效的，<code>true &amp;&amp; expression</code>总是认为表达式，并且 <code>false &amp;&amp; expression</code> 总是认为false。</p>
<p>Therefore, if the condition is <code>true</code>, the element right after <code>&amp;&amp;</code> will appear in the output. If it is <code>false</code>, React will ignore and skip it.</p>
<p>所以，如果条件为<code>true</code>，则<code>&amp;&amp;</code>后面的元素将显示在输出中。 如果是<code>false</code>，React会忽略并跳过它。</p>
<h3 id="Inline-If-Else-with-Conditional-Operator-内联-if-Else有条件运算符"><a href="#Inline-If-Else-with-Conditional-Operator-内联-if-Else有条件运算符" class="headerlink" title="Inline If-Else with Conditional Operator(内联[if-Else有条件运算符])"></a>Inline If-Else with Conditional Operator(内联[if-Else有条件运算符])</h3><p>Another method for conditionally rendering elements inline is to use the JavaScript conditional operator <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" target="_blank" rel="noopener"><code>condition ? true : false</code></a>.</p>
<p>有条件地渲染元素的另一种方法是使用JavaScript条件运算符<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator" target="_blank" rel="noopener"><code>条件 ? 真 : 假</code></a>.</p>
<p>In the example below, we use it to conditionally render a small block of text.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  const isLoggedIn = this.state.isLoggedIn;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      The user is &lt;b&gt;&#123;isLoggedIn ? &apos;currently&apos; : &apos;not&apos;&#125;&lt;/b&gt; logged in.</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It can also be used for larger expressions although it is less obvious what’s going on:</p>
<p>虽然不太明显改变了什么，但它也可以用于更复杂的表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  const isLoggedIn = this.state.isLoggedIn;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;isLoggedIn ? (</span><br><span class="line">        &lt;LogoutButton onClick=&#123;this.handleLogoutClick&#125; /&gt;</span><br><span class="line">      ) : (</span><br><span class="line">        &lt;LoginButton onClick=&#123;this.handleLoginClick&#125; /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Just like in JavaScript, it is up to you to choose an appropriate style based on what you and your team consider more readable. Also remember that whenever conditions become too complex, it might be a good time to <a href="/react/docs/components-and-props.html#extracting-components">extract a component</a>.</p>
<p>就像在JavaScript中一样，您可以根据您和您的团队认为更易读的方式选择合适的样式。 还要记住，只要条件变得太复杂，可能是提取组件的好时机。</p>
<h3 id="Preventing-Component-from-Rendering-防止组件渲染"><a href="#Preventing-Component-from-Rendering-防止组件渲染" class="headerlink" title="Preventing Component from Rendering(防止组件渲染)"></a>Preventing Component from Rendering(防止组件渲染)</h3><p>In rare cases you might want a component to hide itself even though it was rendered by another component. To do this return <code>null</code> instead of its render output.</p>
<p>在极少数情况下，您可能希望组件隐藏自身，即使它由另一个组件呈现。 为此，返回<code>null</code>而不是其渲染输出。</p>
<p>In the example below, the <code>&lt;WarningBanner /&gt;</code> is rendered depending on the value of the prop called <code>warn</code>. If the value of the prop is <code>false</code>, then the component does not render:</p>
<p>在下面的示例中，根据名为<code>warn</code>的属性值渲染<code>&lt;WarningBanner /&gt;</code>。 如果属性值为<code>false</code>，则该组件不呈现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">function WarningBanner(props) &#123;</span><br><span class="line">  if (!props.warn) &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;warning&quot;&gt;</span><br><span class="line">      Warning!</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Page extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;showWarning: true&#125;</span><br><span class="line">    this.handleToggleClick = this.handleToggleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleToggleClick() &#123;</span><br><span class="line">    this.setState(prevState =&gt; (&#123;</span><br><span class="line">      showWarning: !prevState.showWarning</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;WarningBanner warn=&#123;this.state.showWarning&#125; /&gt;</span><br><span class="line">        &lt;button onClick=&#123;this.handleToggleClick&#125;&gt;</span><br><span class="line">          &#123;this.state.showWarning ? &apos;Hide&apos; : &apos;Show&apos;&#125;</span><br><span class="line">        &lt;/button&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Page /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="https://codepen.io/gaearon/pen/Xjoqwm?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Returning <code>null</code> from a component’s <code>render</code> method does not affect the firing of the component’s lifecycle methods. For instance, <code>componentWillUpdate</code> and <code>componentDidUpdate</code> will still be called.</p>
<p>从组件的<code>render</code>方法返回null不会影响组件生命周期方法的触发。 例如，componentWillUpdate和componentDidUpdate仍将被调用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/04/02/rqd-handling-events/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/02/rqd-handling-events/" itemprop="url">
                  Handling Events(处理事件)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-02T11:11:11+08:00">
                2017-04-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/02/rqd-handling-events/" class="leancloud_visitors" data-flag-title="Handling Events(处理事件)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Handling events with React elements is very similar to handling events on DOM elements. There are some syntactic differences:</p>
<p>使用React元素处理事件与处理DOM元素上的事件非常相似。 只不过有一些语法上的差异：</p>
<ul>
<li>React events are named using camelCase, rather than lowercase.</li>
<li>React事件使用驼峰规则命名，而不是小写。</li>
<li>With JSX you pass a function as the event handler, rather than a string.</li>
<li>使用JSX，您可以传递一个函数作为事件处理程序，而不是一个字符串。</li>
</ul>
<p>For example, the HTML:</p>
<p>例如，HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"activateLasers()"</span>&gt;</span></span><br><span class="line">  Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>is slightly different in React:</p>
<p>在React中略有不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>
<p>Another difference is that you cannot return <code>false</code> to prevent default behavior in React. You must call <code>preventDefault</code> explicitly. For example, with plain HTML, to prevent the default link behavior of opening a new page, you can write:</p>
<p>另一个区别是您不能返回<code>false</code>以防止在React中的默认行为。 您必须显式调用<code>preventDefault</code>。 例如，使用纯HTML，为了防止打开新页面的默认链接行为，您可以写：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"console.log('The link was clicked.'); return false"</span>&gt;</span></span><br><span class="line">  Click me</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>In React, this could instead be:</p>
<p>在React中，这应该按如下方式代替：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function ActionLink() &#123;</span><br><span class="line">  function handleClick(e) &#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    console.log(&apos;The link was clicked.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;a href=&quot;#&quot; onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Here, <code>e</code> is a synthetic event. React defines these synthetic events according to the <a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener">W3C spec</a>, so you don’t need to worry about cross-browser compatibility. See the <a href="/react/docs/events.html"><code>SyntheticEvent</code></a> reference guide to learn more.</p>
<p>在这里，<code>e</code>是一个合成事件。 React根据W3C规范定义了这些合成事件，因此您不必担心跨浏览器的兼容性。 请参阅SyntheticEvent参考指南了解更多信息。</p>
<p>When using React you should generally not need to call <code>addEventListener</code> to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.</p>
<p>当使用React时，您通常不需要调用addEventListener来在创建DOM元素之后添加监听器。 而是在元素最初呈现时提供一个监听器。</p>
<p>When you define a component using an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a>, a common pattern is for an event handler to be a method on the class. For example, this <code>Toggle</code> component renders a button that lets the user toggle between “ON” and “OFF” states:</p>
<p>当您使用ES6类定义组件时，常见的模式是将事件处理程序作为类上的方法。 例如，<code>Toggle</code>组件呈现一个按钮，让用户在“ON”和“OFF”状态之间切换：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Toggle extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;isToggleOn: true&#125;;</span><br><span class="line"></span><br><span class="line">    // This binding is necessary to make `this` work in the callback</span><br><span class="line">    this.handleClick = this.handleClick.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    this.setState(prevState =&gt; (&#123;</span><br><span class="line">      isToggleOn: !prevState.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">        &#123;this.state.isToggleOn ? &apos;ON&apos; : &apos;OFF&apos;&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Toggle /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/xEmzGg?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>You have to be careful about the meaning of <code>this</code> in JSX callbacks. In JavaScript, class methods are not <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">bound</a> by default. If you forget to bind <code>this.handleClick</code> and pass it to <code>onClick</code>, <code>this</code> will be <code>undefined</code> when the function is actually called.</p>
<p>在JSX回调中你必须要注意<code>this</code>的含义。 在JavaScript中，类方法默认不受约束。 如果您忘记绑定<code>this.handleClick</code>并将其传递给<code>onClick</code>，那么当该函数实际被调用时，这将是未定义的。</p>
<p>This is not React-specific behavior; it is a part of <a href="https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/" target="_blank" rel="noopener">how functions work in JavaScript</a>. Generally, if you refer to a method without <code>()</code> after it, such as <code>onClick={this.handleClick}</code>, you should bind that method.</p>
<p>这不是React具体的行为; 它是JavaScript中功能如何工作的一部分。 一般来说，如果你引用一个没有<code>（）</code>的方法，比如<code>onClick = {this.handleClick}</code>，你应该绑定该方法。</p>
<p>If calling <code>bind</code> annoys you, there are two ways you can get around this. If you are using the experimental <a href="https://babeljs.io/docs/plugins/transform-class-properties/" target="_blank" rel="noopener">property initializer syntax</a>, you can use property initializers to correctly bind callbacks:</p>
<p>如果调用<code>绑定</code>令你烦恼，有两种方法可以解决这个问题。 如果您使用实验属性初始化程序语法，则可以使用属性初始值设置来正确绑定回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class LoggingButton extends React.Component &#123;</span><br><span class="line">  // This syntax ensures `this` is bound within handleClick.</span><br><span class="line">  // Warning: this is *experimental* syntax.</span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    console.log(&apos;this is:&apos;, this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;this.handleClick&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This syntax is enabled by default in <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a>.</p>
<p>默认情况下，此语法在创建React应用程序中启用。</p>
<p>If you aren’t using property initializer syntax, you can use an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">arrow function</a> in the callback:</p>
<p>如果您不使用属性初始化程序语法，则可以在回调中使用箭头函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class LoggingButton extends React.Component &#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(&apos;this is:&apos;, this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // This syntax ensures `this` is bound within handleClick</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The problem with this syntax is that a different callback is created each time the <code>LoggingButton</code> renders. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. We generally recommend binding in the constructor or using the property initializer syntax, to avoid this sort of performance problem.</p>
<p>这种语法的问题是：每次<code>LoggingButton</code>渲染时都会创建一个不同的回调函数。 在大多数情况下，这很好。 但是，如果这个回调作为支持传递给子组件，这些组件可能会进行额外的重新渲染。 <strong>我们通常建议在构造函数中使用绑定或使用属性初始化器语法来避免这种性能问题</strong>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/04/01/rqd-state-and-lifecycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/01/rqd-state-and-lifecycle/" itemprop="url">
                  State and Lifecycle(状态和生命周期)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-01T11:11:11+08:00">
                2017-04-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/01/rqd-state-and-lifecycle/" class="leancloud_visitors" data-flag-title="State and Lifecycle(状态和生命周期)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Consider the ticking clock example from <a href="/react/docs/rendering-elements.html#updating-the-rendered-element">one of the previous sections</a>.</p>
<p>考虑上一节的秒表时钟示例。</p>
<p>So far we have only learned one way to update the UI.</p>
<p>到目前为止，我们只学到了一种更新UI的方法。</p>
<p>We call <code>ReactDOM.render()</code> to change the rendered output:</p>
<p>我们调用 <code>ReactDOM.render()</code>来更改渲染的输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function tick() &#123;</span><br><span class="line">  const element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, 1000);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/gwoJZk?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>In this section, we will learn how to make the <code>Clock</code> component truly reusable and encapsulated. It will set up its own timer and update itself every second.</p>
<p>在本节中，我们将学习如何使<code>Clock</code>组件真正可重用和并对其封装。 它将设置自己的计时器并每秒更新一次。</p>
<p>We can start by encapsulating how the clock looks:</p>
<p>我们可以从封装时钟开始：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Clock(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function tick() &#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Clock date=&#123;new Date()&#125; /&gt;,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, 1000);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/dpdoYR?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>However, it misses a crucial requirement: the fact that the <code>Clock</code> sets up a timer and updates the UI every second should be an implementation detail of the <code>Clock</code>.</p>
<p>然而，它错过了一个关键的要求：<code>Clock</code>设置定时器并每秒更新UI的事实应该是<code>Clock</code>的实现细节。</p>
<p>Ideally we want to write this once and have the <code>Clock</code> update itself:</p>
<p>理想情况下，我们要写一下这个时钟更新本身：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>To implement this, we need to add “state” to the <code>Clock</code> component.</p>
<p>为了实现这一点，我们需要在<code>Clock</code>组件中添加”state”。</p>
<p>State is similar to props, but it is private and fully controlled by the component.</p>
<p>状态(State)类似于属性，但它是私有的，完全由组件控制。</p>
<p>We <a href="/react/docs/components-and-props.html#functional-and-class-components">mentioned before</a> that components defined as classes have some additional features. Local state is exactly that: a feature available only to classes.</p>
<p>我们之前提到，定义为类的组件具有一些附加功能。 本地状态就是这样：一个功能只适用于类。</p>
<h2 id="Converting-a-Function-to-a-Class-将函数转换为类"><a href="#Converting-a-Function-to-a-Class-将函数转换为类" class="headerlink" title="Converting a Function to a Class(将函数转换为类)"></a>Converting a Function to a Class(将函数转换为类)</h2><p>You can convert a functional component like <code>Clock</code> to a class in five steps:</p>
<ol>
<li>Create an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a> with the same name that extends <code>React.Component</code>.</li>
<li>Add a single empty method to it called <code>render()</code>.</li>
<li>Move the body of the function into the <code>render()</code> method.</li>
<li>Replace <code>props</code> with <code>this.props</code> in the <code>render()</code> body.</li>
<li>Delete the remaining empty function declaration.</li>
</ol>
<hr>
<p>您可以通过五个步骤将时钟功能组件转换为类：</p>
<ol>
<li>创建一个名称继承为<code>React.Component</code>的ES6类。</li>
<li>在类中添加一个名为<code>render()</code>的空方法。</li>
<li>将函数体移动到<code>render()</code>方法中。</li>
<li>在<code>render()</code>函数中使用this.props替换<code>props</code>。</li>
<li>删除剩余的空函数声明。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.props.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/zKRGpo?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p><code>Clock</code> is now defined as a class rather than a function.</p>
<p><code>Clock</code>现在被定义为一个类而不是一个函数。</p>
<p>This lets us use additional features such as local state and lifecycle hooks.</p>
<p>这使我们可以使用其他功能，如本地状态和生命周期的钩子函数。</p>
<h2 id="Adding-Local-State-to-a-Class-将本地状态添加到类"><a href="#Adding-Local-State-to-a-Class-将本地状态添加到类" class="headerlink" title="Adding Local State to a Class(将本地状态添加到类)"></a>Adding Local State to a Class(将本地状态添加到类)</h2><p>We will move the <code>date</code> from props to state in three steps:</p>
<p>我们将分三个步骤，将<code>date</code>的属性映射到状态。</p>
<p>1) Replace <code>this.props.date</code> with <code>this.state.date</code> in the <code>render()</code> method:</p>
<p>1）在<code>render()</code>方法中将this.props.date替换为this.state.date：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2) Add a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes#Constructor" target="_blank" rel="noopener">class constructor</a> that assigns the initial <code>this.state</code>:</p>
<p>2）添加分配初始this.state到类的构造函数中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;date: new Date()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note how we pass <code>props</code> to the base constructor:</p>
<p>注意我们如何将 <code>props</code> 传递给基础构造函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state = &#123;date: new Date()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Class components should always call the base constructor with <code>props</code>.</p>
<p>类组件应始终使用 <code>props</code>调用基础构造函数。</p>
<p>3) Remove the <code>date</code> prop from the <code>&lt;Clock /&gt;</code> element:</p>
<p>3）从<code>&lt;Clock /&gt;</code>元素中删除日期：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>We will later add the timer code back to the component itself.</p>
<p>稍后将定时器代码添加回组件本身。</p>
<p>The result looks like this:</p>
<p>结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;date: new Date()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/KgQpJd?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Next, we’ll make the <code>Clock</code> set up its own timer and update itself every second.</p>
<p>接下来，我们将使<code>Clock</code>设置自己的定时器并每秒更新一次。</p>
<h2 id="Adding-Lifecycle-Methods-to-a-Class-将生命周期方法添加到类中"><a href="#Adding-Lifecycle-Methods-to-a-Class-将生命周期方法添加到类中" class="headerlink" title="Adding Lifecycle Methods to a Class(将生命周期方法添加到类中)"></a>Adding Lifecycle Methods to a Class(将生命周期方法添加到类中)</h2><p>In applications with many components, it’s very important to free up resources taken by the components when they are destroyed.</p>
<p>在具有许多组件的应用程序中，在销毁时释放组件所占用的资源非常重要。</p>
<p>We want to <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval" target="_blank" rel="noopener">set up a timer</a> whenever the <code>Clock</code> is rendered to the DOM for the first time. This is called “mounting” in React.</p>
<p>当<code>Clock</code>第一次渲染到DOM时，我们要设置一个定时器。 这在React中称为“挂载”。</p>
<p>We also want to <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval" target="_blank" rel="noopener">clear that timer</a> whenever the DOM produced by the <code>Clock</code> is removed. This is called “unmounting” in React.</p>
<p>当<code>Clock</code>产生的DOM被删除时，我们也想清除该计时器。 这在React中称为“卸载”。</p>
<p>We can declare special methods on the component class to run some code when a component mounts and unmounts:</p>
<p>当组件挂载和卸载时，我们可以在组件类上声明特殊的方法来运行一些代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;date: new Date()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>These methods are called “lifecycle hooks”.</p>
<p>这些方法称为“生命周期钩子函数”。</p>
<p>The <code>componentDidMount()</code> hook runs after the component output has been rendered to the DOM. This is a good place to set up a timer:</p>
<p>在组件输出已经渲染给DOM之后， <code>componentDidMount()</code> 钩子函数运行。 这是一个建立定时器的好地方：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  this.timerID = setInterval(</span><br><span class="line">    () =&gt; this.tick(),</span><br><span class="line">    1000</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note how we save the timer ID right on <code>this</code>.</p>
<p>注意我们如何在<code>this</code>上保存正确的计时器ID。</p>
<p>While <code>this.props</code> is set up by React itself and <code>this.state</code> has a special meaning, you are free to add additional fields to the class manually if you need to store something that is not used for the visual output.</p>
<p>虽<code>this.props</code>由React本身设置，而this.state具有特殊的含义，但如果需要存储未用于可视输出的内容，则可以手动向类中添加其他字段。</p>
<p>If you don’t use something in <code>render()</code>, it shouldn’t be in the state.</p>
<p>如果您不在 <code>render()</code>,中使用某些东西，则不应该处于该状态。</p>
<p>We will tear down the timer in the <code>componentWillUnmount()</code> lifecycle hook:</p>
<p>我们将在componentWillUnmount()生命周期钩子函数中终止计时器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  clearInterval(this.timerID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Finally, we will implement the <code>tick()</code> method that runs every second.</p>
<p>最后，我们将实现每秒运行的<code>tick()</code> 方法。</p>
<p>It will use <code>this.setState()</code> to schedule updates to the component local state:</p>
<p>它将使用<code>this.setState()</code> 来计划更新组件的本地状态：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Clock extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;date: new Date()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.timerID = setInterval(</span><br><span class="line">      () =&gt; this.tick(),</span><br><span class="line">      1000</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(this.timerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tick() &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      date: new Date()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/amqdNA?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Now the clock ticks every second.</p>
<p>现在时钟每秒钟滴答滴答的跑个不停。</p>
<p>Let’s quickly recap what’s going on and the order in which the methods are called:</p>
<p>让我们快速回顾一下发生了什么以及调用方法的顺序：</p>
<p>1) When <code>&lt;Clock /&gt;</code> is passed to <code>ReactDOM.render()</code>, React calls the constructor of the <code>Clock</code> component. Since <code>Clock</code> needs to display the current time, it initializes <code>this.state</code> with an object including the current time. We will later update this state.</p>
<p>1）当<code>&lt;Clock /&gt;</code>传递给<code>ReactDOM.render（）</code>时，React调用<code>Clock</code>组件的构造函数。 由于<code>Clock</code>需要显示当前时间，所以它将使用包含当前时间的对象来初始化<code>this.state</code>。 我们稍后会更新此状态。</p>
<p>2) React then calls the <code>Clock</code> component’s <code>render()</code> method. This is how React learns what should be displayed on the screen. React then updates the DOM to match the <code>Clock</code>‘s render output.</p>
<p>2）React然后调用<code>Clock</code>组件的<code>render（）</code>方法。 这时React知道如何在屏幕上显示内容。 然后，React更新DOM以匹配<code>Clock</code>的渲染输出。</p>
<p>3) When the <code>Clock</code> output is inserted in the DOM, React calls the <code>componentDidMount()</code> lifecycle hook. Inside it, the <code>Clock</code> component asks the browser to set up a timer to call <code>tick()</code> once a second.</p>
<p>3）当时钟输出插入到DOM中时，React调用<code>componentDidMount（）</code>生命周期钩子函数。 在其中，<code>Clock</code>组件要求浏览器设置一个定时器来每秒调用<code>tick（）</code>一次。</p>
<p>4) Every second the browser calls the <code>tick()</code> method. Inside it, the <code>Clock</code> component schedules a UI update by calling <code>setState()</code> with an object containing the current time. Thanks to the <code>setState()</code> call, React knows the state has changed, and calls <code>render()</code> method again to learn what should be on the screen. This time, <code>this.state.date</code> in the <code>render()</code> method will be different, and so the render output will include the updated time. React updates the DOM accordingly.</p>
<p>4）浏览器每秒钟调用<code>tick（）</code>方法。 在其中，<code>Clock</code>组件通过使用包含当前时间的对象调用<code>setState（）</code>来调动UI更新。 感谢<code>setState（</code>）调用，React知道状态已经改变，并再次调用<code>render（）</code>方法来了解屏幕上应该更新或渲染什么。 这一次，<code>render（）</code>方法中的<code>this.state.date</code>将不同，因此渲染输出将包含更新的时间。 React会相应地更新DOM。</p>
<p>5) If the <code>Clock</code> component is ever removed from the DOM, React calls the <code>componentWillUnmount()</code> lifecycle hook so the timer is stopped.</p>
<p>5）如果时钟组件从DOM中删除，则React会调用<code>componentWillUnmount（）</code>生命周期钩子函数，以使定时器停止。</p>
<h2 id="Using-State-Correctly（正确使用状态）"><a href="#Using-State-Correctly（正确使用状态）" class="headerlink" title="Using State Correctly（正确使用状态）"></a>Using State Correctly（正确使用状态）</h2><p>There are three things you should know about <code>setState()</code>.</p>
<p>你应该知道有关<code>setState（）</code>的三件事情。</p>
<h3 id="Do-Not-Modify-State-Directly-不要直接修改状态"><a href="#Do-Not-Modify-State-Directly-不要直接修改状态" class="headerlink" title="Do Not Modify State Directly(不要直接修改状态)"></a>Do Not Modify State Directly(不要直接修改状态)</h3><p>For example, this will not re-render a component:</p>
<p>例如，这不会重新渲染组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">'Hello'</span>;</span><br></pre></td></tr></table></figure>
<p>Instead, use <code>setState()</code>:</p>
<p>而是使用<code>setState（）</code>代替：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">comment</span>: <span class="string">'Hello'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>The only place where you can assign <code>this.state</code> is the constructor.</p>
<p>唯一可以分配<code>this.state</code>的地方是构造函数。</p>
<h3 id="State-Updates-May-Be-Asynchronous-状态更新可能是异步的"><a href="#State-Updates-May-Be-Asynchronous-状态更新可能是异步的" class="headerlink" title="State Updates May Be Asynchronous(状态更新可能是异步的)"></a>State Updates May Be Asynchronous(状态更新可能是异步的)</h3><p>React may batch multiple <code>setState()</code> calls into a single update for performance.</p>
<p>React可以将多个setState（）批量调用转化为单个更新以实现性能优化。</p>
<p>Because <code>this.props</code> and <code>this.state</code> may be updated asynchronously, you should not rely on their values for calculating the next state.</p>
<p>因为<code>this.props</code>和<code>this.state</code>可能会异步更新，所以您不应该依靠它们的值来计算下一个状态。</p>
<p>For example, this code may fail to update the counter:</p>
<p>例如，此代码可能无法更新计数器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>To fix it, use a second form of <code>setState()</code> that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:</p>
<p>要修复它，请使用第二个形式的接受函数而不是对象的<code>setState（）</code>。 该函数将接收先前的状态作为第一个参数，并且更新应用时的属性作为第二个参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>We used an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">arrow function</a> above, but it also works with regular functions:</p>
<p>我们使用了上面的箭头函数，但它也适用于常规函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="keyword">function</span>(<span class="params">prevState, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: prevState.counter + props.increment</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="State-Updates-are-Merged（状态更新即合并）"><a href="#State-Updates-are-Merged（状态更新即合并）" class="headerlink" title="State Updates are Merged（状态更新即合并）"></a>State Updates are Merged（状态更新即合并）</h3><p>When you call <code>setState()</code>, React merges the object you provide into the current state.</p>
<p>当您调用<code>setState()</code>时，React将您提供的对象合并到当前状态。</p>
<p>For example, your state may contain several independent variables:</p>
<p>例如，您的状态可能包含几个独立变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">constructor(props) &#123;</span><br><span class="line">  super(props);</span><br><span class="line">  this.state = &#123;</span><br><span class="line">    posts: [],</span><br><span class="line">    comments: []</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then you can update them independently with separate <code>setState()</code> calls:</p>
<p>然后可以使用单独的<code>setState（）</code>调用独立更新它们：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  fetchPosts().then(response =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      posts: response.posts</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fetchComments().then(response =&gt; &#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      comments: response.comments</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The merging is shallow, so <code>this.setState({comments})</code> leaves <code>this.state.posts</code> intact, but completely replaces <code>this.state.comments</code>.</p>
<p>合并很浅，所以<code>this.setState（{comments}）</code>与<code>this.state.posts</code>各自完整，但完全替代了<code>this.state.comments</code>。</p>
<h2 id="The-Data-Flows-Down（数据流）"><a href="#The-Data-Flows-Down（数据流）" class="headerlink" title="The Data Flows Down（数据流）"></a>The Data Flows Down（数据流）</h2><p>Neither parent nor child components can know if a certain component is stateful or stateless, and they shouldn’t care whether it is defined as a function or a class.</p>
<p>父组件和子组件都不能知道某个组件是有状态还是无状态，并且它们不应该关心它是否被定义为函数或类。</p>
<p>This is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it.</p>
<p>这就是为什么状态通常被称为局部调用或封装。 除了设置它自身之外，它不可访问其它的任何组件。</p>
<p>A component may choose to pass its state down as props to its child components:</p>
<p>组件可以选择将其状态作为属性传递给其子组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br></pre></td></tr></table></figure>
<p>This also works for user-defined components:</p>
<p>这也适用于用户自定义的组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormattedDate date=&#123;<span class="keyword">this</span>.state.date&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>The <code>FormattedDate</code> component would receive the <code>date</code> in its props and wouldn’t know whether it came from the <code>Clock</code>‘s state, from the <code>Clock</code>‘s props, or was typed by hand:</p>
<p><code>FormattedDate</code>组件将在其属性中收到<code>日期</code>，并且不知道它是来自<code>时钟</code>的状态，还是来自<code>时钟</code>的属性，还是手动输入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FormattedDate</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;props.date.toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/zKRqNB?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>This is commonly called a “top-down” or “unidirectional” data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components “below” them in the tree.</p>
<p>这通常被称为“自顶向下”或“单向”数据流。 任何状态始终由某个特定组件所有，并且从该状态导出的任何数据或UI只能影响树中“下方”的组件。</p>
<p>If you imagine a component tree as a waterfall of props, each component’s state is like an additional water source that joins it at an arbitrary point but also flows down.</p>
<p>如果你想象一个组件树作为属性的瀑布，每个组件的状态就像一个额外的水源，它连接在一个任意点，但也流下来。</p>
<p>To show that all components are truly isolated, we can create an <code>App</code> component that renders three <code>&lt;Clock&gt;</code>s:</p>
<p>为了表明所有组件都是真正隔离的，我们可以创建一个应用程序组件，呈现三个<code>&lt;Clock&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/vXdGmd?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Each <code>Clock</code> sets up its own timer and updates independently.</p>
<p>每个时钟设置自己的定时器并独自更新。</p>
<p>In React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa.</p>
<p>在React应用程序中，组件是有状态还是无状态被认为是可能随时间而变化的组件的实现细节。 可以在有状态组件中使用无状态组件，反之亦然。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/03/31/rqd-components-and-props/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/31/rqd-components-and-props/" itemprop="url">
                  Components and Props(组件和属性)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-31T11:11:11+08:00">
                2017-03-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/03/31/rqd-components-and-props/" class="leancloud_visitors" data-flag-title="Components and Props(组件和属性)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.</p>
<p>组件让您将UI拆分成独立的可重复使用的部分，并单独考虑重复每个部分。</p>
<p>Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.</p>
<p>在概念上，组件就像JavaScript函数。 他们接受任意输入（称为“属性”），并返回描述应该在屏幕上显示的React元素。</p>
<h2 id="Functional-and-Class-Components-功能函数和类组件"><a href="#Functional-and-Class-Components-功能函数和类组件" class="headerlink" title="Functional and Class Components(功能函数和类组件)"></a>Functional and Class Components(功能函数和类组件)</h2><p>The simplest way to define a component is to write a JavaScript function:</p>
<p>定义组件的最简单的方法是编写一个JavaScript函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function is a valid React component because it accepts a single “props” object argument with data and returns a React element. We call such components “functional” because they are literally JavaScript functions.</p>
<p>该函数是一个有效的React组件，因为它接受一个单一的“props”对象参数数据并返回一个React元素。 我们将这些组件称为“功能函数”，因为它们是字面上的<code>JavaScript</code>函数。</p>
<p>You can also use an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a> to define a component:</p>
<p>你也可以用一个ES6的类定义一个组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The above two components are equivalent from React’s point of view.</p>
<p>从React的角度来看，上面这两个组件实现的功能都是一样的。</p>
<p>Classes have some additional features that we will discuss in the <a href="/react/docs/state-and-lifecycle.html">next sections</a>. Until then, we will use functional components for their conciseness.</p>
<p>课程有一些额外的功能，我们将在下一节讨论。 在此之前，我们将使用功能组件来简化。</p>
<h2 id="Rendering-a-Component-渲染组件"><a href="#Rendering-a-Component-渲染组件" class="headerlink" title="Rendering a Component(渲染组件)"></a>Rendering a Component(渲染组件)</h2><p>Previously, we only encountered React elements that represent DOM tags:</p>
<p>以前，我们只遇到代表DOM标签的React元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure>
<p>However, elements can also represent user-defined components:</p>
<p>然而，元素也可以表示用户自定义的组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure>
<p>When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object “props”.</p>
<p>当React遇到一个表示用户自定义的组件作为元素时，它将JSX属性作为单个对象传递给该组件。 我们称这个对象为”props(属性)”。</p>
<p>For example, this code renders “Hello, Sara” on the page:</p>
<p>例如，该代码在页面上显示“Hello，Sara”：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/YGYmEG?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Let’s recap what happens in this example:</p>
<ol>
<li>We call <code>ReactDOM.render()</code> with the <code>&lt;Welcome name=&quot;Sara&quot; /&gt;</code> element.</li>
<li>React calls the <code>Welcome</code> component with <code>{name: &#39;Sara&#39;}</code> as the props.</li>
<li>Our <code>Welcome</code> component returns a <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code> element as the result.</li>
<li>React DOM efficiently updates the DOM to match <code>&lt;h1&gt;Hello, Sara&lt;/h1&gt;</code>.</li>
</ol>
<p>我们来回顾一下在这个例子中会发生什么：</p>
<p>1.我们使用<code>&lt;Welcome name =“Sara”/&gt;</code>元素作为<code>ReactDOM.render()</code>函数的参数。<br>2.React调用使用<code>{name：&#39;Sara&#39;}</code>作为<code>Welcome</code>组件的属性。<br>3.我们的 <code>Welcome</code> 组件返回一个<code>&lt;h1&gt; Hello，Sara &lt;/ h1&gt;</code>元素作为结果。<br>4.React DOM有效地更新DOM以匹配<code>&lt;h1&gt; Hello，Sara &lt;/ h1&gt;</code>元素的变化。</p>
<blockquote>
<p><strong>Caveat:</strong></p>
<p>Always start component names with a capital letter.</p>
<p>For example, <code>&lt;div /&gt;</code> represents a DOM tag, but <code>&lt;Welcome /&gt;</code> represents a component and requires <code>Welcome</code> to be in scope.</p>
<p>警告：</p>
<p>始终使用大写字母组件开始的名称。</p>
<p>例如，<code>&lt;div /&gt;</code>表示一个DOM标签，但<code>&lt;Welcome /&gt;</code>表示一个组件，并且要求<code>Welcome</code>在要求范围内。</p>
</blockquote>
<h2 id="Composing-Components-组成部分"><a href="#Composing-Components-组成部分" class="headerlink" title="Composing Components(组成部分)"></a>Composing Components(组成部分)</h2><p>Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.</p>
<p>组件可以在其输出中引用其他组件。 这使我们可以对任何级别的部分使用相同的组件抽象。 按钮，表单，对话框，屏幕：在React应用程序中，所有这些通常都表示为组件。</p>
<p>For example, we can create an <code>App</code> component that renders <code>Welcome</code> many times:</p>
<p>例如，我们可以创建一个可以多次呈现<code>Welcome</code> 的App组件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Welcome name=&quot;Sara&quot; /&gt;</span><br><span class="line">      &lt;Welcome name=&quot;Cahal&quot; /&gt;</span><br><span class="line">      &lt;Welcome name=&quot;Edite&quot; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App /&gt;,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/KgQKPr?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Typically, new React apps have a single <code>App</code> component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like <code>Button</code> and gradually work your way to the top of the view hierarchy.</p>
<p>通常，新的React应用程序的顶部有一个App组件。 但是，如果将React集成到现有应用程序中，则可以使用像Button这样的小组件从自下而上开始，并逐渐替换到视图层次结构的顶部。</p>
<blockquote>
<p><strong>Caveat:</strong></p>
<p>Components must return a single root element. This is why we added a <code>&lt;div&gt;</code> to contain all the <code>&lt;Welcome /&gt;</code> elements.</p>
<p>警告：</p>
<p>组件必须返回单个根元素。 这就是为什么我们添加了一个<code>&lt;div&gt;</code>标签来包含所有的<code>&lt;Welcome /&gt;</code>元素。</p>
</blockquote>
<h2 id="Extracting-Components-提取组件"><a href="#Extracting-Components-提取组件" class="headerlink" title="Extracting Components(提取组件)"></a>Extracting Components(提取组件)</h2><p>Don’t be afraid to split components into smaller components.</p>
<p>不要担心将组件拆分成更小的组件。</p>
<p>For example, consider this <code>Comment</code> component:</p>
<p>例如，考虑这个 <code>Comment</code> 组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">        &lt;img className=<span class="string">"Avatar"</span></span><br><span class="line">          src=&#123;props.author.avatarUrl&#125;</span><br><span class="line">          alt=&#123;props.author.name&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;div className=<span class="string">"UserInfo-name"</span>&gt;</span><br><span class="line">          &#123;props.author.name&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;formatDate(props.date)&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/VKQwEo?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>It accepts <code>author</code> (an object), <code>text</code> (a string), and <code>date</code> (a date) as props, and describes a comment on a social media website.</p>
<p>它接受作者（对象），文本（字符串）和日期（日期）作为属性，并在社交媒体网站上描述评论。</p>
<p>This component can be tricky to change because of all the nesting, and it is also hard to reuse individual parts of it. Let’s extract a few components from it.</p>
<p>由于所有的嵌套，这个组件可能很难改变，并且很难重用它的各个部分。 我们从中提取几个组件。</p>
<p>First, we will extract <code>Avatar</code>:</p>
<p>首先，我们将提取<code>Avatar</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Avatar(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;img className=&quot;Avatar&quot;</span><br><span class="line">      src=&#123;props.user.avatarUrl&#125;</span><br><span class="line">      alt=&#123;props.user.name&#125;</span><br><span class="line">    /&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>Avatar</code> doesn’t need to know that it is being rendered inside a <code>Comment</code>. This is why we have given its prop a more generic name: <code>user</code> rather than <code>author</code>.</p>
<p><code>Avatar</code>不需要知道它在<code>Comment</code>中被渲染。 这就是为什么我们给它的属性一个更通用的名称： <code>user</code> 而不是 <code>author</code>。</p>
<p>We recommend naming props from the component’s own point of view rather than the context in which it is being used.</p>
<p>我们建议从组件自己的角度来命名道具，而不是使用组件所处的环境。</p>
<p>We can now simplify <code>Comment</code> a tiny bit:</p>
<p>我们现在可以简化 <code>Comment</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Comment(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;Comment&quot;&gt;</span><br><span class="line">      &lt;div className=&quot;UserInfo&quot;&gt;</span><br><span class="line">        &lt;Avatar user=&#123;props.author&#125; /&gt;</span><br><span class="line">        &lt;div className=&quot;UserInfo-name&quot;&gt;</span><br><span class="line">          &#123;props.author.name&#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=&quot;Comment-text&quot;&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=&quot;Comment-date&quot;&gt;</span><br><span class="line">        &#123;formatDate(props.date)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Next, we will extract a <code>UserInfo</code> component that renders an <code>Avatar</code> next to user’s name:</p>
<p>接下来，我们将提取一个<code>UserInfo</code>组件，用于将<code>Avatar</code>显示在用户名旁边：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function UserInfo(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;UserInfo&quot;&gt;</span><br><span class="line">      &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class="line">      &lt;div className=&quot;UserInfo-name&quot;&gt;</span><br><span class="line">        &#123;props.user.name&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This lets us simplify <code>Comment</code> even further:</p>
<p>这让我们进一步简化 <code>Comment</code> ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Comment(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;Comment&quot;&gt;</span><br><span class="line">      &lt;UserInfo user=&#123;props.author&#125; /&gt;</span><br><span class="line">      &lt;div className=&quot;Comment-text&quot;&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">      &lt;div className=&quot;Comment-date&quot;&gt;</span><br><span class="line">        &#123;formatDate(props.date)&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/rrJNJY?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Extracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times (<code>Button</code>, <code>Panel</code>, <code>Avatar</code>), or is complex enough on its own (<code>App</code>, <code>FeedStory</code>, <code>Comment</code>), it is a good candidate to be a reusable component.</p>
<p>首先，提取组件可能看起来像繁琐的工作，但是在较大的应用程序中可以使用可重用组件的调色板。 一个很好的经验法则是，如果您的UI的一部分被使用了几次 (<code>Button</code>, <code>Panel</code>, <code>Avatar</code>)，或者页面足够复杂 (<code>App</code>, <code>FeedStory</code>, <code>Comment</code>)，那么这作为可重用组件的候选方案 。</p>
<h2 id="Props-are-Read-Only-属性只能被读取"><a href="#Props-are-Read-Only-属性只能被读取" class="headerlink" title="Props are Read-Only(属性只能被读取)"></a>Props are Read-Only(属性只能被读取)</h2><p>Whether you declare a component <a href="#functional-and-class-components">as a function or a class</a>, it must never modify its own props. Consider this <code>sum</code> function:</p>
<p>无论您将组件声明为函数还是类，都不能修改自己的属性。 考虑这个”求和”函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Such functions are called <a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">“pure”</a> because they do not attempt to change their inputs, and always return the same result for the same inputs.</p>
<p>这些功能被称为“纯函数”，因为它们不会尝试更改其输入的内容，并且总是为相同的输入返回相同的结果。</p>
<p>In contrast, this function is impure because it changes its own input:</p>
<p>相比之下，这个功能不是纯函数，因为它改变了自己的输入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params">account, amount</span>) </span>&#123;</span><br><span class="line">  account.total -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React is pretty flexible but it has a single strict rule:</p>
<p>React非常灵活，但它有一个严格的规则：</p>
<p><strong>All React components must act like pure functions with respect to their props.</strong></p>
<p><strong>所有React组件必须像纯函数的功能一样对<code>属性</code>进行使用。</strong></p>
<p>Of course, application UIs are dynamic and change over time. In the <a href="/react/docs/state-and-lifecycle.html">next section</a>, we will introduce a new concept of “state”. State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule.</p>
<p>当然，应用程序UI是动态的，随着时间的推移而改变。 在下一节中，我们将介绍一个<code>state(状态)</code>的新概念。 状态允许React组件根据用户操作，网络响应以及其他任何内容随时间更改其输出，而不会违反此规则。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/03/30/rqd-rendering-elements/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/30/rqd-rendering-elements/" itemprop="url">
                  Rendering Elements(渲染组件)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-30T11:11:11+08:00">
                2017-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/03/30/rqd-rendering-elements/" class="leancloud_visitors" data-flag-title="Rendering Elements(渲染组件)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Elements are the smallest building blocks of React apps.</p>
<p>元素是React应用程序中最小的构建块。</p>
<p>An element describes what you want to see on the screen:</p>
<p>一个元素描述您想要在屏幕上看到的内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;h1&gt;Hello, world&lt;/h1&gt;;</span><br></pre></td></tr></table></figure>
<p>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</p>
<p>与浏览器DOM元素不同，React元素是简单的对象，而且便于创建。 React DOM负责更新浏览器DOM，从而匹配React元素。</p>
<blockquote>
<p><strong>Note:</strong></p>
<p>One might confuse elements with a more widely known concept of “components”. We will introduce components in the <a href="/react/docs/components-and-props.html">next section</a>. Elements are what components are “made of”, and we encourage you to read this section before jumping ahead.</p>
<p>注意：</p>
<p>人们可能会将元素与更广为人知的“组件”概念相混淆。 我们将在下一节介绍组件。 元素是“由…组成”的组件，我们建议您在跳到下一节之前阅读本节。</p>
</blockquote>
<h2 id="Rendering-an-Element-into-the-DOM-将元素渲染到DOM中"><a href="#Rendering-an-Element-into-the-DOM-将元素渲染到DOM中" class="headerlink" title="Rendering an Element into the DOM(将元素渲染到DOM中)"></a>Rendering an Element into the DOM(将元素渲染到DOM中)</h2><p>Let’s say there is a <code>&lt;div&gt;</code> somewhere in your HTML file:</p>
<p>假设你的HTML文件中有一个<div>标签：</div></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>We call this a “root” DOM node because everything inside it will be managed by React DOM.</p>
<p>我们称之为“根”DOM节点，因为其中的所有内容都将由React DOM管理。</p>
<p>Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like.</p>
<p>使用React构建的应用程序通常具有单个根DOM节点。 如果您将React集成到现有应用程序中，则可能需要像您所需的一样多的孤立根DOM节点。</p>
<p>To render a React element into a root DOM node, pass both to <code>ReactDOM.render()</code>:</p>
<p>要将React元素渲染到根DOM节点中，请将它们都传递给<code>ReactDOM.render()</code>函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/rrpgNB?editors=1010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>It displays “Hello, world” on the page.</p>
<p>它在页面上显示“Hello，world”。</p>
<h2 id="Updating-the-Rendered-Element-更新渲染元素"><a href="#Updating-the-Rendered-Element-更新渲染元素" class="headerlink" title="Updating the Rendered Element(更新渲染元素)"></a>Updating the Rendered Element(更新渲染元素)</h2><p>React elements are <a href="https://en.wikipedia.org/wiki/Immutable_object" target="_blank" rel="noopener">immutable</a>. Once you create an element, you can’t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.</p>
<p>React元素是不可变的。 创建元素后，您无法更改其子项或属性。 一个元素就像一个电影中的一帧：它代表了某个时间点的画面。</p>
<p>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to <code>ReactDOM.render()</code>.</p>
<p>根据我们目前所学的知识，更新UI的唯一方法是创建一个新元素，并将其传递给<code>ReactDOM.render()</code>。</p>
<p>Consider this ticking clock example:</p>
<p>考虑这个滴答作响的时钟示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function tick() &#123;</span><br><span class="line">  const element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!&lt;/h1&gt;</span><br><span class="line">      &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    document.getElementById(&apos;root&apos;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, 1000);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/gwoJZk?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>It calls <code>ReactDOM.render()</code> every second from a <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval" target="_blank" rel="noopener"><code>setInterval()</code></a> callback.</p>
<p>它每秒从一个<code>setInterval()</code>回调函数中调用<code>ReactDOM.render()</code>。</p>
<blockquote>
<p><strong>Note:</strong></p>
<p>In practice, most React apps only call <code>ReactDOM.render()</code> once. In the next sections we will learn how such code gets encapsulated into <a href="/react/docs/state-and-lifecycle.html">stateful components</a>.</p>
<p>We recommend that you don’t skip topics because they build on each other.</p>
<p>注意：</p>
<p>实际上，大多数React应用只会调用<code>ReactDOM.render()</code>一次。 在接下来的章节中，我们将学习如何将这些代码封装到有状态的组件中。</p>
<p>我们建议您不要跳过主题，因为它们建立在彼此之间。</p>
</blockquote>
<h2 id="React-Only-Updates-What’s-Necessary-React仅更新必要更新的元素"><a href="#React-Only-Updates-What’s-Necessary-React仅更新必要更新的元素" class="headerlink" title="React Only Updates What’s Necessary(React仅更新必要更新的元素)"></a>React Only Updates What’s Necessary(React仅更新必要更新的元素)</h2><p>React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.</p>
<p>React DOM将元素及其子元素与上一个元素进行比较，并将所需更新的DOM更新到所需的状态。</p>
<p>You can verify by inspecting the <a href="http://codepen.io/gaearon/pen/gwoJZk?editors=0010" target="_blank" rel="noopener">last example</a> with the browser tools:</p>
<p>您可以使用浏览器工具检查最后一个示例来验证：</p>
<p><img src="https://facebook.github.io/react/img/docs/granular-dom-updates.gif" alt="DOM inspector showing granular updates"></p>
<p>Even though we create an element describing the whole UI tree on every tick, only the text node whose contents has changed gets updated by React DOM.</p>
<p>即使我们创建了一个描述整个UI树的元素，只有内容已经改变的文本节点才被React DOM更新。</p>
<p>In our experience, thinking about how the UI should look at any given moment rather than how to change it over time eliminates a whole class of bugs.</p>
<p>根据我们的经验，思考一下在特定时刻UI应该是什么样，而不是随着时间的推移去改变它以排除一系列漏洞。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/03/29/rqd-introducing-jsx/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/03/29/rqd-introducing-jsx/" itemprop="url">
                  Introducing JSX(JSX介绍)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-29T11:11:11+08:00">
                2017-03-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/03/29/rqd-introducing-jsx/" class="leancloud_visitors" data-flag-title="Introducing JSX(JSX介绍)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Consider this variable declaration:</p>
<p>考虑这个变量声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>This funny tag syntax is neither a string nor HTML.</p>
<p>这个有趣的标签语法既不是字符串也不是HTML。</p>
<p>It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.</p>
<p>它被称为JSX，它是JavaScript的语法扩展。 我们建议您使用React来描述UI的外观。 JSX可以说是提示您的一种模板语言，但它和JavaScript的一样强大。</p>
<p>JSX produces React “elements”. We will explore rendering them to the DOM in the <a href="/react/docs/rendering-elements.html">next section</a>. Below, you can find the basics of JSX necessary to get you started.</p>
<p>JSX创建React<code>元素</code>。 我们将在下一节中讲解如何将它们渲染到DOM。 下面你可以开始学习<code>JSX</code>的基础语法知识。</p>
<h3 id="Embedding-Expressions-in-JSX-在JSX中嵌入表达式"><a href="#Embedding-Expressions-in-JSX-在JSX中嵌入表达式" class="headerlink" title="Embedding Expressions in JSX(在JSX中嵌入表达式)"></a>Embedding Expressions in JSX(在JSX中嵌入表达式)</h3><p>You can embed any <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions" target="_blank" rel="noopener">JavaScript expression</a> in JSX by wrapping it in curly braces.</p>
<p>您可以在JSX中嵌入任何<code>JavaScript</code>表达式，方法是将其包装在<code>花括号{}</code>中。</p>
<p>For example, <code>2 + 2</code>, <code>user.firstName</code>, and <code>formatName(user)</code> are all valid expressions:</p>
<p>例如，<code>2 + 2</code>，<code>user.firstName</code>和<code>formatName（user）</code>都是有效的表达式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function formatName(user) &#123;</span><br><span class="line">  return user.firstName + &apos; &apos; + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const user = &#123;</span><br><span class="line">  firstName: &apos;Harper&apos;,</span><br><span class="line">  lastName: &apos;Perez&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const element = (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello, &#123;formatName(user)&#125;!</span><br><span class="line">  &lt;/h1&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/PGEjdG?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>We split JSX over multiple lines for readability. While it isn’t required, when doing this, we also recommend wrapping it in parentheses to avoid the pitfalls of <a href="http://stackoverflow.com/q/2846283" target="_blank" rel="noopener">automatic semicolon insertion</a>.</p>
<p>我们将JSX分成多行，以增强可读性。 虽然这不是必需的，但在这样做的时候，我们也建议把它放在括号中，以避免<a href="http://stackoverflow.com/q/2846283" target="_blank" rel="noopener">分号自动插入的错误</a>。</p>
<h3 id="JSX-is-an-Expression-Too-JSX是一个表达式"><a href="#JSX-is-an-Expression-Too-JSX是一个表达式" class="headerlink" title="JSX is an Expression Too(JSX是一个表达式)"></a>JSX is an Expression Too(JSX是一个表达式)</h3><p>After compilation, JSX expressions become regular JavaScript objects.</p>
<p>编译后，<code>JSX</code>表达式成为常规的<code>JavaScript</code>对象。</p>
<p>This means that you can use JSX inside of <code>if</code> statements and <code>for</code> loops, assign it to variables, accept it as arguments, and return it from functions:</p>
<p>这意味着您可以在<code>if</code>语句和<code>for</code>循环中使用<code>JSX</code>语法，将其分配给变量，或者接受它作为参数，也可以从函数返回它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function getGreeting(user) &#123;</span><br><span class="line">  if (user) &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Specifying-Attributes-with-JSX-JSX指定属性"><a href="#Specifying-Attributes-with-JSX-JSX指定属性" class="headerlink" title="Specifying Attributes with JSX(JSX指定属性)"></a>Specifying Attributes with JSX(JSX指定属性)</h3><p>You may use quotes to specify string literals as attributes:</p>
<p>您可以使用<code>引号</code>将字符串文字指定为属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>You may also use curly braces to embed a JavaScript expression in an attribute:</p>
<p>您还可以使用<code>花括号</code>将JavaScript表达式嵌入到属性中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>Don’t put quotes around curly braces when embedding a JavaScript expression in an attribute. Otherwise JSX will treat the attribute as a string literal rather than an expression. You should either use quotes (for string values) or curly braces (for expressions), but not both in the same attribute.</p>
<p>在属性中嵌入JavaScript表达式时，不要在大括号上放置引号。 否则，JSX将该属性视为字符串文字而不是表达式。 您应该使用引号（对于字符串值）或花括号（用于表达式），但不能同时使用。</p>
<h3 id="Specifying-Children-with-JSX-JSX指定子项"><a href="#Specifying-Children-with-JSX-JSX指定子项" class="headerlink" title="Specifying Children with JSX(JSX指定子项)"></a>Specifying Children with JSX(JSX指定子项)</h3><p>If a tag is empty, you may close it immediately with <code>/&gt;</code>, like XML:</p>
<p>如果是一个空标签，则可以使用<code>/&gt;</code>立即关闭它，如XML：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure>
<p>JSX tags may contain children:</p>
<p>JSX标签可能包含子项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &lt;h2&gt;Good to see you here.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Caveat:</strong></p>
<p>Since JSX is closer to JavaScript than HTML, React DOM uses <code>camelCase</code> property naming convention instead of HTML attribute names.</p>
<p>For example, <code>class</code> becomes <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/className" target="_blank" rel="noopener"><code>className</code></a> in JSX, and <code>tabindex</code> becomes <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex" target="_blank" rel="noopener"><code>tabIndex</code></a>.</p>
<p>警告：</p>
<p>由于JSX比HTML更接近JavaScript，所以React DOM使用<code>camelCase</code>(驼峰)属性命名约定而不是HTML属性名称。</p>
<p>例如，<code>class</code>在JSX中变为<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/className" target="_blank" rel="noopener"><code>className</code></a>，<code>tabindex</code>变为<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/tabIndex" target="_blank" rel="noopener"><code>tabIndex</code></a>。</p>
</blockquote>
<h3 id="JSX-Prevents-Injection-Attacks-JSX防止注入攻击"><a href="#JSX-Prevents-Injection-Attacks-JSX防止注入攻击" class="headerlink" title="JSX Prevents Injection Attacks(JSX防止注入攻击)"></a>JSX Prevents Injection Attacks(JSX防止注入攻击)</h3><p>It is safe to embed user input in JSX:</p>
<p>在JSX中嵌入用户输入是安全的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> title = response.potentiallyMaliciousInput;</span><br><span class="line"><span class="comment">// This is safe:</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>By default, React DOM <a href="http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html" target="_blank" rel="noopener">escapes</a> any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS (cross-site-scripting)</a> attacks.</p>
<p>默认情况下，React DOM会在渲染之前转义嵌入在JSX中的任何值。 因此，它确保永远不会注入任何未明确的内容到您的应用程序。 在渲染之前，所有内容都将转换为字符串。 这有助于防止XSS<a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">跨站点脚本</a>攻击。</p>
<h3 id="JSX-Represents-Objects-JSX表示对象"><a href="#JSX-Represents-Objects-JSX表示对象" class="headerlink" title="JSX Represents Objects(JSX表示对象)"></a>JSX Represents Objects(JSX表示对象)</h3><p>Babel compiles JSX down to <code>React.createElement()</code> calls.</p>
<p>Babel将JSX对象编译为传入<code>React.createElement()</code>函数的参数，并进行函数。</p>
<p>These two examples are identical:</p>
<p>这两个例子是一样的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">'greeting'</span>&#125;,</span><br><span class="line">  <span class="string">'Hello, world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>React.createElement()</code> performs a few checks to help you write bug-free code but essentially it creates an object like this:</p>
<p><code>React.createElement()</code>执行一些检查以帮助您编写无错误代码，但基本上它会创建一个如下所示的对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: this structure is simplified</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  type: <span class="string">'h1'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">'greeting'</span>,</span><br><span class="line">    children: <span class="string">'Hello, world'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>These objects are called “React elements”. You can think of them as descriptions of what you want to see on the screen. React reads these objects and uses them to construct the DOM and keep it up to date.</p>
<p>这些对象被称为<code>&quot;React元素&quot;</code>。 您可以将它们视为您想要在屏幕上看到的内容。 React读取这些对象，并使用它们构造DOM并更新到屏幕上。</p>
<p>We will explore rendering React elements to the DOM in the next section.</p>
<p>我们将在下一节中研究如何将React元素渲染到DOM中。</p>
<blockquote>
<p><strong>Tip:</strong></p>
<p>We recommend searching for a “Babel” syntax scheme for your editor of choice so that both ES6 and JSX code is properly highlighted.</p>
<p>提示：</p>
<p>我们建议您为选择的编辑器搜索“Babel”语法方案，以便ES6和JSX代码都被正确突出显示。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215"
               alt="William-Dream" />
          <p class="site-author-name" itemprop="name">William-Dream</p>
           
              <p class="site-description motion-element" itemprop="description">为了梦-追梦,我的英文名由此而来</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">83</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/li-jun-bo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.lijunbo.com/" title="Net" target="_blank">Net</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">William-Dream</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("PWTRJaGA9VmnmuJISstgYQVk-gzGzoHsz", "OhMVXOeW5jbdIohUayYbpq1v");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

</body>
</html>
