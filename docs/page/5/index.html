<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />




<script data-ad-client="ca-pub-7376123380604387" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>











  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="静水流深" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="为了梦-追梦,我的英文名由此而来">
<meta property="og:type" content="website">
<meta property="og:title" content="静水流深">
<meta property="og:url" content="http://blog.lijunbo.com/page/5/index.html">
<meta property="og:site_name" content="静水流深">
<meta property="og:description" content="为了梦-追梦,我的英文名由此而来">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="静水流深">
<meta name="twitter:description" content="为了梦-追梦,我的英文名由此而来">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.lijunbo.com/page/5/"/>





  <title> 静水流深 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4a874f383236eb548cfc14b4365008b8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">静水流深</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">非淡泊无以明志，非宁静无以致远</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocapitalize="off" autocomplete="off" autocorrect="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/06/01/tab-navigator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/01/tab-navigator/" itemprop="url">
                  标签导航器(TabNavigator)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-01T11:11:11+08:00">
                2017-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react-navigation/" itemprop="url" rel="index">
                    <span itemprop="name">react navigation</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/06/01/tab-navigator/" class="leancloud_visitors" data-flag-title="标签导航器(TabNavigator)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>用于通过TabRouter轻松设置带有多个选项卡的屏幕。有关实例，请参阅我们的展示Demo( <a href="https://exp.host/@react-navigation/NavigationPlayground" target="_blank" rel="noopener">our expo demo</a>)。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomeScreen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> navigationOptions = &#123;</span><br><span class="line">    tabBarLabel: <span class="string">'Home'</span>,</span><br><span class="line">    <span class="comment">// 注意：默认情况下，该图标仅在iOS上显示。搜索下面的showIcon选项.</span></span><br><span class="line">    tabBarIcon: <span class="function">(<span class="params">&#123; tintColor &#125;</span>) =&gt;</span> (</span><br><span class="line">      &lt;Image</span><br><span class="line">        source=&#123;<span class="built_in">require</span>(<span class="string">'./chats-icon.png'</span>)&#125;</span><br><span class="line">        style=&#123;[styles.icon, &#123;<span class="attr">tintColor</span>: tintColor&#125;]&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    ),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Button</span><br><span class="line">        onPress=&#123;() =&gt; <span class="keyword">this</span>.props.navigation.navigate(<span class="string">'Notifications'</span>)&#125;</span><br><span class="line">        title=<span class="string">"Go to notifications"</span></span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyNotificationsScreen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> navigationOptions = &#123;</span><br><span class="line">    tabBarLabel: <span class="string">'Notifications'</span>,</span><br><span class="line">    tabBarIcon: <span class="function">(<span class="params">&#123; tintColor &#125;</span>) =&gt;</span> (</span><br><span class="line">      &lt;Image</span><br><span class="line">        source=&#123;<span class="built_in">require</span>(<span class="string">'./notif-icon.png'</span>)&#125;</span><br><span class="line">        style=&#123;[styles.icon, &#123;<span class="attr">tintColor</span>: tintColor&#125;]&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    ),</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Button</span><br><span class="line">        onPress=&#123;() =&gt; <span class="keyword">this</span>.props.navigation.goBack()&#125;</span><br><span class="line">        title=<span class="string">"Go back home"</span></span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> styles = StyleSheet.create(&#123;</span><br><span class="line">  icon: &#123;</span><br><span class="line">    width: <span class="number">26</span>,</span><br><span class="line">    height: <span class="number">26</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyApp = TabNavigator(&#123;</span><br><span class="line">  Home: &#123;</span><br><span class="line">    screen: MyHomeScreen,</span><br><span class="line">  &#125;,</span><br><span class="line">  Notifications: &#123;</span><br><span class="line">    screen: MyNotificationsScreen,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  tabBarOptions: &#123;</span><br><span class="line">    activeTintColor: <span class="string">'#e91e63'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="API-定义"><a href="#API-定义" class="headerlink" title="API 定义"></a>API 定义</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TabNavigator(RouteConfigs, TabNavigatorConfig)</span><br></pre></td></tr></table></figure>
<h3 id="路由配置-RouteConfigs"><a href="#路由配置-RouteConfigs" class="headerlink" title="路由配置(RouteConfigs)"></a>路由配置(RouteConfigs)</h3><p>路由配置对象是从路由名称到路由配置的映射，它告诉导航器该路由的内容，请参阅<code>StackNavigator</code>中的示例。</p>
<h3 id="标签导航器配置-TabNavigatorConfig"><a href="#标签导航器配置-TabNavigatorConfig" class="headerlink" title="标签导航器配置(TabNavigatorConfig)"></a>标签导航器配置(TabNavigatorConfig)</h3><ul>
<li><code>tabBarComponent</code> - 用作标签栏的组件，例如。 <code>TabBarBottom</code>（这是iOS上的默认），<code>TabBarTop</code>（这是Android上的默认）</li>
<li><code>tabBarPosition</code> - 标签栏的位置可以是“top”或“bottom”</li>
<li><code>swipeEnabled</code> - 是否允许在标签之间进行滑动</li>
<li><code>animationEnabled</code> - 是否在切换标签时启动动画</li>
<li><code>lazy</code> - 是否根据需要懒加载标签，而不是提前渲染</li>
<li><code>tabBarOptions</code> - 配置标签栏，见下文。</li>
</ul>
<p>这几个选项被传递到底层路由器来修改导航逻辑：</p>
<ul>
<li><code>initialRouteName</code> - 第一次加载时初始标签路由的routeName</li>
<li><code>order</code> -定义标签卡顺序的routeNames数组</li>
<li><code>paths</code> - 提供routeName到路径配置的映射，该配置将覆盖routeConfigs中设置的路径.(不太明白)</li>
<li><code>backBehavior</code> - 按下后退按钮是否会使Tab键切换到初始选项卡？如果是，设置为<code>initialRoute</code>，否则为<code>none</code>。默认为<code>initialRoute</code>行为。</li>
</ul>
<h3 id="tabBarOptions-for-TabBarBottom-default-tab-bar-on-iOS"><a href="#tabBarOptions-for-TabBarBottom-default-tab-bar-on-iOS" class="headerlink" title="tabBarOptions for TabBarBottom (default tab bar on iOS)"></a><code>tabBarOptions</code> for <code>TabBarBottom</code> (default tab bar on iOS)</h3><p>使用<code>TabBarBottom</code>组件的标签栏选项(tabBarOptions)(在IOS上默认使用此组件)</p>
<ul>
<li><code>activeTintColor</code> -激活标签的标题和图标的颜色值</li>
<li><code>activeBackgroundColor</code> - 激活标签的标题和图标的背景颜色值</li>
<li><code>inactiveTintColor</code> - 非激活标签的标签和图标颜色</li>
<li><code>inactiveBackgroundColor</code> - 非激活标签的标签和图标的背景颜色值</li>
<li><code>showLabel</code> - 是否显示标签的标题，默认为true显示</li>
<li><code>style</code> - 标签栏的样式对象</li>
<li><code>labelStyle</code> - 标签标题样式对象</li>
<li><code>tabStyle</code> - 标签的样式对象</li>
</ul>
<p>示例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tabBarOptions: &#123;</span><br><span class="line">  activeTintColor: <span class="string">'#e91e63'</span>,</span><br><span class="line">  labelStyle: &#123;</span><br><span class="line">    fontSize: <span class="number">12</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  style: &#123;</span><br><span class="line">    backgroundColor: <span class="string">'blue'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="tabBarOptions-for-TabBarTop-default-tab-bar-on-Android"><a href="#tabBarOptions-for-TabBarTop-default-tab-bar-on-Android" class="headerlink" title="tabBarOptions for TabBarTop (default tab bar on Android)"></a><code>tabBarOptions</code> for <code>TabBarTop</code> (default tab bar on Android)</h3><p>使用<code>TabBarTop</code>组件的标签栏选项(tabBarOptions)(在Android上默认使用此组件)</p>
<ul>
<li><code>activeTintColor</code> -激活标签的标题和图标的颜色值</li>
<li><p><code>inactiveTintColor</code> - 非激活标签的标签和图标颜色</p>
</li>
<li><p><code>showIcon</code> - 是否显示标签的图标，默认为false不显示</p>
</li>
<li><code>showLabel</code> - 是否显示标签的标题，默认为true显示</li>
<li><code>upperCaseLabel</code> - 是否使标签大写，默认为true</li>
<li><code>pressColor</code> - 按压为材质波纹颜色值 (仅Android &gt;= 5.0)</li>
<li><code>pressOpacity</code> - 按压标签的不透明度 (iOS 和 仅Android &lt; 5.0)</li>
<li><code>scrollEnabled</code> - 是否启用可滚动选项卡</li>
<li><code>tabStyle</code> - 标签的样式对象</li>
<li><code>indicatorStyle</code> - 标签指示器的样式对象（选项卡底部的行）</li>
<li><code>labelStyle</code> - 标签标题的样式对象</li>
<li><code>iconStyle</code> - 标签图标的样式对象</li>
<li><code>style</code> - 标签栏的对象</li>
</ul>
<p>示例:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tabBarOptions: &#123;</span><br><span class="line">  labelStyle: &#123;</span><br><span class="line">    fontSize: <span class="number">12</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  style: &#123;</span><br><span class="line">    backgroundColor: <span class="string">'blue'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="屏幕导航选项-Screen-Navigation-Options"><a href="#屏幕导航选项-Screen-Navigation-Options" class="headerlink" title="屏幕导航选项(Screen Navigation Options)"></a>屏幕导航选项(Screen Navigation Options)</h3><h4 id="title"><a href="#title" class="headerlink" title="title"></a><code>title</code></h4><p>可用作<code>headerTitle</code>和<code>tabBarLabel</code>的回退的通用标题</p>
<h4 id="tabBarVisible"><a href="#tabBarVisible" class="headerlink" title="tabBarVisible"></a><code>tabBarVisible</code></h4><p>True或false显示或隐藏选项卡栏，如果未设置，则默认为true</p>
<h4 id="tabBarIcon"><a href="#tabBarIcon" class="headerlink" title="tabBarIcon"></a><code>tabBarIcon</code></h4><p>React元素(组件)或赋予{focused：boolean，tintColor：string}的一个函数返回一个React元素(组件)，以在tab栏中显示</p>
<h4 id="tabBarLabel"><a href="#tabBarLabel" class="headerlink" title="tabBarLabel"></a><code>tabBarLabel</code></h4><p>标签栏或React元素中显示的标签的标题字符串，或给定{focused：boolean，tintColor：string}的函数返回一个React元素(组件)，用以显示在选项卡栏中。未定义时，使用场景标题(<code>title</code>)。要隐藏，请参阅上一节中的<code>tabBarOptions.showLabel</code>。</p>
<h3 id="导航器属性-Navigator-Props"><a href="#导航器属性-Navigator-Props" class="headerlink" title="导航器属性(Navigator Props)"></a>导航器属性(Navigator Props)</h3><p>由<code>TabNavigator（...）</code>创建的导航器组件具有以下属性：</p>
<ul>
<li><code>screenProps</code> - 向子屏幕传递额外的选项和导航选项，例如：</li>
</ul>
 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TabNav = TabNavigator(&#123;</span><br><span class="line">  <span class="comment">// 配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;TabNav</span><br><span class="line">  screenProps=&#123;<span class="comment">/* 这个属性传递给子屏幕组件，在子屏幕组件中作为this.props.screenProps使用 */</span>&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/05/31/stack-navigator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/31/stack-navigator/" itemprop="url">
                  栈导航器(StackNavigator)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-31T11:11:11+08:00">
                2017-05-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react-navigation/" itemprop="url" rel="index">
                    <span itemprop="name">react navigation</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/05/31/stack-navigator/" class="leancloud_visitors" data-flag-title="栈导航器(StackNavigator)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为您的应用程序提供了一种在每个新屏幕放置在堆栈顶部的屏幕之间转换的方法。</p>
<p>默认情况下，<code>StackNavigator</code>配置为熟悉的iOS和Android设备外观：iOS上的新屏幕从右侧滑出，Android上的新屏幕从底部渐隐。在iOS上，<code>StackNavigator</code>也可以配置为模式风格，让屏幕从底部滑入。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHomeScreen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> navigationOptions = &#123;</span><br><span class="line">    title: <span class="string">'Home'</span>,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Button</span><br><span class="line">        onPress=&#123;() =&gt; <span class="keyword">this</span>.props.navigation.navigate(<span class="string">'Profile'</span>, &#123;<span class="attr">name</span>: <span class="string">'Lucy'</span>&#125;)&#125;</span><br><span class="line">        title=<span class="string">"Go to Lucy's profile"</span></span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ModalStack = StackNavigator(&#123;</span><br><span class="line">  Home: &#123;</span><br><span class="line">    screen: MyHomeScreen,</span><br><span class="line">  &#125;,</span><br><span class="line">  Profile: &#123;</span><br><span class="line">    path: <span class="string">'people/:name'</span>,</span><br><span class="line">    screen: MyProfileScreen,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="API-定义"><a href="#API-定义" class="headerlink" title="API 定义"></a>API 定义</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StackNavigator(RouteConfigs, StackNavigatorConfig)</span><br></pre></td></tr></table></figure>
<h3 id="路由配置-RouteConfigs"><a href="#路由配置-RouteConfigs" class="headerlink" title="路由配置(RouteConfigs)"></a>路由配置(RouteConfigs)</h3><p>路由配置对象是从路由名称到路由配置的映射，它告诉导航器该路由要呈现什么内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">StackNavigator(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以导航到每个屏幕，创建一个新的屏幕，如下所示：</span></span><br><span class="line">  Profile: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `ProfileScreen`是一个React组件，将作为屏幕的主要内容。</span></span><br><span class="line">    screen: ProfileScreen,</span><br><span class="line">    <span class="comment">// 当`ProfileScreen`由StackNavigator加载时，它将被赋予“navigation”属性。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选：在Web应用程序中深链接或使用react-navigation导航时，将使用此路径：</span></span><br><span class="line">    path: <span class="string">'people/:name'</span>,</span><br><span class="line">    <span class="comment">// 从路径中提取动作(action)和路由参数.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选：覆盖屏幕的`navigationOptions`（即每个组件中的`navigationOptions`）</span></span><br><span class="line">    navigationOptions: <span class="function">(<span class="params">&#123;navigation&#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">      title: <span class="string">`<span class="subst">$&#123;navigation.state.params.name&#125;</span>'s Profile'`</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  ...MyOtherRoutes,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="栈导航器配置-StackNavigatorConfig"><a href="#栈导航器配置-StackNavigatorConfig" class="headerlink" title="栈导航器配置(StackNavigatorConfig)"></a>栈导航器配置(StackNavigatorConfig)</h3><p>路由器选项:</p>
<ul>
<li><code>initialRouteName</code> - 为栈(stack)设置默认的界面，必须和路由配置(route configs)里面的一个key匹配。</li>
<li><code>initialRouteParams</code> - 初始路由的参数</li>
<li><code>navigationOptions</code> - 用于屏幕的默认导航选项</li>
<li><code>paths</code> - 在路由设置(RouteConfigs)里面设置映射路径的覆盖(不太明白)</li>
</ul>
<p>视觉选项:</p>
<ul>
<li><code>mode</code> - 定义渲染(rendering)和转换(transitions)的样式式,两种选项(给字符串即可)：<ul>
<li><code>card</code> - 使用标准的iOS和Android的界面切换，这是默认的。</li>
<li><code>modal</code> - 使屏幕从底部滑入，这是一种常见的iOS模式。只适用于iOS，对Android没有作用。</li>
</ul>
</li>
<li><code>headerMode</code> - 指定标题(Header)应该如何被渲染,选项：<ul>
<li><code>float</code> - 渲染一个保持在顶部的标题，并在屏幕更改时显示动画。这是iOS上的常见模式。(即共用一个header 意思就是有title文字渐变效果)</li>
<li><code>screen</code> - 每个屏幕都有一个标题，标题与屏幕一起淡入淡出。这是Android上的常见模式(各用各的header 意思就是没有title文字渐变效果)</li>
<li><code>none</code> - 不会显示标题(没有header)</li>
</ul>
</li>
<li><code>cardStyle</code> - 使用该属性继承或者重载一个在stack中的card的样式.</li>
<li><code>transitionConfig</code> - 定义一个返回覆盖默认屏幕的换场动画的对象的函数.</li>
<li><code>onTransitionStart</code> - 当Card换场动画即将开始时，调用此函数.</li>
<li><code>onTransitionEnd</code> - 当Card换场动画完成时，立即调用此函数.</li>
</ul>
<h3 id="屏幕导航选项-Screen-Navigation-Options"><a href="#屏幕导航选项-Screen-Navigation-Options" class="headerlink" title="屏幕导航选项(Screen Navigation Options)"></a>屏幕导航选项(Screen Navigation Options)</h3><h4 id="title"><a href="#title" class="headerlink" title="title"></a><code>title</code></h4><p>页面的标题：用作<code>headerTitle</code>和<code>tabBarLabel</code>的回退的字符串</p>
<h4 id="header"><a href="#header" class="headerlink" title="header"></a><code>header</code></h4><p>React元素(组件)或者一个赋予<code>HeaderProps</code>的函数返回的一个React元素(组件)，显示为一个标题栏。设置为null隐藏标题栏。</p>
<h4 id="headerTitle"><a href="#headerTitle" class="headerlink" title="headerTitle"></a><code>headerTitle</code></h4><p>标题使用的字符串或React元素(组件)。默认为场景值是标题(<code>title</code>)</p>
<h4 id="headerBackTitle"><a href="#headerBackTitle" class="headerlink" title="headerBackTitle"></a><code>headerBackTitle</code></h4><p>iOS上的后退按钮使用的标题字符串，或者为空,禁用标签。默认为场景值是标题(<code>title</code>)</p>
<h4 id="headerTruncatedBackTitle"><a href="#headerTruncatedBackTitle" class="headerlink" title="headerTruncatedBackTitle"></a><code>headerTruncatedBackTitle</code></h4><p>当<code>headerBackTitle</code>不适合屏幕时，返回按钮使用的标题字符串。默认情况下为”Back”。</p>
<h4 id="headerRight"><a href="#headerRight" class="headerlink" title="headerRight"></a><code>headerRight</code></h4><p>设置显示在标题栏的右侧的React元素(组件)</p>
<h4 id="headerLeft"><a href="#headerLeft" class="headerlink" title="headerLeft"></a><code>headerLeft</code></h4><p>设置显示在标题栏的左侧的React元素(组件)</p>
<h4 id="headerStyle"><a href="#headerStyle" class="headerlink" title="headerStyle"></a><code>headerStyle</code></h4><p>设置标题栏的样式对象</p>
<h4 id="headerTitleStyle"><a href="#headerTitleStyle" class="headerlink" title="headerTitleStyle"></a><code>headerTitleStyle</code></h4><p>设置标题(title)的样式对象</p>
<h4 id="headerBackTitleStyle"><a href="#headerBackTitleStyle" class="headerlink" title="headerBackTitleStyle"></a><code>headerBackTitleStyle</code></h4><p>设置返回标题(back title)的样式对象</p>
<h4 id="headerTintColor"><a href="#headerTintColor" class="headerlink" title="headerTintColor"></a><code>headerTintColor</code></h4><p>设置标题颜色</p>
<h4 id="headerPressColorAndroid"><a href="#headerPressColorAndroid" class="headerlink" title="headerPressColorAndroid"></a><code>headerPressColorAndroid</code></h4><p>设置按下时的材质波纹颜色 (仅Android &gt;= 5.0)</p>
<h4 id="gesturesEnabled"><a href="#gesturesEnabled" class="headerlink" title="gesturesEnabled"></a><code>gesturesEnabled</code></h4><p>是否可以使用手势关闭此屏幕。在iOS上默认为true，在Android上为false。</p>
<h3 id="导航器属性-Navigator-Props"><a href="#导航器属性-Navigator-Props" class="headerlink" title="导航器属性(Navigator Props)"></a>导航器属性(Navigator Props)</h3><p>由<code>StackNavigator（...）</code>创建的导航器组件具有以下属性：</p>
<ul>
<li><code>screenProps</code> - 向子屏幕传递额外的选项，例如：</li>
</ul>
 <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SomeStack = StackNavigator(&#123;</span><br><span class="line">  <span class="comment">// 配置</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&lt;SomeStack</span><br><span class="line">  screenProps=&#123;<span class="comment">/* 这个属性传递给子屏幕组件，在子屏幕组件中作为this.props.screenProps使用 */</span>&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="示例-Examples"><a href="#示例-Examples" class="headerlink" title="示例(Examples)"></a>示例(Examples)</h3><p>例子请参阅 <a href="https://github.com/react-community/react-navigation/tree/master/examples/NavigationPlayground/js/SimpleStack.js" target="_blank" rel="noopener">SimpleStack.js</a>和 <a href="https://github.com/react-community/react-navigation/tree/master/examples/NavigationPlayground/js/ModalStack.js" target="_blank" rel="noopener">ModalStack.js</a>，您可以在本地运行<a href="https://github.com/react-community/react-navigation/tree/master/examples/NavigationPlayground" target="_blank" rel="noopener">NavigationPlayground</a> 应用程序的一部分。</p>
<p>您可以通过访问我们的展示Demo( <a href="https://exp.host/@react-navigation/NavigationPlayground" target="_blank" rel="noopener">our expo demo</a>)直接在手机上查看这些示例。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/05/30/navigators/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/30/navigators/" itemprop="url">
                  导航器(Navigator)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-30T11:11:11+08:00">
                2017-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react-navigation/" itemprop="url" rel="index">
                    <span itemprop="name">react navigation</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/05/30/navigators/" class="leancloud_visitors" data-flag-title="导航器(Navigator)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>导航器允许您定义应用程序的导航结构。导航器还可以渲染你配置过的像标题栏和标签栏等常见元素。在该引擎下，导航器是简单的React组件。</p>
<h2 id="内置导航器"><a href="#内置导航器" class="headerlink" title="内置导航器"></a>内置导航器</h2><p><code>react-navigation</code> 包括以下功能来帮助您创建导航器：</p>
<ul>
<li><a href="/docs/navigators/stack">StackNavigator</a> - 一次呈现一个屏幕，并提供屏幕之间的转换。当新屏幕打开时，它被放置在堆栈的顶部。</li>
<li><a href="/docs/navigators/tab">TabNavigator</a> - 渲染一个标签栏，让用户在几个屏幕之间切换</li>
<li><a href="/docs/navigators/drawer">DrawerNavigator</a> - 提供从屏幕左(右)侧滑入的抽屉菜单</li>
</ul>
<h2 id="使用导航器渲染屏幕"><a href="#使用导航器渲染屏幕" class="headerlink" title="使用导航器渲染屏幕"></a>使用导航器渲染屏幕</h2><p>导航器渲染仅由React组件组成的应用程序屏幕。</p>
<p>要了解如何创建屏幕，请阅读：</p>
<ul>
<li>屏幕导航属性（<a href="/docs/navigators/navigation-prop">Screen <code>navigation</code> prop</a>允许屏幕分发导航动作(navigation actions)，如打开另一个屏幕</li>
<li>屏幕导航选项(<a href="/docs/navigators/navigation-options">Screen <code>navigationOptions</code></a>)可以通过导航器自定义如何显示屏幕内容（例如头部标题，标签标题）</li>
</ul>
<h3 id="在根组件上调用导航"><a href="#在根组件上调用导航" class="headerlink" title="在根组件上调用导航"></a>在根组件上调用导航</h3><p>如果您想要使用相同级别的Navigator，您可以声明它，您可以使用react的ref选项：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AppNavigator = StackNavigator(SomeAppRouteConfigs);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  someEvent() &#123;</span><br><span class="line">    <span class="comment">// call navigate for AppNavigator here:</span></span><br><span class="line">    <span class="keyword">this</span>.navigator &amp;&amp; <span class="keyword">this</span>.navigator.dispatch(&#123; <span class="attr">type</span>: <span class="string">'Navigate'</span>, routeName, params &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;AppNavigator ref=&#123;nav =&gt; &#123; <span class="keyword">this</span>.navigator = nav; &#125;&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，此解决方案只能在根导航器上使用。</p>
<h2 id="导航容器"><a href="#导航容器" class="headerlink" title="导航容器"></a>导航容器</h2><p>当导航属性丢失时，内置导航器可以自动表现为根导航器。该功能提供了一个透明的导航容器，这是顶级导航属性的来源。</p>
<p>当渲染其中一个导航器时，导航属性是可选的。当它丢失时，容器进入并管理其自己的导航状态。它还处理URL，外部链接和Android后退按钮集成。</p>
<p>为了方便起见，内置的导航器具有这种能力，因为幕后他们使用<code>createNavigationContainer</code>。通常，导航器需要导航属性才能起作用。</p>
<p>根导航器接受以下属性：</p>
<h3 id="onNavigationStateChange-prevState-newState-action"><a href="#onNavigationStateChange-prevState-newState-action" class="headerlink" title="onNavigationStateChange(prevState, newState, action)"></a><code>onNavigationStateChange(prevState, newState, action)</code></h3><p>每次由导航器管理的导航状态发生变化，该函数都会被调用。它接收到以前的状态，新的导航状态和发生状态变化的动作。默认情况下会将状态更改打印到控制台。</p>
<h3 id="uriPrefix"><a href="#uriPrefix" class="headerlink" title="uriPrefix"></a><code>uriPrefix</code></h3><p>应用程序可能会处理的URI的前缀。这将在处理深层链接( <a href="/docs/guides/linking">deep link</a> )以提取路径传递到路由器时使用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/05/29/guide-headers/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/29/guide-headers/" itemprop="url">
                  配置标题(Configuring the Header)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-29T11:11:11+08:00">
                2017-05-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react-navigation/" itemprop="url" rel="index">
                    <span itemprop="name">react navigation</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/05/29/guide-headers/" class="leancloud_visitors" data-flag-title="配置标题(Configuring the Header)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>标题仅适用于栈导航<code>StackNavigator</code>。</p>
<p>在前面的例子中，我们创建了一个<code>StackNavigator</code>来在我们的应用程序中显示几个屏幕。</p>
<p>导航到聊天屏幕时，我们可以通过将参数提供给导航函数来指定新路由的参数。在这种情况下，我们要在聊天屏幕上提供该人的姓名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.props.navigation.navigate(<span class="string">'Chat'</span>, &#123; <span class="attr">user</span>:  <span class="string">'Lucy'</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>用户 <code>user</code> 参数可以从聊天屏幕访问：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatScreen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; params &#125; = <span class="keyword">this</span>.props.navigation.state;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Text</span>&gt;</span>Chat with &#123;params.user&#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置标题"><a href="#设置标题" class="headerlink" title="设置标题"></a>设置标题</h3><p>接下来，标题可以使用屏幕参数配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatScreen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> navigationOptions = <span class="function">(<span class="params">&#123; navigation &#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">    title: <span class="string">`Chat with <span class="subst">$&#123;navigation.state.params.user&#125;</span>`</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Android</p>
<p><img src="https://reactnavigation.org/assets/examples/basic-header-android.png" alt="Android"></p>
<p>IOS</p>
<p><img src="https://reactnavigation.org/assets/examples/basic-header-iphone.png" alt="IOS"></p>
<h3 id="添加右侧按钮"><a href="#添加右侧按钮" class="headerlink" title="添加右侧按钮"></a>添加右侧按钮</h3><p>然后我们可以添加一个标题导航选项( <a href="/docs/navigators/navigation-options#Stack-Navigation-Options"><code>header</code> navigation option</a> )，它允许我们添加一个自定义的右侧按钮：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> navigationOptions = &#123;</span><br><span class="line">  headerRight: <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">title</span>=<span class="string">"Info"</span> /&gt;</span>,</span></span><br><span class="line"><span class="xml">  ...</span></span><br></pre></td></tr></table></figure>
<p>Android</p>
<p><img src="https://reactnavigation.org/assets/examples/header-button-android.png" alt="Android"></p>
<p>IOS</p>
<p><img src="https://reactnavigation.org/assets/examples/header-button-iphone.png" alt="IOS"></p>
<p>导航选项可以使用导航属性(<a href="/docs/navigators/navigation-prop">navigation prop</a>)定义。让我们根据路由传递过来的参数渲染一个不同的按钮，并设置按钮，同时当按下按钮时调用<code>navigation.setParams</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> navigationOptions = <span class="function">(<span class="params">&#123; navigation &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;state, setParams&#125; = navigation;</span><br><span class="line">  <span class="keyword">const</span> isInfo = state.params.mode === <span class="string">'info'</span>;</span><br><span class="line">  <span class="keyword">const</span> &#123;user&#125; = state.params;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    title: isInfo ? <span class="string">`<span class="subst">$&#123;user&#125;</span>'s Contact Info`</span> : <span class="string">`Chat with <span class="subst">$&#123;state.params.user&#125;</span>`</span>,</span><br><span class="line">    headerRight: (</span><br><span class="line">      &lt;Button</span><br><span class="line">        title=&#123;isInfo ? <span class="string">'Done'</span> : <span class="string">`<span class="subst">$&#123;user&#125;</span>'s info`</span>&#125;</span><br><span class="line">        onPress=&#123;() =&gt; setParams(&#123; <span class="attr">mode</span>: isInfo ? <span class="string">'none'</span> : <span class="string">'info'</span>&#125;)&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    ),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在，标题可以与屏幕路由/状态(screen route/state)进行交互：</p>
<p>Android</p>
<p><img src="https://reactnavigation.org/assets/examples/header-interaction-android.png" alt="Android"></p>
<p>IOS</p>
<p><img src="https://reactnavigation.org/assets/examples/header-interaction-iphone.png" alt="IOS"></p>
<p>要查看其余的标题选项，请参阅导航选项文档(<a href="/docs/navigators/navigation-options#Stack-Navigation-Options">navigation options document</a>).</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/05/28/guide-nested/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/28/guide-nested/" itemprop="url">
                  嵌套导航(Nesting Navigators)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-28T11:11:11+08:00">
                2017-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react-navigation/" itemprop="url" rel="index">
                    <span itemprop="name">react navigation</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/05/28/guide-nested/" class="leancloud_visitors" data-flag-title="嵌套导航(Nesting Navigators)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>通常在移动应用中组合各种形式的导航。 React Navigation中的路由器和导航器是可组合的，它允许您为应用程序定义一个复杂的导航结构。</p>
<p>对于我们的聊天应用程序，我们要在第一个屏幕上放置几个选项卡，查看最近的聊天和所有联系人。</p>
<h2 id="介绍标签导航-Introducing-Tab-Navigator"><a href="#介绍标签导航-Introducing-Tab-Navigator" class="headerlink" title="介绍标签导航(Introducing Tab Navigator)"></a>介绍标签导航(Introducing Tab Navigator)</h2><p>让我们在<code>App.js</code> 创建一个新的 <code>TabNavigator</code> 导航：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; TabNavigator &#125; <span class="keyword">from</span> <span class="string">"react-navigation"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecentChatsScreen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Text</span>&gt;</span>List of recent chats<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllContactsScreen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Text</span>&gt;</span>List of all contacts<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MainScreenNavigator = TabNavigator(&#123;</span><br><span class="line">  Recent: &#123; <span class="attr">screen</span>: RecentChatsScreen &#125;,</span><br><span class="line">  All: &#123; <span class="attr">screen</span>: AllContactsScreen &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果<code>MainScreenNavigator</code>被渲染为顶级导航器组件，它将如下所示：</p>
<p><img src="https://reactnavigation.org/assets/examples/simple-tabs-android.png" alt="Android"></p>
<p><img src="https://reactnavigation.org/assets/examples/simple-tabs-iphone.png" alt="IOS"></p>
<h2 id="在一个屏幕中嵌套一个导航器"><a href="#在一个屏幕中嵌套一个导航器" class="headerlink" title="在一个屏幕中嵌套一个导航器"></a>在一个屏幕中嵌套一个导航器</h2><p>我们希望这些选项卡在应用的第一个屏幕中可见，但是推入栈中的新屏幕应该覆盖当前选项卡屏幕。</p>
<p>让我们将我们的选项卡导航器作为我们在上一步中设置的顶级<code>StackNavigator</code>中的屏幕。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SimpleApp = StackNavigator(&#123;</span><br><span class="line">  Home: &#123; <span class="attr">screen</span>: MainScreenNavigator &#125;,</span><br><span class="line">  Chat: &#123; <span class="attr">screen</span>: ChatScreen &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>因为<code>MainScreenNavigator</code>被当做一整个屏幕，所以我们可以给它设置导航选项（ <code>navigationOptions</code>）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MainScreenNavigator.navigationOptions = &#123;</span><br><span class="line">  title: <span class="string">'My Chats'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们也可以在每个标签组件中添加一个按钮，链接到聊天组件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">  onPress=&#123;() =&gt; <span class="keyword">this</span>.props.navigation.navigate(<span class="string">'Chat'</span>, &#123; <span class="attr">user</span>: <span class="string">'Lucy'</span> &#125;)&#125;</span><br><span class="line">  title=<span class="string">"Chat with Lucy"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p>现在我们将一个导航器放在另一个导航器中，我们可以在导航器之间导航：</p>
<p><img src="https://reactnavigation.org/assets/examples/nested-android.png" alt="Android"></p>
<p><img src="https://reactnavigation.org/assets/examples/nested-iphone.png" alt="IOS"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/05/27/guide-intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/05/27/guide-intro/" itemprop="url">
                  你好移动导航(Hello Mobile Navigation)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-27T11:11:11+08:00">
                2017-05-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react-navigation/" itemprop="url" rel="index">
                    <span itemprop="name">react navigation</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/05/27/guide-intro/" class="leancloud_visitors" data-flag-title="你好移动导航(Hello Mobile Navigation)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们使用React Navigation为Android和iOS构建一个简单的聊天应用程序。</p>
<h2 id="设置与安装"><a href="#设置与安装" class="headerlink" title="设置与安装"></a>设置与安装</h2><p>首先，确保您都设置好了React Native的环境。接下来，创建一个新项目并添加 <code>react-navigation</code>:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个RN应用</span></span><br><span class="line">react-native init SimpleApp</span><br><span class="line"><span class="built_in">cd</span> SimpleApp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过npm包管理器安装最新版本的react-navigation</span></span><br><span class="line">npm install --save react-navigation</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行App</span></span><br><span class="line">react-native run-android <span class="comment"># or:</span></span><br><span class="line">react-native run-ios</span><br></pre></td></tr></table></figure>
<p>验证您是否可以成功查看在iOS或Android设备上运行的示例应用程序：</p>
<p>Android</p>
<p><img src="https://reactnavigation.org/assets/examples/bare-project-android.png" alt="Android"></p>
<p>IOS</p>
<p><img src="https://reactnavigation.org/assets/examples/bare-project-iphone.png" alt="IOS"></p>
<p>我们想在IOS和Android设备上分享同一套代码，所以，我们应该删除 <code>index.ios.js</code> 和 <code>index.android.js</code> 文件中的代码内容，同时，使用 <code>import &#39;./App&#39;;</code> 进行替换。</p>
<p>现在可以为我们的应用程序实现创建新文件， <code>App.js</code> 。</p>
<h2 id="介绍栈导航-Stack-Navigator"><a href="#介绍栈导航-Stack-Navigator" class="headerlink" title="介绍栈导航( Stack Navigator)"></a>介绍栈导航( Stack Navigator)</h2><p>对于我们的应用程序，我们想使用StackNavigator，因为我们需要一个概念上的“堆栈”导航，每个新屏幕都放在堆栈的顶部，并返回从堆栈顶部移除一个屏幕。我们从一个屏幕开始：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  AppRegistry,</span><br><span class="line">  Text,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; StackNavigator &#125; <span class="keyword">from</span> <span class="string">'react-navigation'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeScreen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> navigationOptions = &#123;</span><br><span class="line">    title: <span class="string">'Welcome'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Text</span>&gt;</span>Hello, Navigation!<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SimpleApp = StackNavigator(&#123;</span><br><span class="line">  Home: &#123; <span class="attr">screen</span>: HomeScreen &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(<span class="string">'SimpleApp'</span>, () =&gt; SimpleApp);</span><br></pre></td></tr></table></figure>
<p>屏幕的标题 <code>title</code> 可以在静态<code>navigationOptions</code>上进行配置，其中可以设置许多选项来配置导航器中的屏幕显示。</p>
<p>现在iPhone和Android应用都会出现相同的屏幕：</p>
<p>Android</p>
<p><img src="https://reactnavigation.org/assets/examples/first-screen-android.png" alt="Android"></p>
<p>IOS</p>
<p><img src="https://reactnavigation.org/assets/examples/first-screen-iphone.png" alt="IOS"></p>
<h2 id="添加一个新屏幕"><a href="#添加一个新屏幕" class="headerlink" title="添加一个新屏幕"></a>添加一个新屏幕</h2><p>在我们的 <code>App.js</code> 文件中, 添加一个叫 <code>ChatScreen</code> 新屏幕:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatScreen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> navigationOptions = &#123;</span><br><span class="line">    title: <span class="string">'Chat with Lucy'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &lt;Text&gt;Chat <span class="keyword">with</span> Lucy&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，我们在 <code>HomeScreen</code> 组件中添加一个按钮，并使用路由(<code>routeName</code>)<code>Chat</code> 链接到<code>ChatScreen</code> 组件上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeScreen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> navigationOptions = &#123;</span><br><span class="line">    title: <span class="string">'Welcome'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; navigate &#125; = <span class="keyword">this</span>.props.navigation;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &lt;Text&gt;Hello, Chat App!<span class="xml"><span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line">        &lt;Button</span><br><span class="line">          onPress=&#123;() =&gt; navigate(<span class="string">'Chat'</span>)&#125;</span><br><span class="line">          title=<span class="string">"Chat with Lucy"</span></span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>我们正在使用屏幕导航属性( <a href="/docs/navigators/navigation-prop">screen navigation prop</a> )中的导航功能跳转到<code>ChatScreen</code> 组件上。然后，我们将它添加到我们的栈导航组件<code>StackNavigator</code>中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SimpleApp = StackNavigator(&#123;</span><br><span class="line">  Home: &#123; <span class="attr">screen</span>: HomeScreen &#125;,</span><br><span class="line">  Chat: &#123; <span class="attr">screen</span>: ChatScreen &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>现在，你可以导航到你新创建的<code>ChatScreen</code>组件上，然后返回上一个<code>HomeScreen</code>组件。</p>
<p>Android</p>
<p><img src="https://reactnavigation.org/assets/examples/first-navigation-android.png" alt="Android"></p>
<p>IOS</p>
<p><img src="https://reactnavigation.org/assets/examples/first-navigation-iphone.png" alt="IOS"></p>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>将名称硬编码到<code>ChatScreen</code>中并不理想。如果我们可以动态地传递一个名称来代替，那将会更有用，所以让我们这样做。</p>
<p>除了在导航功能中指定目标组件<code>routeName</code>之外，还可以传递将放入新路由的参数。首先，我们将编辑我们的<code>HomeScreen</code>组件，将 <code>user</code> 参数传递到路由中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeScreen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> navigationOptions = &#123;</span><br><span class="line">    title: <span class="string">'Welcome'</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; navigate &#125; = <span class="keyword">this</span>.props.navigation;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &lt;Text&gt;Hello, Chat App!<span class="xml"><span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line">        &lt;Button</span><br><span class="line">          onPress=&#123;() =&gt; navigate(<span class="string">'Chat'</span>, &#123; <span class="attr">user</span>: <span class="string">'Lucy'</span> &#125;)&#125;</span><br><span class="line">          title=<span class="string">"Chat with Lucy"</span></span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>然后，我们可以编辑我们的<code>ChatScreen</code>组件，以显示通过路由传递的用户参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChatScreen</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 导航选项可以定义为屏幕props的函数：</span></span><br><span class="line">  <span class="keyword">static</span> navigationOptions = <span class="function">(<span class="params">&#123; navigation &#125;</span>) =&gt;</span> (&#123;</span><br><span class="line">    title: <span class="string">`Chat with <span class="subst">$&#123;navigation.state.params.user&#125;</span>`</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// 屏幕的当前路线被传递到`props.navigation.state`：</span></span><br><span class="line">    <span class="keyword">const</span> &#123; params &#125; = <span class="keyword">this</span>.props.navigation.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;View&gt;</span><br><span class="line">        &lt;Text&gt;Chat <span class="keyword">with</span> &#123;params.user&#125;&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，当您导航到聊天屏幕时能看到动态专递过来的名字。尝试在<code>HomeScreen</code>中更改用户参数，看看会发生什么！</p>
<p>Android</p>
<p><img src="https://reactnavigation.org/assets/examples/first-navigation-android.png" alt="Android"></p>
<p>IOS</p>
<p><img src="https://reactnavigation.org/assets/examples/first-navigation-iphone.png" alt="IOS"></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/04/12/rad-uncontrolled-components/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/12/rad-uncontrolled-components/" itemprop="url">
                  Uncontrolled Components(不受控组件)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-12T11:11:11+08:00">
                2017-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/12/rad-uncontrolled-components/" class="leancloud_visitors" data-flag-title="Uncontrolled Components(不受控组件)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>In most cases, we recommend using <a href="/react/docs/forms.html">controlled components</a> to implement forms. In a controlled component, form data is handled by a React component. The alternative is uncontrolled components, where form data is handled by the DOM itself.</p>
<p>在大多数情况下，我们建议使用受控组件来实现表单。 在受控组件中，表单数据由React组件处理。 替代方案是不受控制的组件，其中表单数据由DOM本身处理。</p>
<p>To write an uncontrolled component, instead of writing an event handler for every state update, you can <a href="/react/docs/refs-and-the-dom.html">use a ref</a> to get form values from the DOM.</p>
<p>要编写一个不受控组件，而不是为每个状态更新编写事件处理程序，您可以使用<code>ref</code>从DOM获取表单值。</p>
<p>For example, this code accepts a single name in an uncontrolled component:</p>
<p>例如，此代码在不受控的组件中接受单个名称：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class NameForm extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&apos;A name was submitted: &apos; + this.input.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          Name:</span><br><span class="line">          &lt;input type=&quot;text&quot; ref=&#123;(input) =&gt; this.input = input&#125; /&gt;</span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://codepen.io/gaearon/pen/WooRWa?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Since an uncontrolled component keeps the source of truth in the DOM, it is sometimes easier to integrate React and non-React code when using uncontrolled components. It can also be slightly less code if you want to be quick and dirty. Otherwise, you should usually use controlled components.</p>
<p>由于不受控组件在DOM中保留了真实的来源，因此在使用不受控制的组件时集成React和Non-React代码有时更为容易。 虽然它也可以稍微减少代码量，但你会快速污染代码环境。 否则，您应该通常使用受控组件。</p>
<p>If it’s still not clear which type of component you should use for a particular situation, you might find <a href="http://goshakkk.name/controlled-vs-uncontrolled-inputs-react/" target="_blank" rel="noopener">this article on controlled versus uncontrolled inputs</a> to be helpful.</p>
<p>如果仍然不清楚您应该为特定情况使用哪种类型的组件，那么您可能会发现<a href="http://goshakkk.name/controlled-vs-uncontrolled-inputs-react/" target="_blank" rel="noopener">这篇关于受控制和不受控制的输入的文章</a> 是有帮助的。</p>
<h3 id="Default-Values-默认值"><a href="#Default-Values-默认值" class="headerlink" title="Default Values(默认值)"></a>Default Values(默认值)</h3><p>In the React rendering lifecycle, the <code>value</code> attribute on form elements will override the value in the DOM. With an uncontrolled component, you often want React to specify the initial value, but leave subsequent updates uncontrolled. To handle this case, you can specify a <code>defaultValue</code> attribute instead of <code>value</code>.</p>
<p>在React渲染生命周期中，form元素上的<code>value</code>属性将覆盖DOM中的值。 使用不受控制的组件，您通常希望React指定初始值，但不再控制后续更新。 要处理这种情况，可以指定一个<code>defaultValue</code>属性而不是<code>value</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">      &lt;label&gt;</span><br><span class="line">        Name:</span><br><span class="line">        &lt;input</span><br><span class="line">          defaultValue=&quot;Bob&quot;</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          ref=&#123;(input) =&gt; this.input = input&#125; /&gt;</span><br><span class="line">      &lt;/label&gt;</span><br><span class="line">      &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Likewise, <code>&lt;input type=&quot;checkbox&quot;&gt;</code> and <code>&lt;input type=&quot;radio&quot;&gt;</code> support <code>defaultChecked</code>, and <code>&lt;select&gt;</code> and <code>&lt;textarea&gt;</code> supports <code>defaultValue</code>.</p>
<p>同样，<code>&lt;input type =&quot;checkbox&quot;&gt;</code>和<code>&lt;input type =&quot;radio&quot;&gt;</code>支持<code>defaultChecked</code>，而<code>&lt;select&gt;</code>和<code>&lt;textarea&gt;</code>支持<code>defaultValue</code>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/04/11/rad-refs-and-the-dom/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/11/rad-refs-and-the-dom/" itemprop="url">
                  Refs and the DOM(DOM节点的引用)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-11T11:11:11+08:00">
                2017-04-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/11/rad-refs-and-the-dom/" class="leancloud_visitors" data-flag-title="Refs and the DOM(DOM节点的引用)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>In the typical React dataflow, <a href="/react/docs/components-and-props.html">props</a> are the only way that parent components interact with their children. To modify a child, you re-render it with new props. However, there are a few cases where you need to imperatively modify a child outside of the typical dataflow. The child to be modified could be an instance of a React component, or it could be a DOM element. For both of these cases, React provides an escape hatch.</p>
<p>在典型的React数据流中， <a href="">props</a>是父组件与子组件互动的唯一方法。 要修改子组件，请用新的props重新渲染。 但是，有几种情况需要在典型数据流之外强制修改子组件。 要修改的子组件可以是React组件的一个实例，也可以是一个DOM元素。 对于这两种情况，React提供了一个逃生舱口。</p>
<h3 id="When-to-Use-Refs-何时使用Refs引用"><a href="#When-to-Use-Refs-何时使用Refs引用" class="headerlink" title="When to Use Refs (何时使用Refs引用)"></a>When to Use Refs (何时使用Refs引用)</h3><p>There are a few good use cases for refs:</p>
<p>在这里有一些关于Refs很好的用例</p>
<ul>
<li>Managing focus, text selection, or media playback.</li>
<li>管理焦点，文本选择或媒体播放。</li>
<li>Triggering imperative animations.</li>
<li>触发强制性动画。</li>
<li>Integrating with third-party DOM libraries.</li>
<li>与第三方DOM库集成。</li>
</ul>
<p>Avoid using refs for anything that can be done declaratively.</p>
<p>避免使用refs声明性地做任何事情。</p>
<p>For example, instead of exposing <code>open()</code> and <code>close()</code> methods on a <code>Dialog</code> component, pass an <code>isOpen</code> prop to it.</p>
<p>例如，不要在Dialog组件上暴露<code>open（）</code>和<code>close（）</code>方法，而是将一个<code>isOpen</code>属性传递给它。</p>
<h3 id="Adding-a-Ref-to-a-DOM-Element-添加Ref引用到DOM元素"><a href="#Adding-a-Ref-to-a-DOM-Element-添加Ref引用到DOM元素" class="headerlink" title="Adding a Ref to a DOM Element (添加Ref引用到DOM元素)"></a>Adding a Ref to a DOM Element (添加Ref引用到DOM元素)</h3><p>React supports a special attribute that you can attach to any component. The <code>ref</code> attribute takes a callback function, and the callback will be executed immediately after the component is mounted or unmounted.</p>
<p>React支持一个可以附加到任何组件的特殊属性。 <code>ref</code>属性采用回调函数，并且在组件被装载或卸载之后立即执行回调。</p>
<p>When the <code>ref</code> attribute is used on an HTML element, the <code>ref</code> callback receives the underlying DOM element as its argument. For example, this code uses the <code>ref</code> callback to store a reference to a DOM node:</p>
<p>当在HTML元素上使用<code>ref</code>属性时，<code>ref</code>回调接收底层的DOM元素作为其参数。 例如，此代码使用引用回调来存储对DOM节点的引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.focus = this.focus.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  focus() &#123;</span><br><span class="line">    // Explicitly focus the text input using the raw DOM API</span><br><span class="line">    // 使用原始DOM API明确地将文本输入聚焦</span><br><span class="line">    this.textInput.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // Use the `ref` callback to store a reference to the text input DOM</span><br><span class="line">    // element in an instance field (for example, this.textInput).</span><br><span class="line">    // 使用`ref`回调来存储对文本输入DOM的引用</span><br><span class="line">    // 实例字段中的元素（例如this.textInput）</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;text&quot;</span><br><span class="line">          ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt;</span><br><span class="line">        &lt;input</span><br><span class="line">          type=&quot;button&quot;</span><br><span class="line">          value=&quot;Focus the text input&quot;</span><br><span class="line">          onClick=&#123;this.focus&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React will call the <code>ref</code> callback with the DOM element when the component mounts, and call it with <code>null</code> when it unmounts.</p>
<p>当组件挂载时，React将使用DOM元素调用<code>ref</code>回调，并在卸载时将其调用为<code>null</code>。</p>
<p>Using the <code>ref</code> callback just to set a property on the class is a common pattern for accessing DOM elements. The preferred way is to set the property in the <code>ref</code> callback like in the above example. There is even a shorter way to write it: <code>ref={input =&gt; this.textInput = input}</code>. </p>
<p>使用<code>ref</code>回调只是为了在类上设置属性，这是访问DOM元素的常见模式。 首选的方法是在<code>ref</code>回调中设置属性，就像上面的例子一样。 甚至有一个较短的写法：<code>ref = {input =&gt; this.textInput = input}</code>。</p>
<h3 id="Adding-a-Ref-to-a-Class-Component-添加Ref引用到类组件"><a href="#Adding-a-Ref-to-a-Class-Component-添加Ref引用到类组件" class="headerlink" title="Adding a Ref to a Class Component (添加Ref引用到类组件)"></a>Adding a Ref to a Class Component (添加Ref引用到类组件)</h3><p>When the <code>ref</code> attribute is used on a custom component declared as a class, the <code>ref</code> callback receives the mounted instance of the component as its argument. For example, if we wanted to wrap the <code>CustomTextInput</code> above to simulate it being clicked immediately after mounting:</p>
<p>当在声明为类的自定义组件中使用<code>ref</code>属性时，<code>ref</code>回调接收组件的已挂载实例作为其参数。 例如，如果我们想要包装上面的<code>CustomTextInput</code>来模拟它在安装后立即被点击：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class AutoFocusTextInput extends React.Component &#123;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    this.textInput.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;CustomTextInput</span><br><span class="line">        ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that this only works if <code>CustomTextInput</code> is declared as a class:</p>
<p>请注意，这仅在<code>CustomTextInput</code>被声明为类时才有效：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class CustomTextInput extends React.Component &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Refs-and-Functional-Components-Refs引用和功能组件"><a href="#Refs-and-Functional-Components-Refs引用和功能组件" class="headerlink" title="Refs and Functional Components (Refs引用和功能组件)"></a>Refs and Functional Components (Refs引用和功能组件)</h3><p><strong>You may not use the <code>ref</code> attribute on functional components</strong> because they don’t have instances:</p>
<p><strong>您不能在功能组件上使用<code>ref</code>属性</strong>，因为它们没有实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function MyFunctionalComponent() &#123;</span><br><span class="line">  return &lt;input /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Parent extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    // This will *not* work!</span><br><span class="line">    // 这样是 不能 运行的</span><br><span class="line">    return (</span><br><span class="line">      &lt;MyFunctionalComponent</span><br><span class="line">        ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You should convert the component to a class if you need a ref to it, just like you do when you need lifecycle methods or state.</p>
<p>如果需要Ref去引用它，您应该将组件转换为类，就像在需要生命周期方法或状态时一样。</p>
<p>You can, however, <strong>use the <code>ref</code> attribute inside a functional component</strong> as long as you refer to a DOM element or a class component:</p>
<p>但是，只要您引用DOM元素或类组件，您可以使用功能组件中的<code>ref</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function CustomTextInput(props) &#123;</span><br><span class="line">  // textInput must be declared here so the ref callback can refer to it</span><br><span class="line">  // textInput必须在这里声明，所以ref回调可以引用它</span><br><span class="line">  let textInput = null;</span><br><span class="line"></span><br><span class="line">  function handleClick() &#123;</span><br><span class="line">    textInput.focus();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&quot;text&quot;</span><br><span class="line">        ref=&#123;(input) =&gt; &#123; textInput = input; &#125;&#125; /&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type=&quot;button&quot;</span><br><span class="line">        value=&quot;Focus the text input&quot;</span><br><span class="line">        onClick=&#123;handleClick&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Don’t-Overuse-Refs-不要过度使用Refs引用"><a href="#Don’t-Overuse-Refs-不要过度使用Refs引用" class="headerlink" title="Don’t Overuse Refs (不要过度使用Refs引用)"></a>Don’t Overuse Refs (不要过度使用Refs引用)</h3><p>Your first inclination may be to use refs to “make things happen” in your app. If this is the case, take a moment and think more critically about where state should be owned in the component hierarchy. Often, it becomes clear that the proper place to “own” that state is at a higher level in the hierarchy. See the <a href="/react/docs/lifting-state-up.html">Lifting State Up</a> guide for examples of this.</p>
<p>您的第一个倾向可能是在应用程序中使用Refs引用“使事情发生”。 如果是这种情况，请花一点时间，更多地关注组件层次结构中的状态应该如何拥有。 通常，很明显，“拥有”该状态的适当位置在层次结构中处于较高级别。 有关示例，请参阅<a href="">提升状态向导</a>”。</p>
<h3 id="Legacy-API-String-Refs-旧版API：字符串引用参考"><a href="#Legacy-API-String-Refs-旧版API：字符串引用参考" class="headerlink" title="Legacy API: String Refs (旧版API：字符串引用参考)"></a>Legacy API: String Refs (旧版API：字符串引用参考)</h3><p>If you worked with React before, you might be familiar with an older API where the <code>ref</code> attribute is a string, like <code>&quot;textInput&quot;</code>, and the DOM node is accessed as <code>this.refs.textInput</code>. We advise against it because string refs have <a href="https://github.com/facebook/react/pull/8333#issuecomment-271648615" target="_blank" rel="noopener">some issues</a>, are considered legacy, and <strong>are likely to be removed in one of the future releases</strong>. If you’re currently using <code>this.refs.textInput</code> to access refs, we recommend the callback pattern instead.</p>
<p>如果您之前使用过React，您可能会熟悉一个旧的API，其中<code>ref</code>属性是一个字符串，如<code>“textInput”</code>，DOM节点作为<code>this.refs.textInput</code>进行访问。 我们建议反对这样使用它，因为字符串引用有一些问题，被认为是遗留的Bug，并且可能会在以后的版本中被删除。 如果您正在使用<code>this.refs.textInput</code>访问引用，则建议使用回调模式。</p>
<h3 id="Caveats-警告"><a href="#Caveats-警告" class="headerlink" title="Caveats (警告)"></a>Caveats (警告)</h3><p>If the <code>ref</code> callback is defined as an inline function, it will get called twice during updates, first with <code>null</code> and then again with the DOM element. This is because a new instance of the function is created with each render, so React needs to clear the old ref and set up the new one. You can avoid this by defining the <code>ref</code> callback as a bound method on the class, but note that it shouldn’t matter in most cases.</p>
<p>如果<code>ref</code>回调被定义为内联函数，则在更新期间将被调用两次，首先为<code>null</code>，然后再次使用DOM元素。 这是因为每次渲染都创建了一个新的函数实例，所以React需要清除旧的引用并设置新的引用。 您可以通过将<code>ref</code>回调定义为类的绑定方法来避免这种情况，但请注意，在大多数情况下，这并不重要。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/04/10/rad-jsx-in-depth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/10/rad-jsx-in-depth/" itemprop="url">
                  JSX In Depth(深入JSX)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-10T11:11:11+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/10/rad-jsx-in-depth/" class="leancloud_visitors" data-flag-title="JSX In Depth(深入JSX)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Fundamentally, JSX just provides syntactic sugar for the <code>React.createElement(component, props, ...children)</code> function. The JSX code:</p>
<p>基本上，JSX只是为 <code>React.createElement(component, props, ...children)</code> 函数提供语法糖。 JSX代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyButton color=<span class="string">"blue"</span> shadowSize=&#123;<span class="number">2</span>&#125;&gt;</span><br><span class="line">  Click Me</span><br><span class="line">&lt;<span class="regexp">/MyButton&gt;</span></span><br></pre></td></tr></table></figure>
<p>compiles into:</p>
<p>编译成:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  MyButton,</span><br><span class="line">  &#123;<span class="attr">color</span>: <span class="string">'blue'</span>, <span class="attr">shadowSize</span>: <span class="number">2</span>&#125;,</span><br><span class="line">  <span class="string">'Click Me'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>You can also use the self-closing form of the tag if there are no children. So:</p>
<p>如果没有子标签或子组件，也可以使用标签的自封闭形式。 所以：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">"sidebar"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>compiles into:</p>
<p>编译成:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">React.createElement(</span><br><span class="line">  <span class="string">'div'</span>,</span><br><span class="line">  &#123;<span class="attr">className</span>: <span class="string">'sidebar'</span>&#125;,</span><br><span class="line">  <span class="literal">null</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>If you want to test out how some specific JSX is converted into JavaScript, you can try out <a href="https://babeljs.io/repl/#?babili=false&amp;evaluate=true&amp;lineWrap=false&amp;presets=es2015%2Creact%2Cstage-0&amp;code=function%20hello(" target="_blank" rel="noopener">the online Babel compiler</a>%20%7B%0A%20%20return%20%3Cdiv%3EHello%20world!%3C%2Fdiv%3E%3B%0A%7D).</p>
<p>如果您想测试JSX如何转换为JavaScript，您可以使用在线Babel编译器进行尝试。</p>
<h2 id="Specifying-The-React-Element-Type-指定React元素类型"><a href="#Specifying-The-React-Element-Type-指定React元素类型" class="headerlink" title="Specifying The React Element Type(指定React元素类型)"></a>Specifying The React Element Type(指定React元素类型)</h2><p>The first part of a JSX tag determines the type of the React element.</p>
<p>JSX标签的第一部分决定了React元素的类型。</p>
<p>Capitalized types indicate that the JSX tag is referring to a React component. These tags get compiled into a direct reference to the named variable, so if you use the JSX <code>&lt;Foo /&gt;</code> expression, <code>Foo</code> must be in scope.</p>
<p>大写类型表示的JSX标签指的是React组件。 这些标签被编译成对命名变量的直接引用，所以如果使用JSX <code>&lt;Foo /&gt;</code>表达式，<code>Foo</code>必须在范围内。</p>
<h3 id="React-Must-Be-in-Scope-React必须在范围内"><a href="#React-Must-Be-in-Scope-React必须在范围内" class="headerlink" title="React Must Be in Scope(React必须在范围内)"></a>React Must Be in Scope(React必须在范围内)</h3><p>Since JSX compiles into calls to <code>React.createElement</code>, the <code>React</code> library must also always be in scope from your JSX code.</p>
<p>由于JSX编译成对<code>React.createElement</code>的调用，所以<code>React</code>库也必须始终在JSX代码的范围内。</p>
<p>For example, both of the imports are necessary in this code, even though <code>React</code> and <code>CustomButton</code> are not directly referenced from JavaScript:</p>
<p>例如，即使<code>React</code>和<code>CustomButton</code>不直接从JavaScript引用，这两个导入都是必需的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import CustomButton from &apos;./CustomButton&apos;;</span><br><span class="line"></span><br><span class="line">function WarningButton() &#123;</span><br><span class="line">  // return React.createElement(CustomButton, &#123;color: &apos;red&apos;&#125;, null);</span><br><span class="line">  return &lt;CustomButton color=&quot;red&quot; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you don’t use a JavaScript bundler and added React as a script tag, it is already in scope as a <code>React</code> global.</p>
<p>如果您不使用JavaScript绑定器并将React添加为脚本标记，则它已作为<code>React</code>全局的范围。</p>
<h3 id="Using-Dot-Notation-for-JSX-Type-对JSX类型使用点表示法"><a href="#Using-Dot-Notation-for-JSX-Type-对JSX类型使用点表示法" class="headerlink" title="Using Dot Notation for JSX Type(对JSX类型使用点表示法)"></a>Using Dot Notation for JSX Type(对JSX类型使用点表示法)</h3><p>You can also refer to a React component using dot-notation from within JSX. This is convenient if you have a single module that exports many React components. For example, if <code>MyComponents.DatePicker</code> is a component, you can use it directly from JSX with:</p>
<p>您还可以使用JSX中的<code>点表示法</code>引用React组件。 如果您有一个导出许多React组件的单个模块，这很方便。 例如，如果<code>MyComponents.DatePicker</code>是一个组件，则可以直接从JSX中使用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">const MyComponents = &#123;</span><br><span class="line">  DatePicker: function DatePicker(props) &#123;</span><br><span class="line">    return &lt;div&gt;Imagine a &#123;props.color&#125; datepicker here.&lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function BlueDatePicker() &#123;</span><br><span class="line">  return &lt;MyComponents.DatePicker color=&quot;blue&quot; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="User-Defined-Components-Must-Be-Capitalized-用户定义的组件必须大写"><a href="#User-Defined-Components-Must-Be-Capitalized-用户定义的组件必须大写" class="headerlink" title="User-Defined Components Must Be Capitalized(用户定义的组件必须大写)"></a>User-Defined Components Must Be Capitalized(用户定义的组件必须大写)</h3><p>When an element type starts with a lowercase letter, it refers to a built-in component like <code>&lt;div&gt;</code> or <code>&lt;span&gt;</code> and results in a string <code>&#39;div&#39;</code> or <code>&#39;span&#39;</code> passed to <code>React.createElement</code>. Types that start with a capital letter like <code>&lt;Foo /&gt;</code> compile to <code>React.createElement(Foo)</code> and correspond to a component defined or imported in your JavaScript file.</p>
<p>当元素类型以小写字母开头时，它引用一个内置的组件，如<code>&lt;div&gt;</code>或<code>&lt;span&gt;</code>，并将一个字符串’div’或’span’传递给<code>React.createElement</code>。 以大写字母开头的类型，如<code>&lt;Foo /&gt;</code>编译为<code>React.createElement(Foo)</code>，并对应于您的JavaScript文件中定义或导入的组件。</p>
<p>We recommend naming components with a capital letter. If you do have a component that starts with a lowercase letter, assign it to a capitalized variable before using it in JSX.</p>
<p>我们建议用大写字母命名组件。 如果您的组件以小写字母开头，请在JSX中使用之前将其分配给大写的变量。</p>
<p>For example, this code will not run as expected:</p>
<p>例如，此代码将无法按预期运行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">// Wrong! This is a component and should have been capitalized:</span><br><span class="line">// 错误！ 这是一个组件，应该被大写：</span><br><span class="line">function hello(props) &#123;</span><br><span class="line">  // Correct! This use of &lt;div&gt; is legitimate because div is a valid HTML tag:</span><br><span class="line">  // 正确！ 这种使用&lt;div&gt;是合法的，因为div是一个有效的HTML标记：</span><br><span class="line">  return &lt;div&gt;Hello &#123;props.toWhat&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function HelloWorld() &#123;</span><br><span class="line">  // Wrong! React thinks &lt;hello /&gt; is an HTML tag because it&apos;s not capitalized:</span><br><span class="line">  // 错了！ React认为&lt;hello /&gt;是一个HTML标签，因为它不大写：</span><br><span class="line">  return &lt;hello toWhat=&quot;World&quot; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To fix this, we will rename <code>hello</code> to <code>Hello</code> and use <code>&lt;Hello /&gt;</code> when referring to it:</p>
<p>要解决这个问题，我们将重命名<code>hello</code>为<code>Hello</code>，并在引用它时使用<code>&lt;Hello /&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">// Correct! This is a component and should be capitalized:</span><br><span class="line">// 正确！ 这是一个组件，应该被大写：</span><br><span class="line">function Hello(props) &#123;</span><br><span class="line">  // Correct! This use of &lt;div&gt; is legitimate because div is a valid HTML tag:</span><br><span class="line">  // 正确！ 这种使用&lt;div&gt;是合法的，因为div是一个有效的HTML标记：</span><br><span class="line">  return &lt;div&gt;Hello &#123;props.toWhat&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function HelloWorld() &#123;</span><br><span class="line">  // Correct! React knows &lt;Hello /&gt; is a component because it&apos;s capitalized.</span><br><span class="line">  // 正确！ React知道&lt;Hello /&gt;是一个组件，因为它是大写的。</span><br><span class="line">  return &lt;Hello toWhat=&quot;World&quot; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Choosing-the-Type-at-Runtime-在运行时选择类型"><a href="#Choosing-the-Type-at-Runtime-在运行时选择类型" class="headerlink" title="Choosing the Type at Runtime(在运行时选择类型)"></a>Choosing the Type at Runtime(在运行时选择类型)</h3><p>You cannot use a general expression as the React element type. If you do want to use a general expression to indicate the type of the element, just assign it to a capitalized variable first. This often comes up when you want to render a different component based on a prop:</p>
<p>您不能使用通用表达式作为React元素类型。 如果您想使用通用表达式来表示元素的类型，请先将其分配给大写的变量。 当您要根据属性渲染不同的组件时，会出现这种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; PhotoStory, VideoStory &#125; from &apos;./stories&apos;;</span><br><span class="line"></span><br><span class="line">const components = &#123;</span><br><span class="line">  photo: PhotoStory,</span><br><span class="line">  video: VideoStory</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Story(props) &#123;</span><br><span class="line">  // Wrong! JSX type can&apos;t be an expression.</span><br><span class="line">  // 错了！ JSX类型不能是表达式。</span><br><span class="line">  return &lt;components[props.storyType] story=&#123;props.story&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To fix this, we will assign the type to a capitalized variable first:</p>
<p>要解决这个问题，我们将首先将类型分配给大写的变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React from &apos;react&apos;;</span><br><span class="line">import &#123; PhotoStory, VideoStory &#125; from &apos;./stories&apos;;</span><br><span class="line"></span><br><span class="line">const components = &#123;</span><br><span class="line">  photo: PhotoStory,</span><br><span class="line">  video: VideoStory</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Story(props) &#123;</span><br><span class="line">  // Correct! JSX type can be a capitalized variable.</span><br><span class="line">  // 正确！ JSX类型可以是大写的变量。</span><br><span class="line">  const SpecificStory = components[props.storyType];</span><br><span class="line">  return &lt;SpecificStory story=&#123;props.story&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Props-in-JSX-JSX属性"><a href="#Props-in-JSX-JSX属性" class="headerlink" title="Props in JSX(JSX属性)"></a>Props in JSX(JSX属性)</h2><p>There are several different ways to specify props in JSX.</p>
<p>在JSX中有几种不同的方式来指定属性。</p>
<h3 id="JavaScript-Expressions-JavaScript表达式"><a href="#JavaScript-Expressions-JavaScript表达式" class="headerlink" title="JavaScript Expressions(JavaScript表达式)"></a>JavaScript Expressions(JavaScript表达式)</h3><p>You can pass any JavaScript expression as a prop, by surrounding it with <code>{}</code>. For example, in this JSX:</p>
<p>您可以传递任何JavaScript表达式作为属性，通过使用<code>{}</code>围绕它。 例如，在这个JSX中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent foo=&#123;<span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>For <code>MyComponent</code>, the value of <code>props.foo</code> will be <code>10</code> because the expression <code>1 + 2 + 3 + 4</code> gets evaluated.</p>
<p>对于<code>MyComponent</code>，因为表达式<code>1 + 2 + 3 + 4</code>会被计算，所以<code>props.foo</code>的值将为<code>10</code>。</p>
<p><code>if</code> statements and <code>for</code> loops are not expressions in JavaScript, so they can’t be used in JSX directly. Instead, you can put these in the surrounding code. For example:</p>
<p><code>if</code>语句和<code>for</code>循环在JavaScript中不是表达式，所以它们不能直接在JSX中使用。 相反，您可以将它们放在周围的代码中。 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function NumberDescriber(props) &#123;</span><br><span class="line">  let description;</span><br><span class="line">  if (props.number % 2 == 0) &#123;</span><br><span class="line">    description = &lt;strong&gt;even&lt;/strong&gt;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    description = &lt;i&gt;odd&lt;/i&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;div&gt;&#123;props.number&#125; is an &#123;description&#125; number&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="String-Literals-字符串文字"><a href="#String-Literals-字符串文字" class="headerlink" title="String Literals(字符串文字)"></a>String Literals(字符串文字)</h3><p>You can pass a string literal as a prop. These two JSX expressions are equivalent:</p>
<p>你可以传递字符串文字作为属性。 这两个JSX表达式是等价的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent message=<span class="string">"hello world"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent message=&#123;<span class="string">'hello world'</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>When you pass a string literal, its value is HTML-unescaped. So these two JSX expressions are equivalent:</p>
<p>当您传递字符串文字时，其值为HTML未转义。 所以这两个JSX表达式是等价的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent message=<span class="string">"&amp;lt;3"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyComponent message=&#123;<span class="string">'&lt;3'</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>This behavior is usually not relevant. It’s only mentioned here for completeness.</p>
<p>这种行为通常是不相关的。 这里只提到完整性。</p>
<h3 id="Props-Default-to-“True”-属性默认为“True”"><a href="#Props-Default-to-“True”-属性默认为“True”" class="headerlink" title="Props Default to “True”(属性默认为“True”)"></a>Props Default to “True”(属性默认为“True”)</h3><p>If you pass no value for a prop, it defaults to <code>true</code>. These two JSX expressions are equivalent:</p>
<p>如果你没有传递一个属性的值，它默认为<code>true</code>。 这两个JSX表达式是等价的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyTextBox autocomplete /&gt;</span><br><span class="line"></span><br><span class="line">&lt;MyTextBox autocomplete=&#123;<span class="literal">true</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>In general, we don’t recommend using this because it can be confused with the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Object_initializer#New_notations_in_ECMAScript_2015" target="_blank" rel="noopener">ES6 object shorthand</a> <code>{foo}</code> which is short for <code>{foo: foo}</code> rather than <code>{foo: true}</code>. This behavior is just there so that it matches the behavior of HTML.</p>
<p>一般来说，我们不建议使用它，因为它可能与<code>{foo：foo}</code>而不是<code>{foo：true}</code>的缩写为{foo}的ES6对象简写{foo}混淆。 这种行为就在这里，因此它符合HTML的行为。</p>
<h3 id="Spread-Attributes-传递属性"><a href="#Spread-Attributes-传递属性" class="headerlink" title="Spread Attributes(传递属性)"></a>Spread Attributes(传递属性)</h3><p>If you already have <code>props</code> as an object, and you want to pass it in JSX, you can use <code>...</code> as a “spread” operator to pass the whole props object. These two components are equivalent:</p>
<p>如果您已经拥有 <code>props</code> 作为对象，并且想要在JSX中传递，则可以使用<code>...</code>作为“扩展”运算符来传递整个 <code>props</code> 对象。 这两个组件是等效的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function App1() &#123;</span><br><span class="line">  return &lt;Greeting firstName=&quot;Ben&quot; lastName=&quot;Hector&quot; /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function App2() &#123;</span><br><span class="line">  const props = &#123;firstName: &apos;Ben&apos;, lastName: &apos;Hector&apos;&#125;;</span><br><span class="line">  return &lt;Greeting &#123;...props&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spread attributes can be useful when you are building generic containers. However, they can also make your code messy by making it easy to pass a lot of irrelevant props to components that don’t care about them. We recommend that you use this syntax sparingly.</p>
<p>构建通用容器组件时，扩展属性可能很有用。 然而，他们也可以通过将很多不相关的属性传递给不关心它们的组件来使您的代码变得凌乱。 我们建议您谨慎使用此语法。</p>
<h2 id="Children-in-JSX-JSX中的孩子"><a href="#Children-in-JSX-JSX中的孩子" class="headerlink" title="Children in JSX(JSX中的孩子)"></a>Children in JSX(JSX中的孩子)</h2><p>In JSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special prop: <code>props.children</code>. There are several different ways to pass children:</p>
<p>在包含开始标签和结束标签的JSX表达式中，这些标签之间的内容作为特殊的属性(<code>props.children</code>)进行传递。 有几种不同的方法来传递子组件：</p>
<h3 id="String-Literals-字符串文字-1"><a href="#String-Literals-字符串文字-1" class="headerlink" title="String Literals(字符串文字)"></a>String Literals(字符串文字)</h3><p>You can put a string between the opening and closing tags and <code>props.children</code> will just be that string. This is useful for many of the built-in HTML elements. For example:</p>
<p>您可以在开始和结束标签之间放置一个字符串，而<code>props.children</code>将只是该字符串。 这对于许多内置的HTML元素很有用。 例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent&gt;Hello world!<span class="xml"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>This is valid JSX, and <code>props.children</code> in <code>MyComponent</code> will simply be the string <code>&quot;Hello world!&quot;</code>. HTML is unescaped, so you can generally write JSX just like you would write HTML in this way:</p>
<p>这是有效的JSX，而组件中的<code>props.children</code>将只是字符串<code>“Hello world！</code>”。 HTML可以是未转义的，所以你一般可以写JSX，就像你用这种方式写HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>This is valid HTML &amp;amp; JSX at the same time.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JSX removes whitespace at the beginning and ending of a line. It also removes blank lines. New lines adjacent to tags are removed; new lines that occur in the middle of string literals are condensed into a single space. So these all render to the same thing:</p>
<p>JSX在行的开始和结尾处移除空格。 它也删除空行。 删除与标签相邻的新行; 出现在字符串文字中间的新行被压缩成一个空格。 所以这些渲染都是相同的事情：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;Hello World&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;div&gt;</span></span><br><span class="line"><span class="regexp">  Hello World</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;</span><br><span class="line">  Hello</span><br><span class="line">  World</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  Hello World</span></span><br><span class="line"><span class="regexp">&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>
<h3 id="JSX-Children-JSX子组件"><a href="#JSX-Children-JSX子组件" class="headerlink" title="JSX Children(JSX子组件)"></a>JSX Children(JSX子组件)</h3><p>You can provide more JSX elements as the children. This is useful for displaying nested components:</p>
<p>您可以提供更多的JSX元素作为子组件。 这对于显示嵌套组件很有用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyContainer&gt;</span><br><span class="line">  &lt;MyFirstComponent /&gt;</span><br><span class="line">  &lt;MySecondComponent /&gt;</span><br><span class="line">&lt;<span class="regexp">/MyContainer&gt;</span></span><br></pre></td></tr></table></figure>
<p>You can mix together different types of children, so you can use string literals together with JSX children. This is another way in which JSX is like HTML, so that this is both valid JSX and valid HTML:</p>
<p>你可以混合不同类型的子组件，所以你可以和JSX子组件一起使用字符串文字。 这是JSX的另一种方式，就像HTML一样，JSX和HTML都是有效的：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  Here is a list:</span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>A React component can’t return multiple React elements, but a single JSX expression can have multiple children, so if you want a component to render multiple things you can wrap it in a <code>div</code> like this.</p>
<p>一个React组件不能返回多个React元素，但单个JSX表达式可以有多个子元素，因此，如果您想要一个组件来呈现多个元素，则可以将其包装在这样的<code>div</code>中。</p>
<h3 id="JavaScript-Expressions-JavaScript表达式-1"><a href="#JavaScript-Expressions-JavaScript表达式-1" class="headerlink" title="JavaScript Expressions(JavaScript表达式)"></a>JavaScript Expressions(JavaScript表达式)</h3><p>You can pass any JavaScript expression as children, by enclosing it within <code>{}</code>. For example, these expressions are equivalent:</p>
<p>您可以将任何JavaScript表达式作为孩子传递，并将其包含在<code>{}</code>中。 例如，这些表达式是等价的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;MyComponent&gt;foo&lt;<span class="regexp">/MyComponent&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;MyComponent&gt;&#123;'foo'&#125;&lt;/</span>MyComponent&gt;</span><br></pre></td></tr></table></figure>
<p>This is often useful for rendering a list of JSX expressions of arbitrary length. For example, this renders an HTML list:</p>
<p>这对于呈现任意长度的JSX表达式的列表通常很有用。 例如，这将呈现HTML列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Item(props) &#123;</span><br><span class="line">  return &lt;li&gt;&#123;props.message&#125;&lt;/li&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function TodoList() &#123;</span><br><span class="line">  const todos = [&apos;finish doc&apos;, &apos;submit pr&apos;, &apos;nag dan to review&apos;];</span><br><span class="line">  return (</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &#123;todos.map((message) =&gt; &lt;Item key=&#123;message&#125; message=&#123;message&#125; /&gt;)&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript expressions can be mixed with other types of children. This is often useful in lieu of string templates:</p>
<p>JavaScript表达式可以与其他类型的孩子(这里指字符串)混合使用。 这通常用于代替字符串模板：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Hello(props) &#123;</span><br><span class="line">  return &lt;div&gt;Hello &#123;props.addressee&#125;!&lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Functions-as-Children-函数作为孩子"><a href="#Functions-as-Children-函数作为孩子" class="headerlink" title="Functions as Children(函数作为孩子)"></a>Functions as Children(函数作为孩子)</h3><p>Normally, JavaScript expressions inserted in JSX will evaluate to a string, a React element, or a list of those things. However, <code>props.children</code> works just like any other prop in that it can pass any sort of data, not just the sorts that React knows how to render. For example, if you have a custom component, you could have it take a callback as <code>props.children</code>:</p>
<p>通常，插入JSX中的JavaScript表达式将被转换字符串，React元素或这些内容的列表。 然而，<code>props.children</code>就像任何其他的属性一样工作，因为它可以传递任何数据，而不仅仅是React知道如何呈现的种类。 例如，如果您有自定义组件，则可以将其作为<code>props.children</code>进行回调：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Calls the children callback numTimes to produce a repeated component</span><br><span class="line">// 调用子回调 numtimes 以产生一个重复的组件</span><br><span class="line">function Repeat(props) &#123;</span><br><span class="line">  let items = [];</span><br><span class="line">  for (let i = 0; i &lt; props.numTimes; i++) &#123;</span><br><span class="line">    items.push(props.children(i));</span><br><span class="line">  &#125;</span><br><span class="line">  return &lt;div&gt;&#123;items&#125;&lt;/div&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ListOfTenThings() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;Repeat numTimes=&#123;10&#125;&gt;</span><br><span class="line">      &#123;(index) =&gt; &lt;div key=&#123;index&#125;&gt;This is item &#123;index&#125; in the list&lt;/div&gt;&#125;</span><br><span class="line">    &lt;/Repeat&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Children passed to a custom component can be anything, as long as that component transforms them into something React can understand before rendering. This usage is not common, but it works if you want to stretch what JSX is capable of.</p>
<p>传递给自定义组件的孩子可以是任何东西，只要该组件将它们转换为React在呈现之前可以理解的东西。 这个用法并不常见，但是如果你想扩展JSX的功能，这样也是可以工作的。</p>
<h3 id="Booleans-Null-and-Undefined-Are-Ignored-布尔值，空值和未定义被忽略"><a href="#Booleans-Null-and-Undefined-Are-Ignored-布尔值，空值和未定义被忽略" class="headerlink" title="Booleans, Null, and Undefined Are Ignored(布尔值，空值和未定义被忽略)"></a>Booleans, Null, and Undefined Are Ignored(布尔值，空值和未定义被忽略)</h3><p><code>false</code>, <code>null</code>, <code>undefined</code>, and <code>true</code> are valid children. They simply don’t render. These JSX expressions will all render to the same thing:</p>
<p><code>false</code>, <code>null</code>, <code>undefined</code>, 和<code>true</code>是有效的孩子。 他们根本不渲染。 这些JSX表达式将全部呈现为相同的东西：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div /&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;<span class="literal">false</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;div&gt;&#123;null&#125;&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;<span class="literal">undefined</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;div&gt;&#123;true&#125;&lt;/</span>div&gt;</span><br></pre></td></tr></table></figure>
<p>This can be useful to conditionally render React elements. This JSX only renders a <code>&lt;Header /&gt;</code> if <code>showHeader</code> is <code>true</code>:</p>
<p>这有助于有条件地渲染React元素。 如果<code>showHeader</code>为<code>true</code>，则此JSX仅呈现<code>&lt;Header /&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;showHeader &amp;&amp; &lt;Header /&gt;&#125;</span><br><span class="line">  &lt;Content /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>One caveat is that some <a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy" target="_blank" rel="noopener">“falsy” values</a>, such as the <code>0</code> number, are still rendered by React. For example, this code will not behave as you might expect because <code>0</code> will be printed when <code>props.messages</code> is an empty array:</p>
<p>一个值得注意的是，React提供了一些“伪造”值，如<code>0</code>数字。 例如，此代码将不会像您预期的那样运行，因为当<code>props.messages</code>为空数组时将打印<code>0</code>数字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;props.messages.length &amp;&amp;</span><br><span class="line">    &lt;MessageList messages=&#123;props.messages&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>To fix this, make sure that the expression before <code>&amp;&amp;</code> is always boolean:</p>
<p>要解决这个问题，请确保<code>&amp;&amp;</code>之前的表达式始终为布尔值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;props.messages.length &gt; 0 &amp;&amp;</span><br><span class="line">    &lt;MessageList messages=&#123;props.messages&#125; /&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<p>Conversely, if you want a value like <code>false</code>, <code>true</code>, <code>null</code>, or <code>undefined</code> to appear in the output, you have to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#String_conversion" target="_blank" rel="noopener">convert it to a string</a> first:</p>
<p>相反，如果您想要一个像 <code>false</code>, <code>true</code>, <code>null</code>, 或 <code>undefined</code> 这样的值出现在输出中，则必须先将其转换为字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  My JavaScript variable is &#123;String(myVariable)&#125;.</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.lijunbo.com/2017/04/08/rqd-thinking-in-react/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="William-Dream">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="静水流深">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/08/rqd-thinking-in-react/" itemprop="url">
                  Thinking in React(React的思想)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-08T11:11:11+08:00">
                2017-04-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/04/08/rqd-thinking-in-react/" class="leancloud_visitors" data-flag-title="Thinking in React(React的思想)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>React is, in our opinion, the premier way to build big, fast Web apps with JavaScript. It has scaled very well for us at Facebook and Instagram.</p>
<p>在我看来，React 是快速 构建大型<code>Web</code>应用的首选方式。它已经在<code>Facebook</code>和<code>Instagram</code>被我们有了广泛的应用。</p>
<p>One of the many great parts of React is how it makes you think about apps as you build them. In this document, we’ll walk you through the thought process of building a searchable product data table using React.</p>
<p>React许多优点之一：它使得你在构建 app 的过程中不断思考。在本文里，我将带你经历一次使用 React 构建可搜索的商品数据表的思考过程。</p>
<h2 id="Start-With-A-Mock-从模型开始"><a href="#Start-With-A-Mock-从模型开始" class="headerlink" title="Start With A Mock(从模型开始)"></a>Start With A Mock(从模型开始)</h2><p>Imagine that we already have a JSON API and a mock from our designer. The mock looks like this:</p>
<p>想象我们已经有个一个 JSON API 和一个来自设计师的模型。我们的设计师显然做得不够好，因为模型看起来像这样：</p>
<p><img src="https://facebook.github.io/react/img/blog/thinking-in-react-mock.png" alt="Mockup"></p>
<p>Our JSON API returns some data that looks like this:</p>
<p>我们的 JSON API 返回一些看起来像这样的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;category: &quot;Sporting Goods&quot;, price: &quot;$49.99&quot;, stocked: true, name: &quot;Football&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Sporting Goods&quot;, price: &quot;$9.99&quot;, stocked: true, name: &quot;Baseball&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Sporting Goods&quot;, price: &quot;$29.99&quot;, stocked: false, name: &quot;Basketball&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Electronics&quot;, price: &quot;$99.99&quot;, stocked: true, name: &quot;iPod Touch&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Electronics&quot;, price: &quot;$399.99&quot;, stocked: false, name: &quot;iPhone 5&quot;&#125;,</span><br><span class="line">  &#123;category: &quot;Electronics&quot;, price: &quot;$199.99&quot;, stocked: true, name: &quot;Nexus 7&quot;&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<h2 id="Step-1-Break-The-UI-Into-A-Component-Hierarchy"><a href="#Step-1-Break-The-UI-Into-A-Component-Hierarchy" class="headerlink" title="Step 1: Break The UI Into A Component Hierarchy"></a>Step 1: Break The UI Into A Component Hierarchy</h2><h2 id="第一步：把UI拆分为一些有层级结构的组件"><a href="#第一步：把UI拆分为一些有层级结构的组件" class="headerlink" title="第一步：把UI拆分为一些有层级结构的组件"></a>第一步：把UI拆分为一些有层级结构的组件</h2><p>The first thing you’ll want to do is to draw boxes around every component (and subcomponent) in the mock and give them all names. If you’re working with a designer, they may have already done this, so go talk to them! Their Photoshop layer names may end up being the names of your React components!</p>
<p>首先你想要做的，是在模型里的每一个组件周围绘制边框，并给它们命名。如果你和设计师一起工作，他们应该已经完成这步了，所以去和他们谈谈！他们的 Photoshop 图层名也许最终会成为你的 React 组件名。</p>
<p>But how do you know what should be its own component? Just use the same techniques for deciding if you should create a new function or object. One such technique is the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="noopener">single responsibility principle</a>, that is, a component should ideally only do one thing. If it ends up growing, it should be decomposed into smaller subcomponents.</p>
<p>但是你如何知道什么东西应该是独立的组件？只需在你创建一个函数或者对象时，根据是否使用过相同技术来做决定。一种这样的技术是<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" target="_blank" rel="noopener">单一功能原则（single responsibility principle）</a>，也就是一个组件在理想情况下只做一件事情。如果它最终增长了，它就应该被分解为更小的组件。</p>
<p>Since you’re often displaying a JSON data model to a user, you’ll find that if your model was built correctly, your UI (and therefore your component structure) will map nicely. That’s because UI and data models tend to adhere to the same <em>information architecture</em>, which means the work of separating your UI into components is often trivial. Just break it up into components that represent exactly one piece of your data model.</p>
<p>既然你频繁显示一个 JSON 的数据模型给用户，你会发现，如果你的模型构建正确，你的 UI（因此也有你的组件结构）就将映射良好。那是因为 UI 和数据模型趋向附着于相同的 <em>信息架构</em>，这意味着，把你的 UI 分离为组件的工作通常是琐碎的，只需把 UI 拆分成能准确对应数据模型的每块组件。</p>
<p><img src="https://facebook.github.io/react/img/blog/thinking-in-react-components.png" alt="Component diagram"></p>
<p>You’ll see here that we have five components in our simple app. We’ve italicized the data each component represents.</p>
<p>在这里你会看到，在我们的简单的APP里有五个组件。我用斜体表示每个组件的数据。</p>
<ol>
<li><p><strong><code>FilterableProductTable</code> (orange):</strong> contains the entirety of the example</p>
<p><strong>FilterableProductTable (橙色):</strong> 包含示例的整体</p>
</li>
<li><p><strong><code>SearchBar</code> (blue):</strong> receives all <em>user input</em></p>
<p><strong>SearchBar (蓝色):</strong> 接收所有 <em>用户输入</em></p>
</li>
<li><p><strong><code>ProductTable</code> (green):</strong> displays and filters the <em>data collection</em> based on <em>user input</em></p>
<p><strong>ProductTable (绿色):</strong> 基于 <em>用户输入</em> 显示和过滤的 <em>数据集合(data collection)</em></p>
</li>
<li><p><strong><code>ProductCategoryRow</code> (turquoise):</strong> displays a heading for each <em>category</em></p>
<p><strong>ProductCategoryRow (蓝绿色):</strong> 为每个 <em>分类</em> 显示一个列表头</p>
</li>
<li><p><strong><code>ProductRow</code> (red):</strong> displays a row for each <em>product</em></p>
<p><strong>ProductRow (红色):</strong> 为每个 <em>商品</em> 显示一行</p>
</li>
</ol>
<p>If you look at <code>ProductTable</code>, you’ll see that the table header (containing the “Name” and “Price” labels) isn’t its own component. This is a matter of preference, and there’s an argument to be made either way. For this example, we left it as part of <code>ProductTable</code> because it is part of rendering the <em>data collection</em> which is <code>ProductTable</code>‘s responsibility. However, if this header grows to be complex (i.e. if we were to add affordances for sorting), it would certainly make sense to make this its own <code>ProductTableHeader</code> component.</p>
<p>如果你看着 <code>ProductTable</code>，你会看到表头(包含了 “Name” 和 “Price” 标签) 不是独立的组件。这是一个个人喜好问题，并且无论采用哪种方式都有争论。对于这个例子，我把它留做 <code>ProductTable</code> 的一部分，因为它是 <em>data collection</em>渲染的一部分，而 <em>data collection</em> 渲染是 <code>ProductTable</code> 的职责。然而，当列表头增长到复杂的时候(例如：如果我们添加排序功能)，那么使它成为独立的 <code>ProductTableHeader</code> 组件无疑是有意义的。</p>
<p>Now that we’ve identified the components in our mock, let’s arrange them into a hierarchy. This is easy. Components that appear within another component in the mock should appear as a child in the hierarchy:</p>
<p>既然现在我们已经识别出了我们模型中的组件，让我们把他们安排到一个层级中。这很容易。在模型中，出现在一个组件里面的另一组件 ，应该在层级中表现为一种子级关系：</p>
<ul>
<li><code>FilterableProductTable</code><ul>
<li><code>SearchBar</code></li>
<li><code>ProductTable</code><ul>
<li><code>ProductCategoryRow</code></li>
<li><code>ProductRow</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Step-2-Build-A-Static-Version-in-React"><a href="#Step-2-Build-A-Static-Version-in-React" class="headerlink" title="Step 2: Build A Static Version in React"></a>Step 2: Build A Static Version in React</h2><h2 id="第二步：用React创建一个静态版本"><a href="#第二步：用React创建一个静态版本" class="headerlink" title="第二步：用React创建一个静态版本"></a>第二步：用React创建一个静态版本</h2><p></p><p data-height="600" data-theme-id="0" data-slug-hash="vXpAgj" data-default-tab="js" data-user="lacker" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/lacker/pen/vXpAgj/" target="_blank" rel="noopener">Thinking In React: Step 2</a> on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>Now that you have your component hierarchy, it’s time to implement your app. The easiest way is to build a version that takes your data model and renders the UI but has no interactivity. It’s best to decouple these processes because building a static version requires a lot of typing and no thinking, and adding interactivity requires a lot of thinking and not a lot of typing. We’ll see why.</p>
<p>既然你已经了解了组件的层级结构，是时候实现你的app了。简单的方式是构建一个版本，它取走你的数据模型并渲染UI，除了没有互动性。这是将过程解耦的最好办法，因为构建一个静态版本需要不假思索地写很多代码，而添加互动性需要很多思考但不需要太多代码。之后我们将会看到原因。</p>
<p>To build a static version of your app that renders your data model, you’ll want to build components that reuse other components and pass data using <em>props</em>. <em>props</em> are a way of passing data from parent to child. If you’re familiar with the concept of <em>state</em>, <strong>don’t use state at all</strong> to build this static version. State is reserved only for interactivity, that is, data that changes over time. Since this is a static version of the app, you don’t need it.</p>
<p>要构建一个静态版本 app 来渲染你的数据模型，你将会想到构建一个重用其它组件并利用 <em>props</em> 传递数据的组件。<em>props</em> 是一种从父级传递数据到子级的方式。如果你对 <em>state</em> 的观念很熟悉，<strong>绝不要用state</strong> 来构建这个静态版本。State 仅仅是为互动性，也就是随时间变化的数据所预留的。由于这是一个静态版本，你还不需要用到它。</p>
<p>You can build top-down or bottom-up. That is, you can either start with building the components higher up in the hierarchy (i.e. starting with <code>FilterableProductTable</code>) or with the ones lower in it (<code>ProductRow</code>). In simpler examples, it’s usually easier to go top-down, and on larger projects, it’s easier to go bottom-up and write tests as you build.</p>
<p>你可以自顶向下或自底向上的构建。也就是说，你可以既从较高的层级（比如从 <code>FilterableProductTable</code> 开始）也可以从较低的层级（<code>ProductRow</code>）开始构建组件。在较简单的例子里，通常自顶向下要容易一些，然而在更大的项目上，自底向上地构建更容易，并且更方便伴随着构建写测试。</p>
<p>At the end of this step, you’ll have a library of reusable components that render your data model. The components will only have <code>render()</code> methods since this is a static version of your app. The component at the top of the hierarchy (<code>FilterableProductTable</code>) will take your data model as a prop. If you make a change to your underlying data model and call <code>ReactDOM.render()</code> again, the UI will be updated. It’s easy to see how your UI is updated and where to make changes since there’s nothing complicated going on. React’s <strong>one-way data flow</strong> (also called <em>one-way binding</em>) keeps everything modular and fast.</p>
<p>在这一步的最后，你会获得一个渲染数据模型的可重用组件库。这些组件只有 <code>render()</code> 方法，因为这是一个静态版本。在层级顶端的组件 (<code>FilterableProductTable</code>) 将会接受你的数据模型，并将其作为一个prop。如果你改变了底层数据模型，并且再次调用 <code>React.render()</code> ，UI 将会更新。你可以很容易地看到 UI 是如何更新的，以及哪里变动了，因为这没什么复杂的。React的 <strong>单向数据流</strong> (也被称为 <em>单向绑定</em>)使一切保持了模块化和快速。</p>
<p>Simply refer to the <a href="/react/docs/">React docs</a> if you need help executing this step.</p>
<p>如果你在执行这步时需要帮助，请参阅 <a href="http://www.lijunbo.com/react/2017/03/28/rqd-hello-world.html" target="_blank" rel="noopener">React 文档</a>。</p>
<h3 id="A-Brief-Interlude-Props-vs-State"><a href="#A-Brief-Interlude-Props-vs-State" class="headerlink" title="A Brief Interlude: Props vs State"></a>A Brief Interlude: Props vs State</h3><p>There are two types of “model” data in React: props and state. It’s important to understand the distinction between the two; skim <a href="/react/docs/interactivity-and-dynamic-uis.html">the official React docs</a> if you aren’t sure what the difference is.</p>
<h2 id="Step-3-Identify-The-Minimal-but-complete-Representation-Of-UI-State"><a href="#Step-3-Identify-The-Minimal-but-complete-Representation-Of-UI-State" class="headerlink" title="Step 3: Identify The Minimal (but complete) Representation Of UI State"></a>Step 3: Identify The Minimal (but complete) Representation Of UI State</h2><h2 id="第三步：确定最小（但完备）的-UI-state-表达"><a href="#第三步：确定最小（但完备）的-UI-state-表达" class="headerlink" title="第三步：确定最小（但完备）的 UI state 表达"></a>第三步：确定最小（但完备）的 UI state 表达</h2><p>To make your UI interactive, you need to be able to trigger changes to your underlying data model. React makes this easy with <strong>state</strong>.</p>
<p>要让你的 UI 互动，你需要做到触发底层数据模型发生变化。React用 <strong>state</strong> 来让此变得容易。</p>
<p>To build your app correctly, you first need to think of the minimal set of mutable state that your app needs. The key here is DRY: <em>Don’t Repeat Yourself</em>. Figure out the absolute minimal representation of the state your application needs and compute everything else you need on-demand. For example, if you’re building a TODO list, just keep an array of the TODO items around; don’t keep a separate state variable for the count. Instead, when you want to render the TODO count, simply take the length of the TODO items array.</p>
<p>要正确的构建你的 app，你首先需要思考你的 app 需要的可变 state 的最小组。这里的关键是 DRY 原则：<em>Don’t Repeat Yourself(不要重复自己)</em>。想出哪些是你的应用需要的绝对最小 state 表达，并按需计算其他任何数据。例如，如果你要构建一个 TODO 列表，只要保持一个 TODO 项的数组；不要为了计数保持一个单独的 state 变量。当你想渲染 TODO 的计数时，简单的采用 TODO 项目的数组长度作为替代。</p>
<p>fdsajhgfiuytretrewq7lkz2Think of all of the pieces of data in our example application. We have:</p>
<p>考虑我们示例应用中的数据所有块，包括：</p>
<ul>
<li>The original list of products</li>
<li>原始的商品列表</li>
<li>The search text the user has entered</li>
<li>用户输入的搜索文本</li>
<li>The value of the checkbox</li>
<li>复选框的值</li>
<li>The filtered list of products</li>
<li>商品的过滤列表</li>
</ul>
<p>Let’s go through each one and figure out which one is state. Simply ask three questions about each piece of data:</p>
<p>让我们逐个检查出哪一个是state，只需要简单地问以下三个问题:</p>
<ol>
<li><p>Is it passed in from a parent via props? If so, it probably isn’t state.</p>
<p>它是通过props从父级传递来的吗？如果是，它可能不是 state。</p>
</li>
<li><p>Does it remain unchanged over time? If so, it probably isn’t state.</p>
<p>它随时间变化吗？如果不是,它可能不是 state。</p>
</li>
<li><p>Can you compute it based on any other state or props in your component? If so, it isn’t state.</p>
<p>你能基于其他任何组件里的 state 或者 props 计算出它吗？如果是,它可能不是state.</p>
</li>
</ol>
<p>The original list of products is passed in as props, so that’s not state. The search text and the checkbox seem to be state since they change over time and can’t be computed from anything. And finally, the filtered list of products isn’t state because it can be computed by combining the original list of products with the search text and value of the checkbox.</p>
<p>原始的商品列表以 props 传入，所以它不是 state。搜索文本和复选框看起来是 state，因为他们随时间变化并且不能从任何东西计算出。最后，过滤出的商品列表不是 state，因为它可以通过原始列表与搜索文本及复选框的值组合计算得出。</p>
<p>So finally, our state is:(所以最后,我们的 state 是:)</p>
<ul>
<li>The search text the user has entered (用户输入的搜索文本)</li>
<li>The value of the checkbox(checkbox 的值)</li>
</ul>
<h2 id="Step-4-Identify-Where-Your-State-Should-Live"><a href="#Step-4-Identify-Where-Your-State-Should-Live" class="headerlink" title="Step 4: Identify Where Your State Should Live"></a>Step 4: Identify Where Your State Should Live</h2><h2 id="第四步：确定你的-state-应该存在于哪里"><a href="#第四步：确定你的-state-应该存在于哪里" class="headerlink" title="第四步：确定你的 state 应该存在于哪里"></a>第四步：确定你的 state 应该存在于哪里</h2><p></p><p data-height="600" data-theme-id="0" data-slug-hash="ORzEkG" data-default-tab="js" data-user="lacker" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/lacker/pen/ORzEkG/" target="_blank" rel="noopener">Thinking In React: Step 4</a> by Kevin Lacker (<a href="http://codepen.io/lacker" target="_blank" rel="noopener">@lacker</a>) on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<p>OK, so we’ve identified what the minimal set of app state is. Next, we need to identify which component mutates, or <em>owns</em>, this state.</p>
<p>OK，我们已经确定好应用的最小 state 集合是什么。接下来，我们需要确定哪个组件可以改变，或者 <em>拥有</em> 这个state.</p>
<p>Remember: React is all about one-way data flow down the component hierarchy. It may not be immediately clear which component should own what state. <strong>This is often the most challenging part for newcomers to understand,</strong> so follow these steps to figure it out:</p>
<p>记住：React 总是在组件层级中单向数据流动的。可能不能立刻明白哪些组件应该拥有哪些 state。 <strong>这对于新手在理解上经常是最具挑战的一部分，</strong> 所以跟着这几步来弄明白它：</p>
<p>For each piece of state in your application:(对于您的应用程序中的每个状态)</p>
<ul>
<li><p>Identify every component that renders something based on that state.</p>
<p>确定哪些组件要基于 state 来渲染内容。</p>
</li>
<li><p>Find a common owner component (a single component above all the components that need the state in the hierarchy).</p>
<p>找到多个组件的一个共同拥有者（在所有需要这个state组件的层次之上，找出共有的单一组件）。</p>
</li>
<li><p>Either the common owner or another component higher up in the hierarchy should own the state.</p>
<p>要么是共同拥有者，要么是其他在层级里更高级的组件应该拥有这个state。</p>
</li>
<li><p>If you can’t find a component where it makes sense to own the state, create a new component simply for holding the state and add it somewhere in the hierarchy above the common owner component.</p>
<p>如果你找不到一个组件让其可以有意义地拥有这个 state，可以简单地创建一个新的组件 hold 住这个state，并把它添加到比共同拥有者组件更高的层级上。</p>
</li>
</ul>
<p>Let’s run through this strategy for our application:</p>
<p>让我们使用这个策略浏览一遍我们的应用：</p>
<ul>
<li><p><code>ProductTable</code> needs to filter the product list based on state and <code>SearchBar</code> needs to display the search text and checked state.</p>
<p><code>ProductTable</code> 需要基于 state 过滤产品列表，<code>SearchBar</code> 需要显示搜索文本和选择状态。</p>
</li>
<li><p>The common owner component is <code>FilterableProductTable</code>.</p>
</li>
<li><p>共同拥有者组件是 <code>FilterableProductTable</code>。</p>
</li>
<li><p>It conceptually makes sense for the filter text and checked value to live in <code>FilterableProductTable</code></p>
<p>对于过滤文本和选择框值存在于 <code>FilterableProductTable</code>，从概念上讲是有意义的。</p>
</li>
</ul>
<p>Cool, so we’ve decided that our state lives in <code>FilterableProductTable</code>. First, add an instance property <code>this.state = {filterText: &#39;&#39;, inStockOnly: false}</code> to <code>FilterableProductTable</code>‘s <code>constructor</code> to reflect the initial state of your application. Then, pass <code>filterText</code> and <code>inStockOnly</code> to <code>ProductTable</code> and <code>SearchBar</code> as a prop. Finally, use these props to filter the rows in <code>ProductTable</code> and set the values of the form fields in <code>SearchBar</code>.</p>
<p>酷，我们已经确定了我们的 state 存在于 <code>FilterableProductTable</code>。首先，向<code>FilterableProductTable</code>的构造函数添加一个实例属性<code>this.state = {filterText：&#39;，inStockOnly：false}</code>以反映应用程序的初始状态。然后，传递<code>filterText</code> 和 <code>inStockOnly</code> 给 <code>ProductTable</code> 和 <code>SearchBar</code> 作为属性。最后，使用这些属性来过滤 <code>ProductTable</code> 中的行和设置 <code>SearchBar</code> 的表单项的值。</p>
<p>You can start seeing how your application will behave: set <code>filterText</code> to <code>&quot;ball&quot;</code> and refresh your app. You’ll see that the data table is updated correctly.</p>
<p>你可以开始看看你的应用将有怎样的行为了: 设置 <code>filterText</code> 为 <code>&quot;ball&quot;</code> 并刷新你的 app。你将可以看到数据表被正确地更新。</p>
<h2 id="Step-5-Add-Inverse-Data-Flow"><a href="#Step-5-Add-Inverse-Data-Flow" class="headerlink" title="Step 5: Add Inverse Data Flow"></a>Step 5: Add Inverse Data Flow</h2><h2 id="第五步：添加反向数据流"><a href="#第五步：添加反向数据流" class="headerlink" title="第五步：添加反向数据流"></a>第五步：添加反向数据流</h2><p></p><p data-height="265" data-theme-id="0" data-slug-hash="qRqmjd" data-default-tab="js,result" data-user="rohan10" data-embed-version="2" data-pen-title="Thinking In React: Step 5" class="codepen">See the Pen <a href="http://codepen.io/rohan10/pen/qRqmjd" target="_blank" rel="noopener">Thinking In React: Step 5</a> on <a href="http://codepen.io" target="_blank" rel="noopener">CodePen</a>.</p><p></p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

<p>So far, we’ve built an app that renders correctly as a function of props and state flowing down the hierarchy. Now it’s time to support data flowing the other way: the form components deep in the hierarchy need to update the state in <code>FilterableProductTable</code>.</p>
<p>到目前为止，我们已经构建了一个应用, 它能够使用 props 和 state的功能沿着自顶向下层级正确渲染。现在是时候支持另一种数据流了：在层级深处的表单组件需要更新 <code>FilterableProductTable</code> 里的 state。</p>
<p>React makes this data flow explicit to make it easy to understand how your program works, but it does require a little more typing than traditional two-way data binding.</p>
<p>React让数据流显式流动，使您可以轻松了解程序的工作原理，但它比传统的双向数据绑定需要写更多的代码。</p>
<p>If you try to type or check the box in the current version of the example, you’ll see that React ignores your input. This is intentional, as we’ve set the <code>value</code> prop of the <code>input</code> to always be equal to the <code>state</code> passed in from <code>FilterableProductTable</code>.</p>
<p>如果你尝试在当前版本的示例中输入或者选中复选框，你会发现 React 忽略了你的输入。这是有意的，因为我们已经设置了 <code>input</code> 的 <code>value</code> prop 值总是与 <code>FilterableProductTable</code> 传递过来的 <code>state</code> 一致。</p>
<p>Let’s think about what we want to happen. We want to make sure that whenever the user changes the form, we update the state to reflect the user input. Since components should only update their own state, <code>FilterableProductTable</code> will pass callbacks to <code>SearchBar</code> that will fire whenever the state should be updated. We can use the <code>onChange</code> event on the inputs to be notified of it. The callbacks passed by <code>FilterableProductTable</code> will call <code>setState()</code>, and the app will be updated.</p>
<p>让我们思考下希望发生什么。我们想确保每当用户改变表单，就通过更新 state 来反映用户的输入。由于组件应该只更新自己拥有的 state ， <code>FilterableProductTable</code> 将会传递一个回调函数给 <code>SearchBar</code> ，每当 state 应被更新时回调函数就会被调用。我们可以使用 input 的 <code>onChange</code> 事件来接收它的通知。 <code>FilterableProductTable</code> 传递的回调函数将会调用 <code>setState()</code> ，然后应用将会被更新。</p>
<p>Though this sounds complex, it’s really just a few lines of code. And it’s really explicit how your data is flowing throughout the app.</p>
<p>虽然这听起来复杂，但是实际上只有几行代码。并且这明确显示出了数据在应用中从始至终是如何流动的。</p>
<h2 id="And-That’s-It-好了，就是这样"><a href="#And-That’s-It-好了，就是这样" class="headerlink" title="And That’s It (好了，就是这样)"></a>And That’s It (好了，就是这样)</h2><p>Hopefully, this gives you an idea of how to think about building components and applications with React. While it may be a little more typing than you’re used to, remember that code is read far more than it’s written, and it’s extremely easy to read this modular, explicit code. As you start to build large libraries of components, you’ll appreciate this explicitness and modularity, and with code reuse, your lines of code will start to shrink. :)</p>
<p>希望这给了你一个怎样思考用React构建组件和应用的概念。虽然可能比你过往的习惯要多敲一点代码，但记住，读代码的时间远比写代码的时间多，并且阅读这种模块化的、显式的代码是极为容易的。当你开始构建大型组件库时，你会非常感激这种清晰性和模块化，并且随着代码的重用，你的代码行数将会开始缩减。:)</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://www.gravatar.com/avatar/c8b98e5df395f0e0fd3b47948b37b881.jpg?s=215"
               alt="William-Dream" />
          <p class="site-author-name" itemprop="name">William-Dream</p>
           
              <p class="site-description motion-element" itemprop="description">为了梦-追梦,我的英文名由此而来</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">83</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/li-jun-bo" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.lijunbo.com/" title="Net" target="_blank">Net</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">William-Dream</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("PWTRJaGA9VmnmuJISstgYQVk-gzGzoHsz", "OhMVXOeW5jbdIohUayYbpq1v");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

</body>
</html>
